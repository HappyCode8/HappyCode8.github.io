todo: 跟java里边web开发的一些笔记合一下

## 各种O的概念

- VO（`View Object`）：**视图对象**，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。
- DTO（`Data Transfer Object`）：**数据传输对象**，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，更符合泛指用于展示层与服务层之间的数据传输对象。
- BO（`Business Object`）：**业务对象**，把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。
- PO（`Persistent Object`）：**持久化对象**，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。
- DO（`Domain Object`）：**领域对象**，就是从现实世界中抽象出来的有形或无形的业务实体。

## VO与DTO

某公司有一个后台服务，服务层有一个getUser的方法返回一个系统用户，包含sex(性别)、年龄。对于服务层来说，DTO只从语义上定义，可能是这样的：

```json
{
 "gender":"男",
 "age":35
}
```

但这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，比如管理端要求显示准确的年龄，而应用端为了保护客户隐私，只需要显示一个年龄段即可。

管理端VO：

```json
{
 "gender":"男",
 "age":35
}
```

应用端VO：

```json
{
 "gender":"男",
 "age":30~40
}
```

DTO很有存在的必要，根据职责单一原则，服务层只负责业务，与具体的表现形式无关，DTO不应该出现与表现形式的耦合，DTO定义的是原始数据，VO再对DTO数据进行解释。这下VO和DTO用法就清晰很多了。

## BO和PO

PO-1是交易记录对象，PO-2是登录记录对象，PO-3是商品浏览记录对象，PO-4是添加购物车记录对象，PO-5是搜索记录对象，BO是个人网站行为对象，BO对象：{PO-1;PO-2;PO-3;PO-4;PO-5}。这样做的优点不言而喻，维护代码的时候查看BO，就能知道这块逻辑涉及多少表（PO）。

## BO和DTO

BO是业务对象，DTO是数据传输对象，虽然BO也可以排列组合数据，但它的功能是对内的，比如上个例子中的BO对象包括{PO-1;PO-2;PO-3;PO-4;PO-5}还有其他字段属性，但在提供对外接口时，BO对象中的某些属性对象可能用不到或者不方便对外暴露，那么此时DTO只需要在BO的基础上，抽取自己需要的数据，然后对外提供。

在这个关系上，通常不会有数据内容的变化，内容变化要么在BO内部业务计算的时候完成，要么在解释VO的时候完成。

<img src="https://s2.loli.net/2022/03/26/Q4F1KhOVewN9YUP.png" alt="各种O的关系" style="zoom: 33%;" />

另附这些概念命名规范：

- 数据对象：xxxPO，xxx即为数据表名。(也可DO)
- 数据传输对象：xxxDTO，xxx为业务领域相关的名称。
- 展示对象：xxxVO，xxx一般为网页名称。
- 业务对象：xxxBO，xxx是业务名称。



## 怎么优雅的转化O？

>尽量使用一些工具，org.springframework.beans.BeanUtils#copyProperties，mapstruct等，org.springframework.beans.BeanUtils#copyProperties是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。
>
>转化的语义：
>
>```java
>@PostMapping
>public User addUser(UserInputDTO userInputDTO){
>    User user = new User();
>    //虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好
>    BeanUtils.copyProperties(userInputDTO,user);
>    return userService.addUser(user);
>}
>
>//这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中
>@PostMapping
> public User addUser(UserInputDTO userInputDTO){
>         User user = convertFor(userInputDTO);
>         return userService.addUser(user);
> }
>
> private User convertFor(UserInputDTO userInputDTO){
>         User user = new User();
>         BeanUtils.copyProperties(userInputDTO,user);
>         return user;
> }
>
>//实际开发中我们发现有很多这样的操作以后，那么应该定义好一个接口，让所有这样的操作都有规则的进行。果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。
>public interface DTOConvert<S,T> {
>    T convert(S s);
>}
>public class UserInputDTOConvert implements DTOConvert {
>  @Override
>  public User convert(UserInputDTO userInputDTO) {
>    User user = new User();
>    BeanUtils.copyProperties(userInputDTO,user);
>    return user;
>  }
>}
>@RequestMapping("/v1/api/user")
>@RestController
>public class UserApi {
>    @Autowired
>    private UserService userService;
>
>    @PostMapping
>    public User addUser(UserInputDTO userInputDTO){
>        User user = new UserInputDTOConvert().convert(userInputDTO);
>        return userService.addUser(user);
>    }
>}
>
>//我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的。所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：
>@PostMapping
>public UserOutputDTO addUser(UserInputDTO userInputDTO){
>        User user = new UserInputDTOConvert().convert(userInputDTO);
>        User saveUserResult = userService.addUser(user);
>        UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult);
>        return result;
>}
>//这样你的 API 才更健全。
>
>User user = new UserInputDTOConvert().convert(userInputDTO);
>
>//你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢？
>public class UserInputDTO {
>private String username;
>private int age;
>
>    public String getUsername() {
>        return username;
>    }
>
>    public void setUsername(String username) {
>        this.username = username;
>    }
>
>    public int getAge() {
>        return age;
>    }
>
>    public void setAge(int age) {
>        this.age = age;
>    }
>
>
>    public User convertToUser(){
>        UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert();
>        User convert = userInputDTOConvert.convert(this);
>        return convert;
>    }
>
>    private static class UserInputDTOConvert implements DTOConvert<UserInputDTO,User> {
>        @Override
>        public User convert(UserInputDTO userInputDTO) {
>            User user = new User();
>            BeanUtils.copyProperties(userInputDTO,user);
>            return user;
>        }
>    }
>
>}
>
>//这样原来的实现由
>User user = new UserInputDTOConvert().convert(userInputDTO);
>User saveUserResult = userService.addUser(user);
>//转化为
>User user = userInputDTO.convertToUser();
>User saveUserResult = userService.addUser(user);
>//我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。
>
>//Guava com.google.common.base.Convert有一段这样的定义
>public abstract class Converter<A, B> implements Function<A, B> {
>    protected abstract B doForward(A a);
>    protected abstract A doBackward(B b);
>    //其他略
>}
>//可以把原来代码中的部分改为下列实现
>private static class UserInputDTOConvert extends Converter<UserInputDTO, User> {
>         @Override
>         protected User doForward(UserInputDTO userInputDTO) {
>                 User user = new User();
>                 BeanUtils.copyProperties(userInputDTO,user);
>                 return user;
>         }
>
>         @Override
>         protected UserInputDTO doBackward(User user) {
>                 UserInputDTO userInputDTO = new UserInputDTO();
>                 BeanUtils.copyProperties(user,userInputDTO);
>                 return userInputDTO;
>         }
> }
>
>//再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：
>public class UserDTO {
>    @NotNull
>    private String username;
>    @NotNull
>    private int age;
>        //其他代码略
>}
>@PostMapping
>    public UserDTO addUser(@Valid UserDTO userDTO){
>            User user =  userDTO.convertToUser();
>            User saveResultUser = userService.addUser(user);
>            UserDTO result = userDTO.convertFor(saveResultUser);
>            return result;
>    }
>
>//我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常（带有错误码的异常）。
>@PostMapping
>public UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult){
>     checkDTOParams(bindingResult);
>
>     User user =  userDTO.convertToUser();
>     User saveResultUser = userService.addUser(user);
>     UserDTO result = userDTO.convertFor(saveResultUser);
>     return result;
>}
>private void checkDTOParams(BindingResult bindingResult){
>     if(bindingResult.hasErrors()){
>             //throw new 带验证码的验证错误异常
>     }
>}
>
>//使用链式调用 lombok的@Accessors(chain = true)
>tudent student = new Student()
>        .setAge(24)
>        .setName("zs");
>
>//接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）：
>@Accessors(chain = true)
>@Setter
>@Getter
>@RequiredArgsConstructor(staticName = "ofName")
>public class Student {
>    @NonNull private String name;
>    private int age;
>}
>
>测试代码：
>Student student = Student.ofName("zs");
>
>//当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：
>@RequiredArgsConstructor(staticName = "of")
>public class Student {
>        @NonNull private String name;
>}
>
>测试代码：
>Student student = Student.of("zs");
>
>当然他仍然是支持链式调用的：
>Student student = Student.of("zs").setAge(24);
>
>//使用lombok的@Builder
>```

## domain还是entity

>domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的。
>
>所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为：com.xxx.entity。

## 贫血模型 or 领域模型

> 领域模型是对领域内的概念类或现实世界中对象的可视化表示。
>
> 贫血模型是指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层。贫血模型的缺点是不够面向对象，领域对象只是作为保存状态或者传递状态使用，它是没有生命的，只有数据没有行为的对象不是真正的对象。
>
> web开发中，贫血模型一般这样使用：
>
> （1）铺设扁平的原子业务逻辑层，即简单的CRUD操作（含批量数据操作）
>
> （2）特定业务清晰的逻辑通过Facade层来组装原子操作实现。
>
> （3）给业务逻辑层实施模块划分，保持模块之间的松耦合的关系。
>
> **举例说明**
>
> **原子业务逻辑层（Service）提供了用户模型的条件查询方法：**
>
> List<User> queryUser(Condition con
>
> **Facade层则提供了一种特定的业务场景的分子接口，满足18岁的中国公民，内部实现调用的正是上述的原子接口：**
>
> List<User> queryAdultChinese()
>
> Facade、Service层纵向划分为几个大的领域包：用户、内容和产品。

## 业务驱动技术 or 技术驱动业务

> 业务驱动技术 or 技术驱动业务 ？其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置。
>
> **业务驱动技术：**如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。
>
> **技术驱动业务：**如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益。
>
> 比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。
>
> 我相信大部分人还都处于业务驱动技术的方向吧。所以你既然不能驱动业务，那就请拥抱业务变化吧。

# 消除if...else

## 使用策略模式

```java
public interface IPay {  
    void pay();  
}  

@Service  
public class AliaPay implements IPay {  
     @Override  
     public void pay() {  
        System.out.println("===发起支付宝支付===");  
     }  
}  

@Service  
public class WeixinPay implements IPay {  
     @Override  
     public void pay() {  
         System.out.println("===发起微信支付===");  
     }  
}  
  
@Service  
public class JingDongPay implements IPay {  
     @Override  
     public void pay() {  
        System.out.println("===发起京东支付===");  
     }  
}  

@Service  
public class PayService {  
     @Autowired  
     private AliaPay aliaPay;  
     @Autowired  
     private WeixinPay weixinPay;  
     @Autowired  
     private JingDongPay jingDongPay;  
      
     //问题在于如果支付方式越来越多，比如：又加了百度支付、美团支付、银联支付等等，就需要改toPay方法的代码，增加新的else...if判断，判断多了就会导致逻辑越来越多？这里违法了设计模式六大原则的：开闭原则 和 单一职责原则
     public void toPay(String code) {  
         if ("alia".equals(code)) {  
             aliaPay.pay();  
         } else if ("weixin".equals(code)) {  
              weixinPay.pay();  
         } else if ("jingdong".equals(code)) {  
              jingDongPay.pay();  
         } else {  
              System.out.println("找不到支付方式");  
         }  
     }  
}
```

## 使用注解

```java
@Retention(RetentionPolicy.RUNTIME)  
@Target(ElementType.TYPE)  
public @interface PayCode {  

     String value();    
     String name();  
}

@PayCode(value = "alia", name = "支付宝支付")  
@Service  
public class AliaPay implements IPay {  

     @Override  
     public void pay() {  
         System.out.println("===发起支付宝支付===");  
     }  
}  

 
@PayCode(value = "weixin", name = "微信支付")  
@Service  
public class WeixinPay implements IPay {  
 
     @Override  
     public void pay() {  
         System.out.println("===发起微信支付===");  
     }  
} 

 
@PayCode(value = "jingdong", name = "京东支付")  
@Service  
public class JingDongPay implements IPay {  
 
     @Override  
     public void pay() {  
        System.out.println("===发起京东支付===");  
     }  
}

//
@Service  
public class PayService2 implements ApplicationListener<ContextRefreshedEvent> {  
 
     private static Map<String, IPay> payMap = null;  
     
     @Override  
     public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {  
         ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();  
         Map<String, Object> beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode.class);  
        
         if (beansWithAnnotation != null) {  
             payMap = new HashMap<>();  
             beansWithAnnotation.forEach((key, value) ->{  
                 String bizType = value.getClass().getAnnotation(PayCode.class).value();  
                 payMap.put(bizType, (IPay) value);  
             });  
         }  
     }  
    
     public void pay(String code) {  
        payMap.get(code).pay();  
     }  
}
```

## 动态拼接名称

```java
@Service  
public class PayService3 implements ApplicationContextAware {   
     private ApplicationContext applicationContext;  
     private static final String SUFFIX = "Pay";  

     @Override  
     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
        this.applicationContext = applicationContext;  
     }  

     public void toPay(String payCode) {  
         ((IPay) applicationContext.getBean(getBeanName(payCode))).pay();  
     }  

     public String getBeanName(String payCode) {  
         return payCode + SUFFIX;  
     }  
}
```

## 模板方法判断

```java
@Service  
public class PayService3 implements ApplicationContextAware {   
     private ApplicationContext applicationContext;  
     private static final String SUFFIX = "Pay";  

     @Override  
     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
        this.applicationContext = applicationContext;  
     }  

     public void toPay(String payCode) {  
         ((IPay) applicationContext.getBean(getBeanName(payCode))).pay();  
     }  

     public String getBeanName(String payCode) {  
         return payCode + SUFFIX;  
     }  
}

@Service  
public class PayService4 implements ApplicationContextAware, InitializingBean {  

     private ApplicationContext applicationContext;  
     private List<IPay> payList = null;  

     @Override  
     public void afterPropertiesSet() throws Exception {  
         if (payList == null) {  
             payList = new ArrayList<>();  
             Map<String, IPay> beansOfType = applicationContext.getBeansOfType(IPay.class);  
 
             beansOfType.forEach((key, value) -> payList.add(value));  
         }  
     }  
 
     @Override  
     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
        this.applicationContext = applicationContext;  
     }  
 
     public void toPay(String code) {  
         for (IPay iPay : payList) {  
             if (iPay.support(code)) {  
                iPay.pay();  
             }  
         }  
     }  
}
```

## 策略+工厂模式

```java
public interface IPay {
    void pay();
}

@Service
public class AliaPay implements IPay {

    @PostConstruct
    public void init() {
        PayStrategyFactory.register("aliaPay", this);
    }


    @Override
    public void pay() {
        System.out.println("===发起支付宝支付===");
    }

}

@Service
public class WeixinPay implements IPay {

    @PostConstruct
    public void init() {
        PayStrategyFactory.register("weixinPay", this);
    }

    @Override
    public void pay() {
        System.out.println("===发起微信支付===");
    }
}

@Service
public class JingDongPay implements IPay {

    @PostConstruct
    public void init() {
        PayStrategyFactory.register("jingDongPay", this);
    }

    @Override
    public void pay() {
        System.out.println("===发起京东支付===");
    }
}

public class PayStrategyFactory {

    private static Map<String, IPay> PAY_REGISTERS = new HashMap<>();


    public static void register(String code, IPay iPay) {
        if (null != code && !"".equals(code)) {
            PAY_REGISTERS.put(code, iPay);
        }
    }


    public static IPay get(String code) {
        return PAY_REGISTERS.get(code);
    }
}

@Service
public class PayService3 {

    public void toPay(String code) {
        PayStrategyFactory.get(code).pay();
    }
}
```

## 责任链模式

```java
public abstract class PayHandler {

    @Getter
    @Setter
    protected PayHandler next;

    public abstract void pay(String pay);

}

@Service
public class AliaPayHandler extends PayHandler {


    @Override
    public void pay(String code) {
        if ("alia".equals(code)) {
            System.out.println("===发起支付宝支付===");
        } else {
            getNext().pay(code);
        }
    }

}

@Service
public class WeixinPayHandler extends PayHandler {

    @Override
    public void pay(String code) {
        if ("weixin".equals(code)) {
            System.out.println("===发起微信支付===");
        } else {
            getNext().pay(code);
        }
    }
}

@Service
public class JingDongPayHandler extends PayHandler {


    @Override
    public void pay(String code) {
        if ("jingdong".equals(code)) {
            System.out.println("===发起京东支付===");
        } else {
            getNext().pay(code);
        }
    }
}

@Service
public class PayHandlerChain implements ApplicationContextAware, InitializingBean {

    private ApplicationContext applicationContext;
    private PayHandler header;


    public void handlePay(String code) {
        header.pay(code);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        Map<String, PayHandler> beansOfTypeMap = applicationContext.getBeansOfType(PayHandler.class);
        if (beansOfTypeMap == null || beansOfTypeMap.size() == 0) {
            return;
        }
        List<PayHandler> handlers = beansOfTypeMap.values().stream().collect(Collectors.toList());
        for (int i = 0; i < handlers.size(); i++) {
            PayHandler payHandler = handlers.get(i);
            if (i != handlers.size() - 1) {
                payHandler.setNext(handlers.get(i + 1));
            }
        }
        header = handlers.get(0);
    }
}
```

## 其它方式

- 使用枚举代替

  ```java
  public String getMessage(int code) {  
       if (code == 1) {  
          return "成功";  
       } else if (code == -1) {  
          return "失败";  
       } else if (code == -2) {  
          return "网络超时";  
       } else if (code == -3) {  
          return "参数错误";  
       }  
       throw new RuntimeException("code错误");  
  }
  //使用枚举以后
  public enum MessageEnum {  
       SUCCESS(1, "成功"),  
       FAIL(-1, "失败"),  
       TIME_OUT(-2, "网络超时"),  
       PARAM_ERROR(-3, "参数错误");  
  
       private int code;  
       private String message;  
  
       MessageEnum(int code, String message) {  
           this.code = code;  
           this.message = message;  
       }  
     
       public int getCode() {  
          return this.code;  
       }  
  
       public String getMessage() {  
          return this.message;  
       }  
    
       public static MessageEnum getMessageEnum(int code) {  
          return Arrays.stream(MessageEnum.values()).filter(x -> x.code == code).findFirst().orElse(null);  
       }  
  }
  //调用方法改造
  public String getMessage(int code) {  
       MessageEnum messageEnum = MessageEnum.getMessageEnum(code);  
       return messageEnum.getMessage();  
  }
  ```

- 使用三目运算符(只能消除两个)

  ```java
  public String getMessage2(int code) {  
      return code == 1 ? "成功" : "失败";  
  }
  ```

- 使用断言代替参数检测

  ```java
  public void save(Integer code，String name) {  
       if(code == null) {
         throw Exception("code不能为空");     
       } else {
           if(name == null) {
               throw Exception("name不能为空");     
           } else {
               System.out.println("doSave");
           }
       }
   }
  
  public String save2(Integer code，String name) {      
       Assert.notNull(code,"code不能为空"); 
       Assert.notNull(name,"name不能为空"); 
       System.out.println("doSave");
   }
  ```

# 如何写出高效代码

## 判断存在

**反例** 一些小伙伴会这样实现，先查从用户信息表查出用户记录，然后再去判断是否是会员:

```java
<select id="selectUserByUserId" resultMap="BaseResultMap">
     selct user_id , vip_flag from  user_info where user_id =#{userId};
 </select>

boolean isVip (String userId){
 UserInfo userInfo = userInfoDAp.selectUserByUserId(userId);
 return UserInfo!=null && "Y".equals(userInfo.getVipFlag())
}
```

**正例** 针对这种业务场景，其实更好的实现，是直接`select count`一下，或者select limit 1如下：

```java
<select id="countVipUserByUserId" resultType="java.lang.Integer">
     selct count(1) from  user_info where user_id =#{userId} and vip_flag ='Y';
 </select>
 
 boolean isVip (String userId){
  int vipNum = userInfoDAp.countVipUserByUserId(userId);
  return vipNum>0
}
```

## 少用select *

- 节省资源、减少网络开销。
- 可能用到覆盖索引，减少回表，提高查询效率。

## 初始化集合时，指定容量

假设要插入15个

```java
//initialCapacity = 15/0.75+1=21
 Map map = new HashMap(21);
 
 //又因为hashMap的容量跟2的幂有关，所以可以取32的容量
 Map map = new HashMap(32);
```

## catch的异常，要打印具体的exception

## 覆写toString

- 不覆写的时候，默认的实现是“类名@散列码的无符号十六进制”，这样子打印日志就没啥意思，你都不知道打印的是什么内容。

## 方法参数过长

- 使用对象包装

## 使用缓冲流减少IO

- 使用`FileInputStream`、`FileOutputStream`实现文件读写功能，是没有什么问题的。但是可以使用缓冲流`BufferedReader`、`BufferedWriter`、`BufferedInputStream`、`BufferedOutputStream`等，减少IO次数，提高读写效率。

  > 如果是不带缓冲的流，读取到一个字节或者字符的，就会直接输出数据了。而带缓冲的流，读取到一个字节或者字符时，先不输出，而是等达到缓冲区的最大容量，才一次性输出。

## 少用魔法值

## 成员变量值不变时，优先定义静态常量

> 因为如果定义为static，即类静态常量，在每个实例对象中，它只有一份副本。如果是成员变量，每个实例对象中，都各有一份副本。显然，如果这个变量不会变的话，定义为静态常量更好一些。

## 不重要的方法

- 异步处理，并且可降级，比如通知、邮件、短信等

## YYYY跨年

```java
Calendar calendar = Calendar.getInstance();
calendar.set(2019, Calendar.DECEMBER, 31);

Date testDate = calendar.getTime();

SimpleDateFormat dtf = new SimpleDateFormat("YYYY-MM-dd");
System.out.println("2019-12-31 转 YYYY-MM-dd 格式后 " + dtf.format(testDate));
```

运行结果：

```
2019-12-31 转 YYYY-MM-dd 格式后 2020-12-31
```

> 为什么明明是2019年12月31号，就转了一下格式，就变成了2020年12月31号了？因为YYYY是基于周来计算年的，它指向当天所在周属于的年份，一周从周日开始算起，周六结束，只要本周跨年，那么这一周就算下一年的了。正确姿势是使用yyyy格式。

## 类final

- 如果一个类确定不会被继承，不会拿来搞AOP骚操作，可以指定final修饰符，如用final修饰一个工具类。Java编译器会找机会内联所有的final方法，提升了Java运行效率。

## 与类成员变量无关的方法，应当声明成静态方法

- 有些方法，与实例成员变量无关，就可以声明为静态方法。这一点，工具类用得很多

## 不要用一个Exception捕获所有可能的异常

## 函数不要过度封装

## 深分页优化

```java
//方案一 ：返回上次查询的最大记录(偏移量)
select id，name from user_info where id>10000 limit #{pageSize}.

//方案二：order by + 索引
select id，name from user_info order by id  limit #{offset},#{pageSize}

//方案三：在业务允许的情况下限制页数：
```

## 定时任务

- linux的crontab
- jdk的定时任务
  - Thread死循环+sleep
  - Timer的TimerTask
- spring
  - spring task @Scheduled
- 分布式定时任务
  - xxl-job(大众点评)
  - elastic-job（当当点评）
  - Saturn（唯品会）
  - TBSchedule（阿里）

