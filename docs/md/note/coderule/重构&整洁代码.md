# 重构，改善既有代码的设计

## 代码的坏味道

- Duplicated Code(重复代码)

- Long Method(过长函数)

- Large Class(过大的类)

- Long Parameter List(过长参数列)

- Divergent Change(发散式变化)

  如果新加入一个数据库，我必须修改这三个函数

  如果新出现一种金融工具，我必须修改这四个函数

- Shotgun Surgery(霰弹式修改)

  需要修改的代码散布四处

- Feature Envy(依恋情结)

  函数对某个类的兴趣高过对自己所处类的兴趣

- Data Clumps(数据泥团)

  有时，代码的不同部分包含相同的变量组（例如用于连接到数据库的参数）。这些绑在一起出现的数据应该拥有自己的对象。

- Primitive Obsession(基本类型偏执)

  不愿意在小任务上运用小对象——像是结合数值和币种的money类、由一个起始值和一个结束值组成的range类、电话号码或邮政编码（ZIP)等的特殊字符串

- Switch Statements(Switch惊悚现身)

- Parallel Inheritance Hierarchies(平行继承体系)

  在这种情况下，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。 

- Lazy Class(冗赘类)

- Speculative Generality(夸夸其谈未来性)

- Temporary Field(令人迷惑的暂时字段)

- Message Chains(过度耦合的消息链)

- Message Chains(过度耦合的消息链)

- Middle Man(中间人)

- Inappropriate Intimacy(狎昵关系)

- Alternative Classes with Different Interfaces (异曲同工的类)

- Incomplete Library Class(不完美的库类)

- Data Class(纯稚的数据类)

- Refused Bequest(被拒绝的遗赠)

- Comments(过多的注释)

- 

# 代码整洁之道

## 第二章 命名

- 名副其实

  ```java
  public List<int[]> getThem() {
  	List<int[]> list1 = new ArrayList<int[]>();
  	for (int[] x : theList)
  			if (x[0] == 4)
  					list1.add(x);
  	return list1;
  }
  
  //扫雷游戏，盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而该种状态值为4表示“已标记。
  public List<int[]> getFlaggedCells() {
  	List<int[]> flaggedCells = new ArrayList<int[]>();
  	for (int[] cell : gameBoard)
  			if (cell[STATUS_VALUE] == FLAGGED)
  					flaggedCells.add(cell);
  	return flaggedCells;
  }
  
  public List<Cell> getFlaggedCells() {
  	List<Cell> flaggedCells = new ArrayList<Cell>();
  	for (Cell cell : gameBoard)
  			if (cell.isFlagged())
  					flaggedCells.add(cell);
  	return flaggedCells;
  }
  ```

- 避免误导

  O0l1

- 做有意义的区分

  ```java
  public static void copyChars(char a1[], char a2[]) {
    for (int i = 0; i < a1.length; i++) {
      a2[i] = a1[i];
    }
  }
  ```

  



