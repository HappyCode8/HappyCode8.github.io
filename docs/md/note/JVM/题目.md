## 哪些情况会导致stop the world？各种GC回收器STW几次?

## 对象分配的过程？

## 虚拟机怎么保证多线程分配对象的正确性？

## 常用的JVM调优工具？

## 常用的JVM启动参数？

## 什么是内存震荡？为什么要避免内存震荡？
> -Xms和-Xmx不一致时会导致JVM反复增加和缩减堆内存，这会导致频繁GC(吞吐变低)，但是每次GC的时间相对于稳定的堆却有所下降(响应时间变小)
> 当堆的空闲比例低于-XX:MinHeapFreeRatio(默认40)扩展，高于-XX:MaxHeapFreeRatio(默认70)压缩
> 只有-Xms和-Xmx不一致时上述参数才会生效

## OOM排查

>1. 一次性申请太多，一次查1000W数据
>
>   更改申请对象数量
>
>2. 内存资源耗尽未释放
>
>   未释放对象，频繁建立RPC客户端、JDBC线程而不释放
>
>3. 本身资源不够
>
>   jmap -heap 进程号          查看堆信息
>
>系统已经OOM挂了:提前设置-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=,内存溢出时会导入到指定文件名称（如果没设置神仙难救，根据堆栈信息也可以但是实际系统很复杂很难找到），然后结合visualVM进行定位，找到较大的对象，然后根据GCroot进行查找
>
>系统还没挂掉：导出dump文件：jmap -dump:format=b,file=xxx.hprof 进程号，但是注意会引起GC，导致STW  或者可以使用一些工具，arthas（阿里的工具应该是）
>
>结合jvisualvm进行调试：查看最多跟业务有关对象-> 找到GCROOT->查看线程栈

## 如何定位以及预防死锁

> ```java
> public class Account {
>  public Integer id;
>  public String name;
>  public Integer balance=100;
>  public AtomicInteger atomicInteger=new AtomicInteger(100);
> 
>  public Account(int id, String name) {
>      this.id=id;
>      this.name=name;
>  }
> 
>  public void transfer(Account target, int amount) throws InterruptedException{
>      synchronized (this){//锁住转出账户
>          System.out.println(Thread.currentThread().getName()+"begin");
>          Thread.sleep(2000);
>          synchronized (target){//锁住转入账户
>              this.balance-=amount;
>              target.balance+=amount;
>              System.out.println(Thread.currentThread().getName()+"end");
>          }
>      }
>  }
> 
>  public static void main(String[] args) {
>      Account zhangshan=new Account(1, "zhangshan");
>      Account lisi=new Account(2, "lisi");
>      new Thread(()->{
>          try {
>              zhangshan.transfer(lisi,50);
>          } catch (InterruptedException e) {
>              e.printStackTrace();
>          }
>      }, "t1").start();
>      new Thread(()->{
>          try {
>              lisi.transfer(zhangshan,50);
>          } catch (InterruptedException e) {
>              e.printStackTrace();
>          }
>      }, "t2").start();
>  }
> }
> 
> t2begin
> t1begin
> ```
>
> **jps** 找到进程号
>
> **jstack 进程ID**  找到信息 
>
> **为什么会产生死锁？**
>
> 互斥、占有且等待、不可抢占、循环等待
>
> **怎么破坏条件解决死锁？**
>
> 1. 不使用互斥锁，使用原子操作（破坏互斥）
>
>    ```java
>    public void transfer(Account target, int amount) throws InterruptedException{
>         synchronized (this){//锁住转出账户
>                 this.atomicBalance.addAndGet(-amount);
>                 target.atomicBalance.addAndGet(amount);
>         }
>     }
>    //ThreadLocal CAS？
>    ```
>
> 2. 一次性申请（破坏占有且等待）
>
>    ```java
>    将两个资源放在一个list一次申请
>    ```
>
> 3. 设置超时（破坏不可抢占）
>
>    ```java
>    lock.trylock
>    ```
>
> 4. 排序（破坏循环等待）
>
>    ```java
>    将两个账号id排序再按顺序申请
>    ```
>
> 银行家算法保证避免死锁：**分配资源之前，判断系统是否安全，如果安全才会进行资源分配。**

