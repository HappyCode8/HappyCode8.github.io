# 二分搜索

```java
/*
 *二分搜索实际上是不断卡left和right的过程，卡到什么位置，取决于你的实际需求
 *如果是要取到第一个，那就要严格卡left，除非目标元素确实比它大，否则不移动左界
 *如果是要取最后一个，那就要严格卡right，除非目标元素确实比它小，否则不移动右界
 */
public class BinarySearch1 {
    //正常的二分搜索，检索到那个数字为止，有重复的随机返回了
    public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
            /**
             * 加等号是因为当两个数指到同一个位置时，这个位置又刚好是要找的数,
             * 比如3，4两个数，找4，第一次二分，指向了3没找到,继续左指针右移，此时两指针同位置
             * */
            int mid=left+(right-left)/2;//避免溢出，两边取闭区间
            if(nums[mid]==x)//这里找到就为止
                return mid;
            else if(nums[mid]<x)//这是卡着left不让它动
                left=mid+1;
            else                //尽量移动right
                right=mid-1;
        }
        return -1;
    }
}
```

```java
//二分搜索变种，寻找元素第一次出现的位置,只要卡着left不动，右边即使等于也让它往前移
public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
        int mid=left+(right-left)/2;
        if(left<=nums.length-1&&nums[mid]<x)
        left=mid+1;
        else
        right=mid-1;
        }
        if(left<nums.length&&nums[left]==x)return left;//这里要注意
        return -1;
}

//二分搜索变种，寻找元素最后一次出现的位置,只要卡着right不动,左边即使等于也让它往后移
public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]<=x)
        left=mid+1;
        else
        right=mid-1;
        }
        if(right>=0&&nums[right]==x)return right;
        return -1;
}

//二分搜索变种，寻找第一个大于目标元素的位置
public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]<=x)
        left=mid+1;
        else
        right=mid-1;
        }
        if(right+1>=nums.length)return -1;
        return right+1;
}

//二分搜索变种，寻找第一个小于目标元素的位置
public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]<x)
        left=mid+1;
        else
        right=mid-1;
        }
        return left-1;
}
```

# 排序

## 快排

```java
public class QuickSort {
	public int partition(int nums[],int low,int high){
		int temp=nums[low];
		while(low<high){
			while(low<high&&nums[high]>=temp)high--;//元素全相同，必须保留一个等号，保证指针能移动下去
			nums[low]=nums[high];
			while(low<high&&nums[low]<temp)low++;
			nums[high]=nums[low];
		}
		nums[low]=temp;
		return low;
	}

	public void quickSort(int nums[],int low,int high){
		if(low<high){
			int pivoloc=partition(nums, low, high);
			quickSort(nums, low, pivoloc-1);
			quickSort(nums, pivoloc+1, high);
		}
	}

	public int[] quickSort(int nums[]){
		quickSort(nums,0,nums.length-1);
		return nums;
	}
}
```

```java
/*利用快排，找出元素的前k个小的值和第k小的值
 **/
public static int kthMin3(int[] nums,int left,int right,int k){
        int pivot=partion(nums, left, right);
        if(pivot==k-1)return pivot;
        else if(pivot>k-1)
        return kthMin3(nums, left, pivot-1, k);
        else
        return kthMin3(nums, pivot+1, right, k);
        }

public static int kthMin3(int[] nums,int k){
        return nums[kthMin3(nums, 0, nums.length-1, k)];
        }

public static void topKMin3(int[] nums,int k){
        kthMin3(nums, 0, nums.length-1, k);
        }
```
## 堆排
```java
//调节堆，从i到length进行调节，调节完以后i节点到length-1节点就是堆，在[i...length-1]上只有i不满足堆的定义
	public void adjustHeap(int nums[],int i,int length){//数组，以i节点为根开始调节，数组长度
		int temp=nums[i];
		for(int k=2*i+1;k<length;k=k*2+1){//以i节点的左节点开始比较
			if(k+1<length&&nums[k]<nums[k+1])//K+1是i节点的右节点，它俩哪个大k就取哪个
				k++;
			if(nums[k]>temp){//如果左右节点较大的那个值比原始的根大，一直替换下去
				nums[i]=nums[k];//左右节点较大的那个值换掉根，但是那个节点值不必变
				i=k;//由于i节点取了k节点的值，往子节点跳一层继续比较
				}else {//没调节直接结束了
				break;
			}
		}
		nums[i]=temp;//最后把那个值用根补上
	}
	public int[] heapSort(int nums[]){
		for(int i=nums.length/2-1;i>=0;i--) {//从最后一个非叶子节点开始调节，nums[nums.length/2-1]是最后一个非叶子节点
			adjustHeap(nums, i, nums.length);
		}
		for(int j=nums.length-1;j>0;j--){
			su.swap(nums, 0, j);
			adjustHeap(nums, 0, j);
		}
		return nums;	
	}
```

## 冒泡

```java
public class BubbleSort {
	SortUtil su=new SortUtil();
	//冒泡排序,它的外循环是排序的轮数，内循环是每一轮的相邻数据的两两比较
	//时间复杂度是o(n^2),空间复杂度是O(1)
	public int[] bubbleSort(int[] nums){
		for(int i=0;i<nums.length-1;i++)
			for(int j=0;j<nums.length-i-1;j++)
				if(nums[j]>nums[j+1])//稳定
				    su.swap(nums,j,j+1);
		return nums;	
	}

	//改进的冒泡排序算法，改进之处在于如果某一轮没有发生过交换，那么就是后边的都有序了，就不需要再排了
	//时间复杂度是o(n^2),空间复杂度是O(1)
	public int[] improvedBubbleSort(int[] nums){
		for(int i=0;i<nums.length-1;i++){
			boolean flag=true;
			for(int j=0;j<nums.length-i-1;j++)
				if(nums[j]>nums[j+1]){//稳定
				    su.swap(nums,j,j+1);
				    flag=false;
				}
			if(flag)
			   break;
		}
		return nums;	
	}
}
```

## 插入

```java
public class InsertSort {
	SortUtil su=new SortUtil();
	//插入排序算法，外层循环仍然是排序的轮数，内层循环是插入的过程
	//时间复杂度是o(n^2),空间复杂度是O(1)
	public int[] insertSort(int[] nums){
		for(int i=1;i<nums.length;i++){
			int j=i;
			while(j>0&&nums[j]<nums[j-1]){//稳定
				su.swap(nums, j, j-1);
				j--;
			}
		}		
		return nums;	
	}

	//改进的排序插入算法，在寻找插入位置的过程中使用二分查找
	public int[] improvedInsertSort(int[] nums){
		for(int i=1;i<nums.length;i++){
			int temp=nums[i];
			int left=0,right=i-1;
			while(left<=right){
				int mid=left+(right-left)/2;
				if(nums[mid]<=temp)
					left=mid+1;
				else 
					right=mid-1;
			}
			for(int j=i;j>right+1;j--)
				nums[j]=nums[j-1];
			nums[right+1]=temp;
		}	
		return nums;	
	}
}
```

## 归并

```java
public class MergeSort {
	//归并排序
	public void merge(int nums[],int left,int mid,int right,int temp[]){
		int i = left;
	    int j = mid+1;
	    int t = 0;
	    while (i<=mid && j<=right){
	        if(nums[i]<=nums[j]){
	            temp[t++] = nums[i++];
	        }else {
	            temp[t++] = nums[j++];
	        }
	    }
	    while(i<=mid){
	        temp[t++] = nums[i++];
	    }
	    while(j<=right){
	        temp[t++] = nums[j++];
	    }
	    t = 0;
	    while(left <= right){
	       nums[left++] = temp[t++];
	    }
	}

	public void mergeSort(int nums[],int left,int right,int []temp){
		 if(left<right){
	         int mid = (left+right)/2;
	         mergeSort(nums,left,mid,temp);
	         mergeSort(nums,mid+1,right,temp);
	         merge(nums,left,mid,right,temp);
	     }	
	}

	public int[] mergeSort(int nums[]){
		int[] temp = new int[nums.length];
	    mergeSort(nums,0,nums.length-1,temp);
	    return  nums;
	}
}
```

## 希尔

```java
public class ShellSort {
	SortUtil su=new SortUtil();
	//希尔排序
	public int[] shellSort(int nums[]){
		for(int gap=nums.length/2;gap>0;gap/=2){
			for(int i=gap;i<nums.length;i++){
				int j=i;
				while(j-gap>=0&&nums[j-gap]>nums[j]){
					su.swap(nums,j-gap,j);
					j-=gap;
				}
			}
		}
		return nums;	
	}
}
```

## 基数

```java
public class RadixSort {
	//基数排序
	public void radixHelp(int[] a, int exp) {
	    int[] output = new int[a.length];   
	    int[] buckets = new int[10];

	    for (int i = 0; i < a.length; i++)
	        buckets[ (a[i]/exp)%10 ]++;

	    for (int i = 1; i < 10; i++)
	        buckets[i] += buckets[i - 1];

	    for (int i = a.length - 1; i >= 0; i--) {
	        output[buckets[ (a[i]/exp)%10 ] - 1] = a[i];
	        buckets[ (a[i]/exp)%10 ]--;
	    }

	    for (int i = 0; i < a.length; i++)
	        a[i] = output[i];
	}
	
	public int[] radixSort(int nums[]){
		int exp; 
		int max = nums[0]; 
		for(int i=0;i<nums.length;i++)
			max=Math.max(nums[i], max);
	    for (exp = 1; max/exp > 0; exp *= 10)
	    	radixHelp(nums, exp);
		return nums;
	}
}
```

## 选择

```java
public class SelectSort {
	SortUtil su=new SortUtil();
	//选择排序算法，它的外循环是轮数，也可以说是一次从前到后为每一位选择值，内循环是选取这个值的过程
	//时间复杂度是o(n^2),空间复杂度是O(1)
	public int[] selectSort(int[] nums){
	    for(int i=0;i<nums.length-1;i++){
	    	int min=i;
	    	for(int j=i+1;j<nums.length;j++)
	    		if(nums[j]<nums[min])//不稳定，其不稳定如5 8 5 2 9
	    			min=j;
	    	if(min!=i)
	    	  su.swap(nums, i, min);
	    }
		return nums;	
	}
}
```

## 计数

```java
public class CountSort {
	//计数排序,适用于已经知道最大值与最小值并且二者差距不大，比如班级成绩，人们年龄等
	public int[] countSort(int nums[],int max,int min){
		int[] count=new int[max-min+1];
		for(int i=0;i<nums.length;i++){
			count[nums[i]-min]++;
		}
		int index=0;
		for(int i=0;i<count.length;i++)
			while(count[i]-->0)
				nums[index++]=i+min;
		return nums;	
	}
}
```

## 桶排

```java
public class BucketSort {
	//桶排序，适用于差距大，但是分布均匀的数字
	public int[] bucketSort(int nums[],int max,int min){
		int bucketNum=(max-min)/nums.length+1;
		List<List<Integer>> bucketArr = new ArrayList<>(bucketNum);
	    for(int i = 0; i < bucketNum; i++){
	        bucketArr.add(new ArrayList<Integer>());
	    }

	    for(int i = 0; i < nums.length; i++){
	        int num = (nums[i] - min) / (nums.length);
	        bucketArr.get(num).add(nums[i]);
	    }
	    
	    int index=0;
	    for(int i = 0; i < bucketArr.size(); i++){
	        Collections.sort(bucketArr.get(i));
	        for(int j = 0; j < bucketArr.get(i).size(); j++)
	        	nums[index++]=bucketArr.get(i).get(j);
	    }
		return nums;	
	}
}
```

# TOPK

```java
//使用java提供的优先队列
import java.util.PriorityQueue;

public class TopKMin {
	public static int[] topKMin(int[] nums,int k){
		int[] res=new int[k];
		//大根堆
		PriorityQueue<Integer> pq=new PriorityQueue<Integer>((o1, o2) -> o2-o1);
		for(int num:nums){
			pq.add(num);
			if(pq.size()>k)
				//往出弹大的值
				pq.poll();
		}
		int i=0;
        while(i<k)
        	res[i++]=pq.poll();
		return res;		
	}
	
	public static int kthMin(int[] nums,int k){
		PriorityQueue<Integer> pq=new PriorityQueue<Integer>((o1, o2) -> o2-o1);
		for(int num:nums){
			pq.add(num);
			if(pq.size()>k)
				pq.poll();
		}
		//弹完大的值，剩下堆顶的那个值就是第k小的
		return (int)(pq.toArray()[0]);
	}
	
	public static void main(String[] args){
		int[] test=new int[]{1,3,5,7,9,2,4,6,8,0};
		int[] res=topKMin(test, 3);
		for(int i:res)
			System.out.println(i);
		System.out.println(kthMin(test, 3));
	}
}
```

```java
//构建堆
public class TopKMin2 {
	//假设除了i位置，别的都满足大根堆的定义，现在调节大根堆
	public static void adjust(int[] nums,int i,int length){
		int temp=nums[i];
		for(int k=2*i+1;k<length;k=k*2+1){
			if(k+1<length&&nums[k]<nums[k+1])
				k++;
			if(temp<nums[k]){
				nums[i]=nums[k];
				i=k;
			}else
				break;		
		}
		nums[i]=temp;
	}
	
	public static void topKMin2(int[] nums,int k){
		for(int i=k/2-1;i>=0;i--)
			adjust(nums, i, k);//先调节一个大根堆
		for(int i=k;i<nums.length;i++){//新来的比根小就替换
			if(nums[i]<nums[0]){
				nums[0]=nums[i];
				adjust(nums, 0, k);
			}	
		}
	}
	
	//只要来的比根上的小，就换掉根，然后调节
	public static int kthMin2(int[] nums,int k){
		for(int i=k/2-1;i>=0;i--)
			adjust(nums, i, k);//先调节一个大根堆
		for(int i=k;i<nums.length;i++){//新来的比根小就替换
			if(nums[i]<nums[0]){
				nums[0]=nums[i];
				adjust(nums, 0, k);
			}	
		}
		return nums[0];
	}
	
	public static void main(String[] args){
		int[] test=new int[]{1,3,5,7,9,2,4,6,8,0};		
		System.out.println(kthMin2(test, 3));
		for(int i=0;i<3;i++)
			System.out.println(test[i]);
	}
}
```

```java
//利用快排
public class TopKMin3 {
	public static int partion(int[] nums,int left,int right){
		int temp=nums[left];
		while(left<right){
		while(left<right&&nums[right]>=temp)right--;
		  nums[left]=nums[right];
		while(left<right&&nums[left]<temp)left++;
		  nums[right]=nums[left];
		}
		nums[left]=temp;
		return left;
	}
	public static int kthMin3(int[] nums,int left,int right,int k){
		int pivot=partion(nums, left, right);
		if(pivot==k-1)return pivot;
		else if(pivot>k-1)
			return kthMin3(nums, left, pivot-1, k);
		else
			return kthMin3(nums, pivot+1, right, k);
	}

	public static int kthMin3(int[] nums,int k){
		return nums[kthMin3(nums, 0, nums.length-1, k)];
	}

	public static void topKMin3(int[] nums,int k){
		kthMin3(nums, 0, nums.length-1, k);
	}

	public static void main(String[] args){
		int[] test=new int[]{1,3,5,7,9,2,4,6,8,0};
		//将这个元素与原数组比较，自然可以找到前k个
		System.out.println(kthMin3(test, 6));
//		topKMin3(test,4);
//		for(int i=0;i<test.length;i++){
//			System.out.println(test[i]);
//		}
	}
}
```

# 字符串匹配算法

- BF（Brute Force）算法：暴力破解
  - 字符串短的时候用，代码实现简单
- RK算法
  - 将主串中每一个子串长度的子串求哈希然后比较，可以降低复杂度到O(n)
- BM算法与KMP算法
  - 较复杂，主要要根据子串自身的一些特征然后在不匹配时往后滑动多位

# 高级数据结构

## 拓扑排序

## 最短路径

- Dijkstra
-  Bellford 
- Floyd

## 位图

- 布隆过滤器

## 基于概率的统计

过滤垃圾短信，可以有3种方法

- 基于黑名单
- 规则
- 朴素贝叶斯

## 向量空间

- 基于相似用户做推荐

  >1. 把人听的歌作为向量
  >2. 把向量差距不大的人，看作口味相似的用户
  >3. 遍历所有的用户，对比每个用户跟被推荐者口味相似的用户，并且设置一个阈值，如果你和某个用户共同喜爱的歌曲个数超过这个阈值，我们就把这个用户看作跟你口味相似的用户，把这个用户喜爱但你还没听过的歌曲，推荐给你

- 基于相似歌曲做推荐

  >1. 把听了歌的人作为向量
  >2. 计算歌曲之间的相似度
  >3. 在用户已经听过的歌曲中，找出他喜爱程度较高的歌曲。然后，我们找出跟这些歌曲相似度很高的其他歌曲，推荐给他

## A*算法

- 寻路算法
- 不能像 Dijkstra 算法那样，找到最短路径

## LSM Tree

- Log Structure Merge Tree
- 这种结构的写入，全部都是以Append的模式追加，不存在删除和修改。当然有得就有舍，这种结构虽然大大提升了数据的写入能力，却是以牺牲部分读取性能为代价，故此这种结构通常适合于写多读少的场景。故LSM被设计来提供比传统的B+树或者ISAM更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。这里面最典型的例子就属于Kakfa了
- 支持高写，B+树支持高读

## 时间轮

延时队列的底层实现

- JDK 中的 DelayedQueue
- Redis 中 ZSET
- 时间轮

## pageRank

## Raft

## UUID

## 一致性哈希

## Trie树（字典树）

- 存储

  ```java
  class TrieNode {
    char data;
    TrieNode children[26];//只有26个字母的字典树，不存在的对应置空
  }
  ```

- 耗内存

- 使用场景

  Trie 树不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决，Trie 树比较适合的是查找前缀匹配的字符串

## AC自动机

- 单模式串匹配算法

  在一个模式串和一个主串之间进行匹配，也就是说，在一个主串中查找一个模式串。BF 算法、RK 算法、BM 算法、KMP 算法等字符串匹配算法

- 多模式串匹配算法

  在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。Trie 树。

- AC自动机算法（Aho-Corasick）

  AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了。

  ```java
  public class AcNode {
    public char data; 
    public AcNode[] children = new AcNode[26]; // 字符集只包含a~z这26个字符
    public boolean isEndingChar = false; // 结尾字符为true
    public int length = -1; // 当isEndingChar=true时，记录模式串长度
    public AcNode fail; // 失败指针
    public AcNode(char data) {
      this.data = data;
    }
  }
  ```



# 七天练

## 1

数组

>实现一个支持动态扩容的数组
>
>实现一个大小固定的有序数组，支持动态增删改操作
>
>实现两个有序数组合并为一个有序数组

链表

>实现单链表、循环链表、双向链表，支持增删操作
>
>实现单链表反转
>
>实现两个有序的链表合并为一个有序链表
>
>实现求链表的中间结点

Three Sum（求三数之和）

Majority Element（求众数）

Missing Positive（求缺失的第一个正数）

Linked List Cycle I（环形链表）

Merge k Sorted Lists（合并 k 个排序链表）

## 2

关于栈、队列和递归的几个必知必会的代码实现

栈

> 用数组实现一个顺序栈用链表
>
> 实现一个链式栈
>
> 编程模拟实现一个浏览器的前进、后退功能
>
> Valid Parentheses（有效的括号）
>
> Longest Valid Parentheses（最长有效的括号）
>
> Evaluate Reverse Polish Notatio（逆波兰表达式求值）

队列

> 用数组实现一个顺序队列
>
> 用链表实现一个链式队列
>
> 实现一个循环队列
>
> Design Circular Deque（设计一个双端队列）

递归

>编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2)
>
>编程实现求阶乘 n!
>
>编程实现一组数据集合的全排列
>
>Sliding Window Maximum（滑动窗口最大值）
>
>Climbing Stairs（爬楼梯）

## 3

排序

> 实现归并排序、快速排序、插入排序、冒泡排序、选择排序
>
> 编程实现找到一组数据的第 K 大元素

二分查找

> 实现一个有序数组的二分查找算法
>
> 实现模糊二分查找算法（比如大于等于给定值的第一个元素）
>
> Sqrt(x) （x 的平方根）

## 4

散列表

> 实现一个基于链表法解决冲突问题的散列表
>
> 实现一个 LRU 缓存淘汰算法

字符串

> 实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树
>
> 实现朴素的字符串匹配算法
>
> Reverse String （反转字符串）
>
> Reverse Words in a String（翻转字符串里的单词）
>
> String to Integer (atoi)（字符串转换整数 (atoi)）

## 5

二叉树

> 实现一个二叉查找树，并且支持插入、删除、查找操作
>
> 实现查找二叉查找树中某个节点的后继、前驱节点
>
> 实现二叉树前、中、后序以及按层遍历

堆

> 实现一个小顶堆、大顶堆、优先级队列
>
> 实现堆排序利用优先级队列合并 K 个有序数组
>
> 求一组动态数据集合的最大 Top K

Invert Binary Tree（翻转二叉树）

Maximum Depth of Binary Tree（二叉树的最大深度）

Validate Binary Search Tree（验证二叉查找树）

Path Sum（路径总和）

## 6

实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法

实现图的深度优先搜索、广度优先搜索

实现 Dijkstra 算法、A* 算法

实现拓扑排序的 Kahn 算法、DFS 算法

Number of Islands（岛屿的个数）

Valid Sudoku（有效的数独）

## 7

回溯

> 利用回溯算法求解八皇后问题
>
> 利用回溯算法求解 0-1 背包问题

分治

> 利用分治算法求一组数据的逆序对个数

动态规划

> 0-1 背包问题
>
> 最小路径和
>
> 编程实现莱文斯坦最短编辑距离
>
> 编程实现查找两个字符串的最长公共子序列
>
> 编程实现一个数据序列的最长递增子序列

Regular Expression Matching（正则表达式匹配）

Minimum Path Sum（最小路径和）

Coin Change （零钱兑换）

Best Time to Buy and Sell Stock（买卖股票的最佳时机）

Maximum Product Subarray（乘积最大子序列）

Triangle（三角形最小路径和）

# 业务算法

## 短网址

第一种实现思路是通过哈希算法生成短网址。我们采用计算速度快、冲突概率小的 MurmurHash 算法，并将计算得到的 10 进制数，转化成 62 进制表示法，进一步缩短短网址的长度。对于哈希算法的哈希冲突问题，我们通过给原始网址添加特殊前缀字符，重新计算哈希值的方法来解决。

第二种实现思路是通过 ID 生成器来生成短网址。我们维护一个 ID 自增的 ID 生成器，给每个原始网址分配一个 ID 号码，并且同样转成 62 进制表示法，拼接到短网址服务的域名之后，形成最终的短网址。

## 高性能队列Disruptor

Disruptor 采用了“两阶段写入”的方法。在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能因此就提高了。Disruptor 对消费过程的改造，跟对生产过程的改造是类似的。它先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能因此也就提高了。

## 文本差分

