# 目录

>[仓库](https://github.com/github20131983/Algorithm) [算法可视化](https://visualgo.net/en)
>
>**链表**
>
>- [2两数相加](https://leetcode-cn.com/problems/add-two-numbers)
>- [445链表求和](https://leetcode-cn.com/problems/add-two-numbers-ii/description/)
>- [19删除链表倒数第n个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)
>- [24两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
>- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
>- [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
>- [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)
>- [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)
>- [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)
>- [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
>- [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
>- [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)
>- [24交换链表中的相邻结点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/)
>- [234回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/description/)
>- [725分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/description/)
>- [23合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
>
>**动态规划**
>
>1. 斐波那契数列
>- 爬楼梯
>  - [普通爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
>  - [最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
>  - [变态爬楼梯](https://mp.weixin.qq.com/s/NZPaFsFrTybO3K3s7p7EVg)
>- 强盗抢劫
>  - [打家劫舍](https://leetcode.cn/problems/house-robber/)
>  - [打家劫舍II(环形街区)](https://leetcode.cn/problems/house-robber-ii/)
>  - [打家劫舍III(二叉树街区)](https://leetcode.cn/problems/house-robber-iii/)
>- 信件错排
>- 母牛生产
>2. 路径
>- [矩阵最小路径和](https://leetcode.cn/problems/minimum-path-sum/submissions/)
>- [矩阵总路径数](https://leetcode.cn/problems/unique-paths/)
>- [矩阵总路径数II](https://leetcode.cn/problems/unique-paths-ii/)
>- [最小三角路径和](https://leetcode.cn/problems/triangle/)
>3. 数组区间
>- [数组区间和](https://leetcode.cn/problems/range-sum-query-immutable/)
>- [数组中等差递增子区间的个数](https://leetcode.cn/problems/arithmetic-slices/)
>4. 分割整数
>- [分割整数的最大乘积](https://leetcode.cn/problems/integer-break/description/)
>- [按平方数来分割整数](https://leetcode.cn/problems/perfect-squares/description/)
>- [分割整数构成字母字符串](https://leetcode.cn/problems/decode-ways/description/)
>5. 子序列与子串
>- [最长递增子序列的长度](https://leetcode.cn/problems/longest-increasing-subsequence/description/)
>- [最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)
>- [最长摆动子序列](https://leetcode.cn/problems/wiggle-subsequence/)
>- [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/submissions/)
>- [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)  动态规划、中心扩散
>- [最长数对列](https://leetcode.cn/problems/maximum-length-of-pair-chain/description/)
>- [最长公共子串](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)
>- [最大数组和](https://leetcode.cn/problems/maximum-subarray/)
>- [最大数组积](https://leetcode.cn/problems/maximum-product-subarray/)
>- [最大正方形](https://leetcode-cn.com/problems/maximal-square)
>6. 背包问题
>- 简单背包
>- [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)
>- [目标和](https://leetcode.cn/problems/target-sum/description/)
>- [01 字符构成最多的字符串](https://leetcode.cn/problems/ones-and-zeroes/description/)
>- [找零钱的最少硬币数](https://leetcode.cn/problems/ones-and-zeroes/description/)
>- [找零钱的硬币数组合](https://leetcode.cn/problems/coin-change-2/description/)
>- [字符串按单词列表分割](https://leetcode.cn/problems/word-break/description/)
>- [组合总和](https://leetcode.cn/problems/combination-sum-iv/description/)
>7. 买卖股票
>- [买卖股票I](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
>- [买卖股票II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
>- [买卖股票III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
>- [买卖股票IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
>- [买卖股票V](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
>- [买卖股票VI](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
>8. 字符串编辑
>- [删除两个字符串的字符使它们相等](https://leetcode.cn/problems/delete-operation-for-two-strings/description/)
>- [编辑距离](https://leetcode.cn/problems/delete-operation-for-two-strings/description/)
>- [复制粘贴字符](https://leetcode.cn/problems/2-keys-keyboard/description/)
>- [正则表达式](https://leetcode.cn/problems/regular-expression-matching/)
>
>8. 其他疑难问题
>
>- [312戳气球](https://leetcode.cn/problems/burst-balloons/)
>- [接雨水](https://leetcode.cn/problems/trapping-rain-water/)
>- [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/) 动态规划、栈、两次遍历
>
>**贪心算法**
>
>- [买卖股票II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
>- [分饼干](https://leetcode.cn/problems/assign-cookies/)
>- [跳跃游戏](https://leetcode.cn/problems/jump-game/)
>- [881. 救生艇](https://leetcode-cn.com/problems/boats-to-save-people/)
>- [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)
>- [134. 加油站](https://leetcode-cn.com/problems/gas-station/)
>- [621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)
>- [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)
>- [406根据身高和序号重组队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/)
>- [655修改一个数成为非递减数组](https://leetcode-cn.com/problems/non-decreasing-array/description/)
>- [763分隔字符串使同种字符出现在一起](https://leetcode-cn.com/problems/partition-labels/description/)
>
>**二分查找**
>
>- 基本框架及其变种
>- [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)
>- [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)
>- [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)
>- [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)
>- [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)
>- [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)
>- [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
>- [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
>- [744大于给定元素的最小元素](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/)
>- [540有序数组的 Single Element](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/)
>- [278第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/description/)
>- [搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/?favorite=2cktkvj)
>
>**搜索**
>
>1. 深度优先&广度优先
>
>- [695岛屿最大面积](https://leetcode-cn.com/problems/max-area-of-island/)
>- [733图像渲染](https://leetcode-cn.com/problems/flood-fill/)
>- [1091计算在网格中从原点到特定点的最短路径长度](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)
>- [279组成整数的最小平方数数量](https://leetcode-cn.com/problems/perfect-squares/description/)
>- [127最短单词路径](https://leetcode-cn.com/problems/word-ladder/description/)
>- [200矩阵中的连通分量数目](https://leetcode-cn.com/problems/number-of-islands/description/)
>- [547好友关系的连通分量数目](https://leetcode-cn.com/problems/friend-circles/description/)
>- [130填充封闭区域](https://leetcode-cn.com/problems/surrounded-regions/description/)
>- [417能到达的太平洋和大西洋的区域](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/description/)
>- [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)
>
>2. 回溯&剪枝
>
>- [77组合](https://leetcode-cn.com/problems/combinations/)
>- [39组合总和](https://leetcode-cn.com/problems/combination-sum/description/)
>- [40组合总和II](https://leetcode-cn.com/problems/combination-sum-ii/description/)
>- [216组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)
>- [78子集](https://leetcode-cn.com/problems/subsets/)
>- [90子集II](https://leetcode-cn.com/problems/subsets-ii/description/)
>- [46全排列](https://leetcode-cn.com/problems/permutations/)
>- [47全排列II](https://leetcode-cn.com/problems/permutations-ii/description/)
>- [17电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/)
>- [131分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/description/)
>- [93复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/description/)
>- [491递增子序列](https://leetcode.cn/problems/increasing-subsequences/)
>- [51N皇后](https://leetcode-cn.com/problems/n-queens/)
>- [36有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)
>- [37解数独](https://leetcode-cn.com/problems/sudoku-solver/)
>- [22括号生成](https://leetcode-cn.com/problems/generate-parentheses/)
>- [301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)
>- [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)
>
>**双指针**
>
>- [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)
>- [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
>- [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)
>- [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)
>- [633.两数平方和](https://leetcode-cn.com/problems/sum-of-square-numbers/description/)
>- [345.反转字符串中的元音字符](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/)
>- [680.回文字符串](https://leetcode-cn.com/problems/valid-palindrome-ii/description/)
>- [88.归并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/description/)
>- [524.最长子序列](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/)
>- [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
>- [76最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
>
>**滑动窗口**
>
>- [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
>- [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)
>- [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)
>- [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)
>- [1456. 定长子串中元音的最大数目](https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)
>- [904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)
>
>**位运算**
>
>- [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)
>- [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)
>- [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)
>- [389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)
>- [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)
>- [461统计两个数的二进制表示有多少位不同](https://leetcode-cn.com/problems/hamming-distance/)
>- [136数组中唯一一个不重复的元素](https://leetcode-cn.com/problems/single-number/description/)
>- [260数组中不重复的两个元素](https://leetcode-cn.com/problems/single-number-iii/description/)
>- [190翻转一个数的比特位](https://leetcode-cn.com/problems/reverse-bits/description/)
>- 不用额外变量交换两个整数[程序员代码面试指南 ：P317](http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97.html#)
>- [231判断一个数是不是 2 的 n 次方](https://leetcode-cn.com/problems/power-of-two/description/)
>- [342判断一个数是不是 4 的 n 次方](https://leetcode-cn.com/problems/power-of-four/)
>- [693判断一个数的位级表示是否不会出现连续的 0 和 1](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/description/)
>- [476求一个数的补码](https://leetcode-cn.com/problems/number-complement/description/)
>- [371实现整数的加法](https://leetcode-cn.com/problems/sum-of-two-integers/description/)
>- [318字符串数组最大乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/description/)
>- [338统计从 0 ~ n 每个数的二进制表示中 1 的个数](https://leetcode-cn.com/problems/counting-bits/description/)
>
>**递归&分治**
>
>- [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)
>- [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)
>- [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
>- [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
>- [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)
>- [241给表达式加括号](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/description/)
>- [95不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/description/)
>
>**排序**
>
>- 各种排序算法
>- TopK
>
>**单调栈**
>
>- [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
>- [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
>- [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)
>- [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)
>- [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
>
>**set&map**
>
>- [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)
>- [167. 两数之和II](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/)
>- [15. 三数之和](https://leetcode-cn.com/problems/3sum/)
>- [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)
>- [447. 回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)
>- [187. 重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)
>- [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)
>- [1.Two Sum (Easy))](https://leetcode-cn.com/problems/two-sum/description/)
>- [217判断数组是否含有重复元素](https://leetcode-cn.com/problems/contains-duplicate/description/)
>- [594最长和谐序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/)
>- [128最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/description/)
>
>**栈&队列**
>
>- [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)
>- [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)
>- [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)
>- [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)
>- [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)
>- [682. 棒球比赛](https://leetcode-cn.com/problems/baseball-game/)
>- [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)
>- [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)
>- [692. 前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)
>- [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)
>- [739数组中元素与下一个比它大的元素之间的距离](https://leetcode-cn.com/problems/daily-temperatures/description/)
>- [503循环数组中比当前元素大的下一个元素](https://leetcode-cn.com/problems/next-greater-element-ii/description/)
>
>**数组&矩阵**
>
>- [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)
>- [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)
>- [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)
>- [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
>- [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)
>- [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)
>- [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)
>- [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)
>- [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)
>- [905. 按奇偶排序数组](https://leetcode-cn.com/problems/sort-array-by-parity/)
>- [922. 按奇偶排序数组 II](https://leetcode-cn.com/problems/sort-array-by-parity-ii/)
>- [283把数组中的 0 移到末尾](https://leetcode-cn.com/problems/move-zeroes/description/)
>- [566改变矩阵维度](https://leetcode-cn.com/problems/reshape-the-matrix/description/)
>- [485找出数组中最长的连续 1](https://leetcode-cn.com/problems/max-consecutive-ones/description/)
>- [240有序矩阵查找](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/)
>- [378有序矩阵的 Kth Element](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)
>- [645一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数](https://leetcode-cn.com/problems/set-mismatch/description/)
>- [287找出数组中重复的数，数组值在 [1, n] 之间](https://leetcode-cn.com/problems/find-the-duplicate-number/description/)
>- [667数组相邻差值的个数](https://leetcode-cn.com/problems/beautiful-arrangement-ii/description/)
>- [697数组的度](https://leetcode-cn.com/problems/degree-of-an-array/description/)
>- [766对角元素相等的矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/description/)
>- [565嵌套数组](https://leetcode-cn.com/problems/array-nesting/description/)
>-  [769分隔数组](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/description/)
>- [31下一个排列](https://leetcode.cn/problems/next-permutation/?favorite=2cktkvj)
>
>**字符串**
>
>- [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)
>- [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)
>- [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)
>- [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)
>- [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)
>- [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)
>- [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)
>- [796. 旋转字符串](https://leetcode-cn.com/problems/rotate-string/)
>- [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)
>- 字符串循环移位包含[编程之美 3.1](http://www.cyc2018.xyz/算法/Leetcode 题解/Leetcode 题解 - 字符串.html#)
>- 字符串循环移位[编程之美 2.17](http://www.cyc2018.xyz/算法/Leetcode 题解/Leetcode 题解 - 字符串.html#)
>- 字符串中单词的翻转[程序员代码面试指南](http://www.cyc2018.xyz/算法/Leetcode 题解/Leetcode 题解 - 字符串.html#)
>- [242两个字符串包含的字符是否完全相同](https://leetcode-cn.com/problems/valid-anagram/description/)
>- [409计算一组字符集合可以组成的回文字符串的最大长度](https://leetcode-cn.com/problems/longest-palindrome/description/)
>- [205字符串同构](https://leetcode-cn.com/problems/isomorphic-strings/description/)
>- [647回文子字符串个数](https://leetcode-cn.com/problems/palindromic-substrings/description/)
>- [9判断一个整数是否是回文数](https://leetcode-cn.com/problems/palindrome-number/description/)
>- [696统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数](https://leetcode-cn.com/problems/count-binary-substrings/description/)
>
>**树**
>
>1. 递归
>  - [104二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/)
>  - [110平衡树](https://leetcode-cn.com/problems/balanced-binary-tree/description/)
>  - [543二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/description/)
>  - [226翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/)
>  - [617合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)
>  - [112判断路径和是否等于一个数](https://leetcode-cn.com/problems/path-sum/description/)
>  - [437统计路径和等于一个数的路径数量](https://leetcode-cn.com/problems/path-sum-iii/description/)
>  - [572子树](https://leetcode-cn.com/problems/subtree-of-another-tree/description/)
>  - [101对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/description/)
>  - [111最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/)
>  - [404统计左叶子节点的和](https://leetcode-cn.com/problems/sum-of-left-leaves/description/)
>  - [687相同节点值的最大路径长度](https://leetcode-cn.com/problems/longest-univalue-path/)
>  - [337间隔遍历](https://leetcode-cn.com/problems/house-robber-iii/description/)
>  - [671找出二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/description/)
>  - [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)
>  - [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)
>  - [112路径总和I](https://leetcode-cn.com/problems/path-sum)
>  - [113路径总和II](https://leetcode-cn.com/problems/path-sum-ii/)
>  - [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)
>  - [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)
>  - [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)
>  - [958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)
>  - [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)
>  - [236二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)
>  - [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)
>  - [297二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)
>2. 层次遍历
>  - [513得到左下角的节点](https://leetcode-cn.com/problems/find-bottom-left-tree-value/description/)
>  - [102二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
>  - [129求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
>
>3. 前中后序遍历
>  - [144非递归实现二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)
>  - [145非递归实现二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)
>  - [94非递归实现二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/)
>  - [105从前序与中序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
>  - [106中序与后续遍历恢复二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/submissions/)
>4. BST
>  - [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)
>  - [669修剪二叉查找树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/)
>  - [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)
>  - [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)
>  - [235二叉查找树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)
>  - [108从有序数组中构造二叉查找树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/)
>  - [109根据有序链表构造平衡的二叉查找树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/description/)
>  - [653两数之和IV](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/description/)
>  - [530在二叉查找树中查找两个节点之差的最小绝对值](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/description/)
>  - [501寻找二叉查找树中出现次数最多的值](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/description/)
>5. Trie
>  - [208实现一个 Trie](https://leetcode-cn.com/problems/implement-trie-prefix-tree/description/)
>  - [677实现一个 Trie，用来求前缀和](https://leetcode-cn.com/problems/map-sum-pairs/description/)
>  - [720. 词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary/)
>
>**并查集&图&拓扑排序**
>
>- [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)
>- [785判断是否为二分图](https://leetcode-cn.com/problems/is-graph-bipartite/description/)
>- [207课程安排的合法性](https://leetcode-cn.com/problems/course-schedule/description/)
>- [210课程安排的顺序](https://leetcode-cn.com/problems/course-schedule-ii/description/)
>- [684冗余连接](https://leetcode-cn.com/problems/redundant-connection/description/)
>- [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)
>
>**数学**
>
>- [204生成素数序列](https://leetcode-cn.com/problems/count-primes/description/)
>- [504进制](https://leetcode-cn.com/problems/base-7/description/)
>- [405进制](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/description/)
>- [168进制](https://leetcode-cn.com/problems/excel-sheet-column-title/description/)
>- [172统计阶乘尾部有多少个 0](https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/)
>- [67二进制加法](https://leetcode-cn.com/problems/add-binary/description/)
>- [415字符串加法](https://leetcode-cn.com/problems/add-strings/description/)
>- [462改变数组元素使所有的数组元素都相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/description/)
>- [169数组中出现次数多于 n / 2 的元素](https://leetcode-cn.com/problems/majority-element/description/)
>- [367平方数](https://leetcode-cn.com/problems/valid-perfect-square/description/)
>- [326  3 的 n 次方](https://leetcode-cn.com/problems/power-of-three/description/)
>- [238乘积数组](https://leetcode-cn.com/problems/product-of-array-except-self/description/)
>- [628找出数组中的乘积最大的三个数](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/description/)

# 链表

```java
public class ListNode {
   int val;
   ListNode next;
   ListNode(int x) { 
       val = x; 
   }
}
```

## 两数相加

> 给你两个非空的链表，表示两个非负的整数，数字逆序存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。
> **输入**：2->4->3+5->6->4  
> **输出**：7->0->8(**342 + 465 = 807**)
> **思路**：这个链表从前到后实际上是个位、十位、百位.......，所以从前往后刚好是模拟了从个位加到最高位的过程，基本上只要模拟就行了。
>
> ```java
> public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
>         ListNode sum=new ListNode(-1);
>         ListNode head=sum;
>         int sigleSum=0;
>         while(l1!=null||l2!=null){
>             sigleSum/=10;
>             if(l1!=null){
>                 sigleSum+=l1.val;
>                 l1=l1.next;
>             }
>             if(l2!=null){
>                 sigleSum+=l2.val;
>                 l2=l2.next;
>             }
>             sum.next=new ListNode(sigleSum%10);
>             sum=sum.next;
>         }
>         if(sigleSum>=10)sum.next=new ListNode(1);
>         return head.next;
>     }
> ```

## 删除链表倒数第n个节点

>给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点，使用一趟扫描实现
>**输入**：head = [1,2,3,4,5], n = 2
>**输出**：[1,2,3,5]
>**思路**：双指针，快的先跑n个，慢的在开始跑，当快的跑到末尾时，慢的指的就是要删除的
>
>```java
>class Solution {
>    public ListNode removeNthFromEnd(ListNode head, int n) {
>        ListNode start=new ListNode(-1);
>        start.next=head;
>        ListNode slow=start,fast=start;
>        for(int i=1;i<=n;i++)
>            fast=fast.next;
>        while(fast.next!=null){
>            fast=fast.next;
>            slow=slow.next;
>        }
>        slow.next=slow.next.next;//删除
>        return start.next;
>    }
>}
>```

## 两两交换链表中的节点

> 给定一个链表，**两两交换** **(换节点而不是值)** 其中相邻的节点，并返回交换后的链表。
> **思路**：用三个指针，一个指向交换两节点的前方，其余指向要交换的两个，每次交换完三个指针前进两格
>
> ```java
> public ListNode swapPairs(ListNode head) {
>     if (head == null || head.next == null) {
>       return head;
>     }
>     ListNode start = new ListNode(-1);
>     start.next = head;
>     ListNode end = start.next.next.next, fake = start;
>     while (end != null && end.next != null) {
>       //交换，然后跳到下一个区间交换
>       reversePartNode(start, end);
>       start = start.next.next;
>       end = end.next.next;
>     }
>     reversePartNode(start, end);
>     return fake.next;
> }
> 
>    //交换start与end之间的内容
> public void reversePartNode(ListNode startNode, ListNode endNode) {
>     ListNode firstNode = startNode.next;
>     ListNode secondNode = startNode.next.next;
>     startNode.next = secondNode;
>     secondNode.next = firstNode;
>     firstNode.next = endNode;
> }
> ```

## 合并两个有序列表

>模拟即可，可以使用迭代+递归两种方法
>
>```java
>public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
>        if (list1 == null) {
>            return list2;
>        }
>        if (list2 == null) {
>            return list1;
>        }
>        ListNode virtualNode = new ListNode(-1);
>        ListNode preNode=virtualNode;
>        while (list1 != null && list2 != null) {
>            if (list1.val < list2.val) {
>                preNode.next = list1;
>                list1=list1.next;
>            }else{
>                preNode.next = list2;
>                list2=list2.next;
>            }
>            preNode=preNode.next;
>        }
>        if (list1 != null) {
>            preNode.next=list1;
>        }else if(list2 != null){
>            preNode.next=list2;
>        }
>        return virtualNode.next;
>}
>```
>
>

## 23合并K个排序链表

>3种方法，1是在合并两个有序链表的基础上不断往上合，2是采用归并的方法，3是采用优先队列
>
>```java
>class Solution {//归并
>    public ListNode mergeKLists(ListNode[] lists) {
>        return merge(lists, 0, lists.length - 1);
>    }
>  
>public ListNode merge(ListNode[] lists, int l, int r) {
>    if (l == r) {
>        return lists[l];
>    }
>    if (l > r) {
>        return null;
>    }
>    int mid = (l + r) >> 1;
>    return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
>}
>
>public ListNode mergeTwoLists(ListNode a, ListNode b) {
>    if (a == null || b == null) {
>        return a != null ? a : b;
>    }
>    ListNode head = new ListNode(0);
>    ListNode tail = head, aPtr = a, bPtr = b;
>    while (aPtr != null && bPtr != null) {
>        if (aPtr.val < bPtr.val) {
>            tail.next = aPtr;
>            aPtr = aPtr.next;
>        } else {
>            tail.next = bPtr;
>            bPtr = bPtr.next;
>        }
>        tail = tail.next;
>    }
>    tail.next = (aPtr != null ? aPtr : bPtr);
>    return head.next;
>}
>```
>```java
>class Solution {
>    class Status implements Comparable<Status> {
>        int val;
>        ListNode ptr;
>
>        Status(int val, ListNode ptr) {
>            this.val = val;
>            this.ptr = ptr;
>        }
>
>        public int compareTo(Status status2) {
>            return this.val - status2.val;
>        }
>    }
>
>    PriorityQueue<Status> h = new PriorityQueue<Status>();
>
>    public ListNode mergeKLists(ListNode[] lists) {
>        for (ListNode node: lists) {//将链表头放入优先队列
>            if (node != null) {
>                h.offer(new Status(node.val, node));
>            }
>        }
>        ListNode res = new ListNode(0);
>        ListNode p = res;
>        while (!h.isEmpty()) {
>            Status n = h.poll();
>            p.next = n.ptr;
>            p = p.next;
>            if (n.ptr.next != null) {
>                h.offer(new Status(n.ptr.next.val, n.ptr.next));
>            }
>        }
>        return res.next;
>    }
>}
>```

## 61旋转链表

> 给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。
>
> 链接：https://leetcode-cn.com/problems/rotate-list/
>
> 思路：双指针，先让一个指针移到末尾，然后另一个指针移动k位，下一位断开，末尾指针接到头上
>
> ```java
> class Solution {
>     public ListNode rotateRight(ListNode head, int k) {
>         if (head==null||head.next==null) return head;
>         ListNode dummy=new ListNode(-1);
>         dummy.next=head;
>         ListNode fast=dummy,slow=dummy;
>         int length;
>         for(length=0;fast.next!=null;length++)
>             fast=fast.next;
>         for(int i=length-k%length;i>0;i--)
>             slow=slow.next;
>         fast.next=dummy.next;
>         dummy.next=slow.next;
>         slow.next=null;
>         return dummy.next;
>     }
> }
> ```
>
> 

## 82删除排序链表中的重复元素 II

>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。
>
>返回同样按升序排列的结果链表。
>
>来源：力扣（LeetCode）
>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii
>
>```java
>class Solution {
>    public ListNode rotateRight(ListNode head, int k) {
>        if (head==null||head.next==null) return head;
>        ListNode dummy=new ListNode(-1);
>        dummy.next=head;
>        ListNode fast=dummy,slow=dummy;
>        int length;
>        for(length=0;fast.next!=null;length++)
>            fast=fast.next;
>        for(int i=length-k%length;i>0;i--)
>            slow=slow.next;
>        fast.next=dummy.next;
>        dummy.next=slow.next;
>        slow.next=null;
>        return dummy.next;
>    }
>}
>```
>
>## 

## 86分隔链表

>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
>
>你应当 保留 两个分区中每个节点的初始相对位置。
>链接：https://leetcode-cn.com/problems/partition-list
>
>思路：起两个新链表，拼起来
>
>```java
>public ListNode partition(ListNode head, int x) {
>        ListNode fakeNode1=new ListNode(-1);
>        ListNode fakeNode2=new ListNode(-1);
>        ListNode cur1=fakeNode1,cur2=fakeNode2;
>        while(head!=null){
>            if(head.val<x){
>                cur1.next=head;
>                cur1=head;
>            }else{
>                cur2.next=head;
>                cur2=head;
>            }
>            head=head.next;
>        }
>        cur1.next=fakeNode2.next;
>        cur2.next=null;
>        return fakeNode1.next;
>    }
>```
>
>

## 翻转链表

>```java
>public ListNode reverseList(ListNode head) {
>        if (head == null || head.next == null) {
>            return head;
>        }
>        ListNode fakeNode = new ListNode(-1);
>        fakeNode.next = head;
>        ListNode p = head.next;
>        while (p != null) {
>            //head与p对调
>            head.next = p.next;
>            p.next = fakeNode.next;
>            //fake重新指向节点头
>            fakeNode.next = p;
>            //p指向新的节点开始下一轮
>            p = head.next;
>        }
>        return fakeNode.next;
>    }
>
>    //递归方法
>    /**
>     * head next
>     *   □→  □→   □→□→□→□→□→□→□→
>     * */
>    public ListNode reverseList2(ListNode head) {
>        if (head == null || head.next == null) {
>            return head;
>        }
>        ListNode next = head.next;
>        ListNode newHead = reverseList2(next);
>        next.next = head;
>        head.next = null;
>        return newHead;
>    }
>```
>
>

## 92翻转链表II

>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
>
>来源：力扣（LeetCode）
>链接：https://leetcode-cn.com/problems/reverse-linked-list-ii
>
>```java
>public ListNode reverseBetween(ListNode head, int m, int n) {
>        ListNode fakeNode=new ListNode(-1);
>        fakeNode.next=head;
>        ListNode pre=new ListNode(-1);
>        pre=fakeNode;
>        for(int i=1;i<=m-1;i++)
>            pre=pre.next;
>        ListNode start=pre.next;
>        ListNode then=start.next;
>        for(int i=1;i<=n-m;i++){
>            start.next=then.next;
>            then.next=pre.next;
>            pre.next=then;
>            then=start.next;
>        }
>        return fakeNode.next;
>    }
>```
>
>## 

## 25k个一组翻转链表

>```java
>class Solution {
>    public ListNode reverseKGroup(ListNode head, int k) {
>        ListNode hair = new ListNode(0);
>        hair.next = head;
>        ListNode pre = hair;
>
>        while (head != null) {
>            ListNode tail = pre;
>            // 查看剩余部分长度是否大于等于 k
>            for (int i = 0; i < k; ++i) {
>                tail = tail.next;
>                if (tail == null) {
>                    return hair.next;
>                }
>            }
>            ListNode nex = tail.next;
>            ListNode[] reverse = myReverse(head, tail);
>            head = reverse[0];
>            tail = reverse[1];
>            // 把子链表重新接回原链表
>            pre.next = head;
>            tail.next = nex;
>            pre = tail;
>            head = tail.next;
>        }
>
>        return hair.next;
>    }
>
>    //翻转从head到tail的链表，并且返回翻转后的头和尾
>    public ListNode[] myReverse(ListNode head, ListNode tail) {
>        ListNode prev = tail.next;
>        ListNode p = head;
>        while (prev != tail) {
>            ListNode nex = p.next;
>            p.next = prev;
>            prev = p;
>            p = nex;
>        }
>        return new ListNode[]{tail, head};
>    }
>}
>```
>
>

## 环形链表&相交链表

>```java
>//环形链表
>public class Solution {
>    public boolean hasCycle(ListNode head) {
>        if(head==null)return false;
>        ListNode walker=head;
>        ListNode runner=head;
>        while(walker.next!=null&&runner.next!=null&&runner.next.next!=null){
>        	walker=walker.next;
>        	runner=runner.next.next;
>        	if(walker==runner)return true;
>        }
>        return false;
>    }
>}
>//相交链表
>public class Solution {
>    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
>        ListNode p=headA;
>        ListNode q=headB;
>        while(p!=q){
>            p=p==null?headB:p.next;
>            q=q==null?headA:q.next;
>        }
>        return p;
>    }
>}
>```
>
>

## 328奇偶链表

>拆分两条链表即可然后拼起来即可
>
>```java
>class Solution {
>    public ListNode oddEvenList(ListNode head) {
>        if(head==null || head.next==null){
>            return head;
>        }
>        ListNode fake=new ListNode(-1);
>        fake.next=head.next;
>        ListNode odd=head, even=head.next;
>        while(even!=null && even.next!=null){
>            odd.next=even.next;
>            odd=odd.next;
>            even.next=odd.next;
>            even=even.next;
>        }
>        odd.next=fake.next;
>        return head;
>    }
>}
>```
>
>

## 138复制带随机指针的链表

>
>
>```java
>class Solution {
>    public Node copyRandomList(Node head) {
>        if(head == null){
>            return null;
>        }
>        Node cur = head;
>        HashMap<Node,Node> map = new HashMap<>();
>        while(cur!=null){
>            map.put(cur,new Node(cur.val));
>            cur = cur.next;
>        }
>        cur=head;
>        while(cur!=null){
>            map.get(cur).next=map.get(cur.next);
>            map.get(cur).random=map.get(cur.random);
>            cur=cur.next;
>        }
>        return map.get(head);
>    }
>}
>```
>
>

# 树

```java
 public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode(int x) { val = x; }
 }
```

## 递归

### 101对称二叉树

>检查二叉树是否轴对称
>
>```java
>class Solution {
>    public boolean isSymmetric(TreeNode root) {
>        if(root==null)return true;
>        return isSymmetricHelper(root.left,root.right);
>    }
>    public boolean isSymmetricHelper(TreeNode p,TreeNode q) {
>        if(p==null&&q==null)return true;
>        if(p==null||q==null)return false;
>        if(p.val==q.val)
>            return isSymmetricHelper(p.left,q.right)&&isSymmetricHelper(p.right,q.left);
>        return false;
>    }
>}
>
>```
>
>

### 104二叉树的最大深度

>```java
>class Solution {
>    public int maxDepth(TreeNode root) {
>             if (root == null) {
>                 return 0;
>             }
>             return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
>        }
>}
>```
>
>

### 111最小深度

>
>
>```java
>public class Solution {
>public int minDepth(TreeNode root) {
>   if(root==null) {
>			return 0;
>		}
>   if(root.left==null) {
>			return minDepth(root.right)+1;
>		}
>   if(root.right==null) {
>			return minDepth(root.left)+1;
>		}
>   return Math.min(minDepth(root.left),minDepth(root.right))+1;
>}
>public static void main(String[] args){
>	TreeNode[] tr1=new TreeNode[7];
>	 tr1[0]=new TreeNode(1);
>	 tr1[1]=new TreeNode(2);
>	 tr1[2]=new TreeNode(2);
>	 tr1[3]=new TreeNode(3);
>	 tr1[4]=new TreeNode(4);
>	 tr1[5]=new TreeNode(4);
>	 tr1[6]=new TreeNode(3);
>	 tr1[0].left=tr1[1];
>	 tr1[0].right=tr1[2];
>	 tr1[1].left=tr1[3];
>	 tr1[1].right=tr1[4];
>	 tr1[2].left=tr1[6];
>	 tr1[2].right=tr1[5];
>	 Solution s=new Solution();
>	 System.out.println(s.minDepth(tr1[0]));
>}
>}
>```
>
>

### 110平衡树

>
>
>```java
>public class Solution {
>public boolean isBalanced(TreeNode root) {
>	if(root==null) {
>			return true;
>		}
>	int nleft=treeDepth(root.left);
>	int nright=treeDepth(root.right);
>	if(nleft-nright>1||nleft-nright<-1) {
>			return false;
>		}
>   return isBalanced(root.left)&&isBalanced(root.right);
>}
>	public int treeDepth(TreeNode root){
>			if (root == null) {
>            return 0;
>        }
>        return Math.max(treeDepth(root.left), treeDepth(root.right)) + 1;
>  } 	 
>	 
>  public static void main(String[] args){
>		 TreeNode[] tr1=new TreeNode[7];
>	 tr1[0]=new TreeNode(1);
>	 tr1[1]=new TreeNode(2);
>	 tr1[2]=new TreeNode(2);
>	 tr1[3]=new TreeNode(3);
>	 tr1[4]=new TreeNode(4);
>	 tr1[5]=new TreeNode(4);
>	 tr1[6]=new TreeNode(3);
>	 tr1[0].left=tr1[1];
>	 //tr1[0].right=tr1[2];
>	 tr1[1].left=tr1[3];
>	 tr1[1].right=tr1[4];
>	// tr1[2].left=tr1[6];
>	 //tr1[2].right=tr1[5];
>	 Solution s=new Solution();
>	 System.out.println(s.isBalanced(tr1[0]));	 
>	 }
>}
>```
>
>

### 543两节点的最长路径

>
>
>```java
>public class Solution {
>    int max = 0;
>
>    public int diameterOfBinaryTree(TreeNode root) {
>        helper(root);
>        return max;
>    }
>
>    public int helper(TreeNode root) {
>        if (root == null) {
>            return 0;
>        }
>        int left = helper(root.left);
>        int right = helper(root.right);
>        max = Math.max(max, right + left);
>        return Math.max(left, right) + 1;
>    }
>
>    public static void main(String[] args) {
>        TreeNode[] tr1 = new TreeNode[7];
>        tr1[0] = new TreeNode(1);
>        tr1[1] = new TreeNode(2);
>        tr1[2] = new TreeNode(3);
>        tr1[3] = new TreeNode(4);
>        tr1[4] = new TreeNode(5);
>        tr1[5] = new TreeNode(6);
>        tr1[6] = new TreeNode(7);
>        tr1[0].left = tr1[1];
>        tr1[0].right = tr1[2];
>        tr1[1].left = tr1[3];
>        tr1[1].right = tr1[4];
>	/* tr1[2].left=tr1[5];
>	 tr1[2].right=tr1[6];*/
>        Solution s = new Solution();
>        System.out.println(s.diameterOfBinaryTree(tr1[0]));
>    }
>}
>```
>
>

### 112路径总和I

> 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
>
> ```java
> class Solution {
>     public boolean hasPathSum(TreeNode root, int sum) {
>         if(root==null)
>                 return false;
>             sum-=root.val;
>             if(root.left==null&&root.right==null&&sum==0)
>                 return true;
>             return hasPathSum(root.left,sum)||hasPathSum(root.right,sum);
>     }
> }
> ```
>
> 

### 113路径总和II

> 求出每一条路径
>
> ```java
> class Solution {
>     List<List<Integer>> result=new ArrayList<List<Integer>>();
>     List<Integer> tempList=new ArrayList<>();
>     public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
>         backtrack(root, targetSum);
>         return result;
>     }
> 
>  public void backtrack(TreeNode start,int sum){
>      if(start==null)return;
>      tempList.add(start.val);
>      if(start.left==null&&start.right==null&&sum==start.val)
>          result.add(new ArrayList<>(tempList));
>      backtrack(start.left, sum-start.val);
>      backtrack(start.right, sum-start.val);
>      tempList.remove(tempList.size()-1);
>  }
> }
> ```
>
> 

### 437路径总和III

> 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的路径 的数目。
>
> ```java
> class Solution {
>     public int pathSum(TreeNode root, int sum) {
>         if(root==null)return 0;
>         return dfs(root,sum)+pathSum(root.left,sum)+pathSum(root.right,sum);
>     }
> public int dfs(TreeNode root,int sum){
>     if(root==null)return 0;
>     int count=0;
>     if(root.val==sum)
>         count++;
>     return count+dfs(root.left,sum-root.val)+dfs(root.right,sum-root.val);
> }
> }
> ```
>
> 

### 236二叉树的最近公共祖先

>
>
>```java
>class Solution {
>    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
>        if(root==null||root==p||root==q)
>            return root;
>        TreeNode left=lowestCommonAncestor(root.left,p,q);
>        TreeNode right=lowestCommonAncestor(root.right,p,q);
>        if(left!=null&&right!=null)return root;
>        if(left!=null)return left;
>        if(right!=null)return right;
>        return null;
>    }
>}
>```
>
>

### 199二叉树的右视图

>思路：本质是层次遍历的变种，放入队列时从右往左放，放入结果集时只放第一个就行
>
>```java
>class Solution {
>    public List<Integer> rightSideView(TreeNode root) {
>        Queue<TreeNode> queue=new LinkedList<TreeNode>();
>        List<Integer> list=new ArrayList<Integer>();
>        if(root==null)return list;
>        queue.offer(root);
>        while(!queue.isEmpty()){
>            int size=queue.size();
>            list.add(queue.peek().val);
>            for(int i=0;i<size;i++){
>                TreeNode temp=queue.poll();
>                if(temp.right!=null)
>                    queue.offer(temp.right);
>                if(temp.left!=null)
>                    queue.offer(temp.left);
>            }
>        }
>        return list;
>    }
>}
>```
>
>

### 662二叉树最大宽度

>```java
>public int widthOfBinaryTree(TreeNode root) {
>        if (root == null) {
>            return 0;
>        }
>        LinkedList<TreeNode> queue = new LinkedList();
>        root.val = 1;
>        queue.addLast(root);
>        int maxWidth = 1;
>        while (!queue.isEmpty()) {
>            int size = queue.size();
>            int beginIndex = -1;
>            for (int i = 0; i < size; i++) {
>                if (queue.peek() != null) {
>                    TreeNode treeNode = queue.peek();
>                    if (treeNode.left != null) {
>                        treeNode.left.val = treeNode.val * 2;
>                        queue.offer(treeNode.left);
>                    }
>                    if (treeNode.right != null) {
>                        treeNode.right.val = treeNode.val * 2 + 1;
>                        queue.offer(treeNode.right);
>                    }
>                }
>                if (beginIndex == -1) {
>                    beginIndex = queue.pop().val;
>                } else {
>                    maxWidth = Math.max(queue.pop().val - beginIndex + 1, maxWidth);
>                }
>            }
>        }
>        return maxWidth;
>    }
>```
>
>

### 114二叉树展开为链表

>
>
>```java
>class Solution {
>    public void flatten(TreeNode root) {
>        while(root!=null){       
>            if(root.left!=null){//左子树不为空，就把右子树接到左子树最后访问的节点上
>                TreeNode cur=root.left;
>                while(cur.right!=null)//找到最后访问的节点
>                    cur=cur.right;
>                cur.right=root.right;//把右子树接到左子树最后访问的节点上
>                root.right=root.left;//把左子树接到又子树上
>                root.left=null;//置空左子树
>            }
>            root=root.right;//往右子树继续重复上述步骤
>        }
>    }
>}
>```
>
>

### 958二叉树的完全性检验

>```java
>class Solution {
>    public boolean isCompleteTree(TreeNode root) {
>        LinkedList<TreeNode> q = new LinkedList<>();
>        TreeNode cur;
>        q.addLast(root);
>        while ((cur = q.removeFirst()) != null) {
>            q.addLast(cur.left);
>            q.addLast(cur.right);
>        }
>        while (!q.isEmpty()) {
>            if (q.removeLast() != null) {
>                return false;
>            }
>        }
>        return true;
>    }
>}
>```
>
>

### 226翻转二叉树

>
>
>```java
>//非递归解法
>class Solution {
>    public TreeNode invertTree(TreeNode root) {
>        if(root==null)return null;
>	Stack<TreeNode> s=new Stack<TreeNode>();
>	s.push(root);
>	while(s.size()>0){
>		TreeNode node=s.pop();
>		TreeNode temp=node.left;
>		node.left=node.right;
>		node.right=temp;		
>		if(node.right!=null)
>			s.push(node.right);	
>		if(node.left!=null)
>			s.push(node.left);
>	}
>	return root;
>    }
>}
>```
>
>```java
>//递归解法
>class Solution {
>    public TreeNode invertTree(TreeNode root) {
>        if (root == null) {
>            return null;
>        }
>        TreeNode left = invertTree(root.left);
>        TreeNode right = invertTree(root.right);
>        root.left = right;
>        root.right = left;
>        return root;
>    }
>}
>```
>
>

### 617合并二叉树

>
>
>```java
>class Solution {
>    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
>        if(t1==null&&t2==null)return null;
>        int newval=(t1==null?0:t1.val)+(t2==null?0:t2.val);
>        TreeNode newtr=new TreeNode(newval);
>        newtr.left=mergeTrees(t1==null?null:t1.left,t2==null?null:t2.left);
>        newtr.right=mergeTrees(t1==null?null:t1.right,t2==null?null:t2.right);
>        return newtr;
>    }
>}
>```
>
>

### 297二叉树的序列化与反序列化

>
>
>```java
>public class Codec {
>
>    // Encodes a tree to a single string.
>    public String serialize(TreeNode root) {
>        return rserialize(root, "");
>    }
>  
>    // Decodes your encoded data to tree.
>    public TreeNode deserialize(String data) {
>        String[] dataArray = data.split(",");
>        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));
>        return rdeserialize(dataList);
>    }
>
>    public String rserialize(TreeNode root, String str) {
>        if (root == null) {
>            str += "None,";
>        } else {
>            str += str.valueOf(root.val) + ",";
>            str = rserialize(root.left, str);
>            str = rserialize(root.right, str);
>        }
>        return str;
>    }
>  
>    public TreeNode rdeserialize(List<String> dataList) {
>        if (dataList.get(0).equals("None")) {
>            dataList.remove(0);
>            return null;
>        }
>  
>        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));
>        dataList.remove(0);
>        root.left = rdeserialize(dataList);
>        root.right = rdeserialize(dataList);
>    
>        return root;
>    }
>}
>```
>
>

### 572子树

>
>
>```java
>public class Solution {
>    public boolean isSubtree(TreeNode s, TreeNode t) {
>        if (s == null) {
>            return false;
>        }
>        if (isSame(s, t)) {
>            return true;
>        }
>        return isSubtree(s.left, t) || isSubtree(s.right, t);
>    }
>
>    public boolean isSame(TreeNode s, TreeNode t) {
>        if (s == null && t == null) {
>            return true;
>        }
>        if (s == null || t == null) {
>            return false;
>        }
>        if (s.val != t.val) {
>            return false;
>        }
>        return isSame(s.left, t.left) && isSame(s.right, t.right);
>    }
>
>    public static void main(String[] args) {
>        TreeNode[] tr1 = new TreeNode[9];
>        tr1[0] = new TreeNode(3);
>        tr1[1] = new TreeNode(4);
>        tr1[2] = new TreeNode(5);
>        tr1[3] = new TreeNode(1);
>        tr1[4] = new TreeNode(2);
>        tr1[8] = new TreeNode(0);
>        tr1[0].left = tr1[1];
>        tr1[0].right = tr1[2];
>        tr1[1].left = tr1[3];
>        tr1[1].right = tr1[4];
>        tr1[4].left = tr1[8];
>
>        tr1[5] = new TreeNode(4);
>        tr1[6] = new TreeNode(1);
>        tr1[7] = new TreeNode(2);
>        tr1[5].left = tr1[6];
>        tr1[5].right = tr1[7];
>
>        Solution s = new Solution();
>        System.out.println(s.isSubtree(tr1[0], tr1[5]));
>    }
>}
>```

### 404统计左叶子节点的和

>对于一个节点，如果左叶子节点没有子节点了，那么这个值就是最终的值要加上，否则需要递归
>
>```java
>public class Solution {
>public int sumOfLeftLeaves(TreeNode root) {
>        int sum=0;
>        if(root==null) {
>         		return sum;
>      		}
>        if(root.left!=null){
>          	 if(root.left.left==null&&root.left.right==null) {
>            			sum+=root.left.val;
>             } else {
>                 sum+=sumOfLeftLeaves(root.left);
>             }
>        }
>        sum+=sumOfLeftLeaves(root.right);
>        return sum;
>    }
>public static void main(String[] args){
>             Solution s=new Solution();
>             TreeNode[] tr1=new TreeNode[7];
>              tr1[0]=new TreeNode(1);
>              tr1[1]=new TreeNode(2);
>              tr1[2]=new TreeNode(2);
>              tr1[3]=new TreeNode(3);
>              tr1[4]=new TreeNode(4);
>              tr1[5]=new TreeNode(4);
>              tr1[6]=new TreeNode(3);
>              tr1[0].left=null;
>              tr1[0].right=tr1[2];
>              tr1[1].left=tr1[3];
>              tr1[1].right=tr1[4];
>              tr1[2].left=null;
>              tr1[2].right=null;
>              System.out.println(s.sumOfLeftLeaves(tr1[0]));
>				}
>}
>```

### 687相同节点值的最大路径长度

>
>
>```java
>public class Solution {
>    int max = 0;
>
>    public int longestUnivaluePath(TreeNode root) {
>        helper(root);
>        return max;
>    }
>
>    public int helper(TreeNode root) {
>        if (root == null) {
>            return 0;
>        }
>        int left = helper(root.left);//这里是关键，在计算每个节点的值的时候已经算出了其左右节点
>        int right = helper(root.right);
>        int leftCount = 0, rightCount = 0;
>        if (root.left != null && root.left.val == root.val) {
>            leftCount = left + 1;
>        }
>        if (root.right != null && root.right.val == root.val) {
>            rightCount = right + 1;
>        }
>        max = Math.max(max, leftCount + rightCount);
>        return Math.max(leftCount, rightCount);
>    }
>
>    public static void main(String[] args) {
>        TreeNode[] tr1 = new TreeNode[6];
>        tr1[0] = new TreeNode(5);
>        tr1[1] = new TreeNode(4);
>        tr1[2] = new TreeNode(5);
>        tr1[3] = new TreeNode(1);
>        tr1[4] = new TreeNode(1);
>        tr1[5] = new TreeNode(5);
>        tr1[0].left = tr1[1];
>        tr1[0].right = tr1[2];
>        tr1[1].left = tr1[3];
>        tr1[1].right = tr1[4];
>        tr1[2].right = tr1[5];
>        Solution s = new Solution();
>        System.out.println(s.longestUnivaluePath(tr1[0]));
>    }
>}
>```
>
>

### 671找出二叉树中第二小的节点

>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 `2` 或 `0`。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
>
>```java
>public class Solution {
>public int findSecondMinimumValue(TreeNode root) {
>        if (root==null) {
>			return -1;
>		}
>        return findHelper(root, root.val);
>    }
>public int findHelper(TreeNode root,int min){
>	if(root==null) {
>		return -1;
>	}
>	if(root.val>min) {
>		return root.val;
>	}
>	int left=findHelper(root.left, min);
>	int right=findHelper(root.right, min);
>	return (left==-1||right==-1)?Math.max(left, right):Math.min(left, right);
>}
>	public static void main(String[] args) {
>		TreeNode[] tr1=new TreeNode[7];
>		 tr1[0]=new TreeNode(2);
>		 tr1[1]=new TreeNode(2);
>		 tr1[2]=new TreeNode(5);
>		 tr1[3]=new TreeNode(5);
>		 tr1[4]=new TreeNode(7);
>		 tr1[0].left=tr1[1];
>		 tr1[0].right=tr1[2];
>		 tr1[2].left=tr1[3];
>		 tr1[2].right=tr1[4];
>		 Solution s=new Solution();
>		 System.out.println(s.findSecondMinimumValue(tr1[0]));
>	}
>}
>```
>
>

### 找出从根节点到指定节点的路径

>```java
>public class Solution {
>    public static void main(String[] args) {
>        TreeNode[] tr = new TreeNode[7];
>        tr[0] = new TreeNode(1);
>        tr[1] = new TreeNode(2);
>        tr[2] = new TreeNode(3);
>        tr[3] = new TreeNode(4);
>        tr[4] = new TreeNode(5);
>        tr[5] = new TreeNode(6);
>        tr[6] = new TreeNode(7);
>        tr[0].left = tr[1];
>        tr[0].right = tr[2];
>        tr[1].left = tr[3];
>        tr[1].right = tr[4];
>        tr[2].left = tr[5];
>        tr[2].right = tr[6];
>        ArrayList<TreeNode> treeNodes = new ArrayList<>();
>        Solution solution = new Solution();
>        solution.getPath(tr[0], tr[4], treeNodes);
>        for (TreeNode treeNode : treeNodes) {
>            System.out.println(treeNode.val);
>        }
>    }
>
>    public boolean getPath(TreeNode root, TreeNode node, List<TreeNode> path) {
>        if (root == node) {
>            return true;
>        }
>        path.add(root);
>        boolean found = false;
>        if (root.left != null) {
>            found = getPath(root.left, node, path);
>        }
>        if (!found && root.right != null) {
>            found = getPath(root.right, node, path);
>        }
>        if (!found) {
>            path.remove(path.size() - 1);
>        }
>        return found;
>    }
>}
>```
>
>

## 求从根节点到所有叶节点的路径

>
>
>```java
>public class Solution {
>    List<List<Integer>> result = new ArrayList<>();
>    List<Integer> tempList = new ArrayList<>();
>
>    public void backTrack(TreeNode root) {
>        if (root == null) {
>            return;
>        }
>        tempList.add(root.val);
>        if (root.left == null && root.right == null) {
>            result.add(new ArrayList<>(tempList));
>        }
>        backTrack(root.left);
>        backTrack(root.right);
>        tempList.remove(tempList.size() - 1);
>    }
>}
>```
>
>

## 层次遍历

### 513得到左下角节点

>```java
>public int findBottomLeftValue(TreeNode root) {
>        Queue<TreeNode> queue = new LinkedList<>();
>        queue.add(root);
>        while (!queue.isEmpty()) {
>            root = queue.poll();
>            if (root.right != null) {
>                queue.add(root.right);
>            }
>            if (root.left != null) {
>                queue.add(root.left);
>            }
>        }
>        return root.val;
>    }
>```
>
>

### 102.二叉树的层序遍历

>**之字形遍历**时，只需要记一个标志然后翻转得到的数据或者使用双端队列头插或者尾插；
>
>**倒层序遍历**时，从下往上添加，只需要在结果列表插入时从头插入;
>
>```java
>//标准层次遍历
>class Solution {
>    public List<List<Integer>> levelOrder(TreeNode root) {
>        Queue<TreeNode> q=new LinkedList<TreeNode>();
>        List<List<Integer>> res=new LinkedList<>();
>        if(root==null)return res;
>        q.offer(root);        
>        while(!q.isEmpty()){
>            int qSize=q.size();    
>            List<Integer> tempList=new LinkedList<>();
>            for(int i=0;i<qSize;i++){               
>                if(q.peek().left!=null)q.offer(q.peek().left);
>                if(q.peek().right!=null)q.offer(q.peek().right);
>                tempList.add(q.poll().val);
>            }
>            res.add(tempList);
>        }
>        return res;
>    }
>}
>```
>
>

### 129求根节点到叶节点数字之和

> 仍然用层次遍历，每次将父节点的数乘10然后赋给子节点，当节点的左右子树都为null时将其加入求和
>
> ```java
> class Solution {
>     public int sumNumbers(TreeNode root) {
>         if(root==null)return 0;
>          Queue<TreeNode> queue=new LinkedList<>();
>         queue.offer(root);
>         int sum=0;
>         while(!queue.isEmpty()){
>             int size=queue.size();           
>             for(int i=0;i<size;i++){
>                 TreeNode temp=queue.poll();
>                 if(temp.left==null&&temp.right==null)
>                     sum+=temp.val;
>                 else{
>                     if(temp.left!=null){
>                         temp.left.val=10*temp.val+temp.left.val;
>                         queue.offer(temp.left);
>                     }
>                     if(temp.right!=null){
>                         temp.right.val=10*temp.val+temp.right.val;
>                         queue.offer(temp.right);
>                     }
>                 }
>             }
>         }
>         return sum;
>     }
> }
> ```
>
> 

## 前中后序遍历

### 105从前序与中序遍历构造二叉树

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTreeHelper(0,0,inorder.length-1, preorder, inorder);
    }
    public TreeNode buildTreeHelper(int preStart,int inStart,int inEnd,int[] preorder, int[] inorder){
        if(preStart>preorder.length-1||inStart>inEnd)
            return null;
        TreeNode root=new TreeNode(preorder[preStart]);
        int inIndex=0;
        for(int i=0;i<inorder.length;i++){
            if(root.val==inorder[i])
                inIndex=i;
        }
        root.left=buildTreeHelper(preStart+1, inStart, inIndex-1, preorder, inorder);
        root.right=buildTreeHelper(preStart+inIndex-inStart+1, inIndex+1, inEnd, preorder, inorder);
        return root;
    }
}
```

### 106中序与后续遍历恢复二叉树

```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTreeHelper(postorder.length-1, 0, inorder.length-1, inorder, postorder);
    }
    public TreeNode buildTreeHelper(int postEnd,int inStart,int inEnd,int[] inorder, int[] postorder) {
        if(postEnd<0||inStart>inEnd)
            return null;
        TreeNode root=new TreeNode(postorder[postEnd]);
        int inIndex=0;
        for (int i = 0; i < inorder.length; i++)
            if(root.val==inorder[i])
                inIndex=i;
        root.left=buildTreeHelper(postEnd-(inEnd-inIndex)-1, inStart, inIndex-1, inorder, postorder);
        root.right=buildTreeHelper(postEnd-1, inIndex+1, inEnd, inorder, postorder);
        return root;
    }
}
```

### 94二叉树的中序遍历

```java
public class InorderTraversal {
    //使用递归方法遍历
    public List<Integer> inorderTraversal1(TreeNode root) {
        List<Integer> res=new ArrayList<Integer>();
        inorderTraversalHelp(root,res);
        return res;
    }
    public void inorderTraversalHelp(TreeNode root,List<Integer> res) {
        if(root!=null){
            inorderTraversalHelp(root.left,res);
            res.add(root.val);
            inorderTraversalHelp(root.right, res);
        }
    }
    //使用非递归方法遍历
    public List<Integer> inorderTraversal2(TreeNode root) {
        Stack<TreeNode> s=new Stack<TreeNode>();
        List<Integer> l=new ArrayList<Integer>();
        TreeNode cur=root;
        while(!s.isEmpty()||root!=null){
            while(cur!=null){
                s.push(cur);
                cur=cur.left;
            }
            cur=s.pop();
            l.add(cur.val);
            cur=cur.right;
        }
        return l;
    }
}
```

### 145 二叉树的前序遍历

```java
public class PreOrder {
    //递归
    public List<Integer> preorderTraversal1(TreeNode root) {
        List<Integer> list=new ArrayList<Integer>();
        preorderTraversal(root,list);
        return list;
    }
    public void preorderTraversal(TreeNode root,List<Integer> list) {
        if(root!=null) {
            list.add(root.val);
            preorderTraversal(root.left,list);
            preorderTraversal(root.right,list);
        }
    }
    //非递归
    public List<Integer> preorderTraversal2(TreeNode root) {
        Stack<TreeNode> stack=new Stack<>();
        List<Integer> res=new ArrayList<>();
        if(root==null){
            return res;
        }
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            res.add(node.val);
            if(node.right!=null){
                stack.push(node.right);
            }
            if(node.left!=null){
                stack.push(node.left);
            }
        }
        return res;
    }
}
```

### 144 二叉树的后序遍历

```java
//前序遍历的顺序是根左右，后序遍历的顺序是左右根，要实现左右根可以先按前序遍历的方法实现根右左然后倒序一下变成左右根
public class PostOrder {
    //递归
    public List<Integer>  postorderTraversal1(TreeNode root) {
        List<Integer> list=new ArrayList<Integer>();
        preorderTraversal(root,list);
        return list;
    }
    public void preorderTraversal(TreeNode root,List<Integer> list) {
        if(root!=null) {
            preorderTraversal(root.left,list);
            preorderTraversal(root.right,list);
            list.add(root.val);
        }
    }
    //非递归
    public List<Integer> postorderTraversal2(TreeNode root) {
        Stack<TreeNode> stack=new Stack<>();
        List<Integer> res=new ArrayList<>();
        if(root==null){
            return res;
        }
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            res.add(node.val);
            if(node.left!=null){
                stack.push(node.left);
            }
            if(node.right!=null){
                stack.push(node.right);
            }
        }
        Collections.reverse(res);
        return res;
    }
}
```

## BST

### 669修剪二叉搜索树

>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构
>
>```java
>public TreeNode trimBST(TreeNode root, int L, int R) {
>        if(root==null) {
>			return null;
>		}
>        if(root.val<L) {
>			return trimBST(root.right, L, R);
>		}
>        if(root.val>R) {
>			return trimBST(root.left, L, R);
>		}
>        root.left=trimBST(root.left, L, R);
>        root.right=trimBST(root.right, L, R);
>        return root;
>    }
>```
>
>

### 98验证二叉搜索树

>验证一棵树是不是二叉搜索树
>
>```java
>class Solution {
>   public boolean isValidBST(TreeNode root) {
>        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);
>    }
>    public boolean isValidBST(TreeNode root,long minVal,long maxVal){
>        if(root==null)return true;
>        if(root.val>=maxVal||root.val<=minVal)return false;
>        return isValidBST(root.left, minVal, root.val)&&isValidBST(root.right,root.val,maxVal);
>    }
>}
>```
>
>

### 230二叉搜索树中第K小的元素

>```java
>class Solution {
>    public int kthSmallest(TreeNode root, int k) {
>        if(count(root.left)==k-1)//如果左子树的节点数刚好是k-1,那根节点就是要找的节点
>            return root.val;
>        if(count(root.left)<k-1)//如果左子树的节点比k-1个要少，那就在右子树上找
>            return kthSmallest(root.right,k-count(root.left)-1);
>        return kthSmallest(root.left,k);//否则在左子树上找
>    }
>    public int count(TreeNode root){//左右子树一共有多少个节点
>        if(root==null){
>          return 0;
>        }
>        return 1+count(root.left)+count(root.right);
>    }
>}
>
>//或者使用中序遍历
>class Solution{
>    private int cnt = 0;
>    private int val;
>
>    public int kthSmallest(TreeNode root, int k) {
>        inOrder(root, k);
>        return val;
>    }
>
>    private void inOrder(TreeNode node, int k) {
>        if (node == null) return;
>        inOrder(node.left, k);
>        cnt++;
>        if (cnt == k) {
>            val = node.val;
>            return;
>        }
>        inOrder(node.right, k);
>    }
>}
>```
>
>

### 538把二叉搜索树转换为累加树

>把每个节点的值都加上比他大的节点的值
>
>输入：root = [3,2,4,1]
>输出：[7,9,4,10]
>
>```java
>public class Solution {
>    int sum = 0;
>
>    public TreeNode convertBST(TreeNode root) {
>        convert(root);
>        return root;
>    }
>
>    public void convert(TreeNode current) {
>        if (current == null) {
>            return;
>        }
>        convert(current.right);
>        current.val += sum;
>        sum = current.val;
>        convert(current.left);
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        TreeNode[] tr1 = new TreeNode[3];
>        tr1[0] = new TreeNode(5);
>        tr1[1] = new TreeNode(2);
>        tr1[2] = new TreeNode(13);
>        tr1[0].left = tr1[1];
>        tr1[0].right = tr1[2];
>        s.convertBST(tr1[0]);
>        System.out.println(tr1[0].val + " " + tr1[1].val + " " + tr1[2].val);
>    }
>}
>```
>
>

### 235二叉查找树的最近公共祖先

>```java
>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
>        if (root.val > p.val && root.val > q.val) {
>            return lowestCommonAncestor(root.left, p, q);
>        }
>        if (root.val < p.val && root.val < q.val) {
>            return lowestCommonAncestor(root.right, p, q);
>        }
>        return root;
>}
>```
>
>

### 108从有序数组中构造二叉查找树

>```java
>public class Solution {
>    public TreeNode sortedArrayToBST(int[] nums) {
>        if (nums.length == 0) {
>            return null;
>        }
>        TreeNode head = helper(nums, 0, nums.length - 1);
>        return head;
>    }
>
>    public TreeNode helper(int[] nums, int low, int high) {
>        if (low > high) {
>            return null;
>        }
>        int middle = low + (high - low + 1) / 2;
>        System.out.println(middle);
>        TreeNode node = new TreeNode(nums[middle]);
>        node.left = helper(nums, low, middle - 1);
>        node.right = helper(nums, middle + 1, high);
>        return node;
>    }
>}
>```
>
>

### 109根据有序链表构造平衡的二叉查找树

>与上边的根据数组构造类似，但是要找到链表的中间节点
>
>```java
>public class Solution {
>    public TreeNode sortedListToBST(ListNode head) {
>        if (head == null) {
>            return null;
>        }
>        return creatBST(head, null);
>    }
>
>    public TreeNode creatBST(ListNode head, ListNode tail) {
>        ListNode slow = head;
>        ListNode fast = head;
>        if (head == tail) {
>            return null;
>        }
>        while (fast != tail && fast.next != tail) {
>            slow = slow.next;
>            fast = fast.next.next;
>        }
>        TreeNode root = new TreeNode(slow.val);
>        root.left = creatBST(head, slow);
>        root.right = creatBST(slow.next, tail);
>        return root;
>    }
>}
>```
>
>

### 654两数之和IV

>
>
>```java
>class Solution {
>    Set<Integer> s = new HashSet<>();
>    public boolean findTarget(TreeNode root, int k) {
>        
>        return dfs(root, k);
>    }
>
>    public boolean dfs(TreeNode root, int k) {
>        if (root == null) {
>            return false;
>        }
>        if (s.contains(k - root.val)) {
>            return true;
>        }
>        s.add(root.val);
>        return dfs(root.left, k) || dfs(root.right, k);
>    }
>}
>
>//或者可以直接将树中序遍历为数组然后二分查找
>class Solution{
>      public boolean findTarget(TreeNode root, int k) {
>          List<Integer> nums = new ArrayList<>();
>          inOrder(root, nums);
>          int i = 0, j = nums.size() - 1;
>          while (i < j) {
>              int sum = nums.get(i) + nums.get(j);
>              if (sum == k) return true;
>              if (sum < k) i++;
>              else j--;
>          }
>          return false;
>      }
>
>      private void inOrder(TreeNode root, List<Integer> nums) {
>          if (root == null) return;
>          inOrder(root.left, nums);
>          nums.add(root.val);
>          inOrder(root.right, nums);
>      }
>}
>```
>
>

### 530在二叉查找树中查找两个节点之差的最小绝对值

>利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。
>
>```java
>public class Solution {
>    int min = Integer.MAX_VALUE;
>    Integer prev = null;
>
>    public int getMinimumDifference(TreeNode root) {
>        if (root == null) {
>            return min;
>        }
>        getMinimumDifference(root.left);
>        if (prev != null) {
>            min = Math.min(min, root.val - prev);
>        }
>        prev = root.val;
>        getMinimumDifference(root.right);
>        return min;
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        TreeNode[] tr1 = new TreeNode[3];
>        tr1[0] = new TreeNode(1);
>        tr1[1] = new TreeNode(3);
>        tr1[2] = new TreeNode(2);
>        tr1[0].right = tr1[1];
>        tr1[1].left = tr1[2];
>        System.out.println(s.getMinimumDifference(tr1[0]));
>    }
>}
>```
>
>

### 501寻找二叉查找树中出现次数最多的值

>
>
>```java
>public class Solution {
>    TreeNode prev;
>    int count = 0;
>    int maxCount = -1;
>
>    public int[] findMode(TreeNode root) {
>        List<Integer> modes = new ArrayList<Integer>();
>        prev = root;
>        inorder(root, modes);
>        int[] ret = new int[modes.size()];
>        for (int i = 0; i < modes.size(); i++) {
>            ret[i] = modes.get(i);
>        }
>        return ret;
>    }
>
>    public void inorder(TreeNode root, List<Integer> modes) {
>        if (root == null) {
>            return;
>        }
>        inorder(root.left, modes);
>        count = prev.val == root.val ? count + 1 : 1;
>        if (count == maxCount) {
>            modes.add(root.val);
>        } else if (count > maxCount) {
>            modes.clear();
>            modes.add(root.val);
>            maxCount = count;
>        }
>        prev = root;
>        inorder(root.right, modes);
>    }
>
>    public static void main(String[] args) {
>        TreeNode[] tr1 = new TreeNode[7];
>        tr1[0] = new TreeNode(5);
>        tr1[1] = new TreeNode(4);
>        tr1[2] = new TreeNode(6);
>        tr1[3] = new TreeNode(2);
>        tr1[4] = new TreeNode(4);
>        tr1[5] = new TreeNode(6);
>        tr1[6] = new TreeNode(7);
>        tr1[0].left = tr1[1];
>        tr1[0].right = tr1[2];
>        tr1[1].left = tr1[3];
>        tr1[1].right = tr1[4];
>        tr1[2].left = tr1[5];
>        tr1[2].right = tr1[6];
>        Solution s = new Solution();
>        int[] a = s.findMode(tr1[0]);
>        for (int aa : a) {
>            System.out.println(aa);
>        }
>    }
>}
>```
>
>

## 二叉树迭代器

>实现一个二叉搜索树迭代器类`BSTIterator` ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
>
>- `BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的一个对象。BST 的根节点 `root` 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
>- `boolean hasNext()` 如果向指针右侧遍历存在数字，则返回 `true` ；否则返回 `false` 。
>- `int next()`将指针向右移动，然后返回指针处的数字。
>
>```java
>class BSTIterator {
>    Stack<TreeNode> stack=new Stack<TreeNode>();
>    public BSTIterator(TreeNode root) {
>        pushAll(root);
>    }
>    
>    /** @return the next smallest number */
>    public int next() {
>        TreeNode temp=stack.pop();
>        pushAll(temp.right);
>        return temp.val;
>    }
>    
>    /** @return whether we have a next smallest number */
>    public boolean hasNext() {
>        return !stack.isEmpty();
>    }
>    public void pushAll(TreeNode node){
>        while(node!=null){
>            stack.push(node);
>            node=node.left;
>        }
>    }
>}
>```
>
>

## Trie

### 208实现一个Trie

>
>
>```java
>class Trie {
>
>    private class Node {
>        Node[] childs = new Node[26];
>        boolean isLeaf;
>    }
>
>    private Node root = new Node();
>
>    public Trie() {
>    }
>
>    public void insert(String word) {
>        insert(word, root);
>    }
>
>    private void insert(String word, Node node) {
>        if (node == null) return;
>        if (word.length() == 0) {
>            node.isLeaf = true;
>            return;
>        }
>        int index = indexForChar(word.charAt(0));
>        if (node.childs[index] == null) {
>            node.childs[index] = new Node();
>        }
>        insert(word.substring(1), node.childs[index]);
>    }
>
>    public boolean search(String word) {
>        return search(word, root);
>    }
>
>    private boolean search(String word, Node node) {
>        if (node == null) return false;
>        if (word.length() == 0) return node.isLeaf;
>        int index = indexForChar(word.charAt(0));
>        return search(word.substring(1), node.childs[index]);
>    }
>
>    public boolean startsWith(String prefix) {
>        return startWith(prefix, root);
>    }
>
>    private boolean startWith(String prefix, Node node) {
>        if (node == null) return false;
>        if (prefix.length() == 0) return true;
>        int index = indexForChar(prefix.charAt(0));
>        return startWith(prefix.substring(1), node.childs[index]);
>    }
>
>    private int indexForChar(char c) {
>        return c - 'a';
>    }
>}
>```
>
>

### 677用Trie求前缀和

>
>
>```java
>class MapSum {
>
>    private class Node {
>        Node[] child = new Node[26];
>        int value;
>    }
>
>    private Node root = new Node();
>
>    public MapSum() {
>
>    }
>
>    public void insert(String key, int val) {
>        insert(key, root, val);
>    }
>
>    private void insert(String key, Node node, int val) {
>        if (node == null) return;
>        if (key.length() == 0) {
>            node.value = val;
>            return;
>        }
>        int index = indexForChar(key.charAt(0));
>        if (node.child[index] == null) {
>            node.child[index] = new Node();
>        }
>        insert(key.substring(1), node.child[index], val);
>    }
>
>    public int sum(String prefix) {
>        return sum(prefix, root);
>    }
>
>    private int sum(String prefix, Node node) {
>        if (node == null) return 0;
>        if (prefix.length() != 0) {
>            int index = indexForChar(prefix.charAt(0));
>            return sum(prefix.substring(1), node.child[index]);
>        }
>        int sum = node.value;
>        for (Node child : node.child) {
>            sum += sum(prefix, child);
>        }
>        return sum;
>    }
>
>    private int indexForChar(char c) {
>        return c - 'a';
>    }
>}
>```
>
>

# 搜索

## 深度优先&广度优先

### 695岛屿最大面积

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int maxArea=0;
        for(int i=0;i<grid.length;i++)
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                  maxArea=Math.max(maxArea, maxAreaOfIslandHelper(grid,i,j));
                }
            }
        return maxArea;
  }
public int maxAreaOfIslandHelper(int[][] grid,int i,int j){
    if(i>=0&&i<grid.length&&j>=0&&j<grid[0].length&&grid[i][j]==1){
        grid[i][j]=0;
        return 1+maxAreaOfIslandHelper(grid,i+1,j)+maxAreaOfIslandHelper(grid,i-1,j)+maxAreaOfIslandHelper(grid,i,j+1)+maxAreaOfIslandHelper(grid,i,j-1);
            }
    return 0;
}
}
```

### 200岛屿数量

>输入：grid = [
>  ["1","1","0","0","0"],
>  ["1","1","0","0","0"],
>  ["0","0","1","0","0"],
>  ["0","0","0","1","1"]
>]
>输出：3
>
>```java
>public class Main {
>    private int m, n;
>    private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
>
>    public int numIslands(char[][] grid) {
>        if (grid == null || grid.length == 0) {
>            return 0;
>        }
>        m = grid.length;
>        n = grid[0].length;
>        int islandsNum = 0;
>        for (int i = 0; i < m; i++) {
>            for (int j = 0; j < n; j++) {
>                if (grid[i][j] != '0') {
>                    dfs(grid, i, j);
>                    islandsNum++;
>                }
>            }
>        }
>        return islandsNum;
>    }
>
>    private void dfs(char[][] grid, int i, int j) {
>        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0') {
>            return;
>        }
>        grid[i][j] = '0';
>        for (int[] d : direction) {
>            dfs(grid, i + d[0], j + d[1]);
>        }
>    }
>```
>
>

## 回溯&剪枝

框架

>result = []
>void backtrack(路径, 选择列表){
>    if(满足结束条件){
>        result.add(路径)
>        return
>    }
>    for(选择:选择列表){               //搜索树的宽度
>        做选择
>        backtrack(路径, 选择列表)     //搜索树的深度，路径与选择列表分别给出了搜索目标与搜索范围（0还是index）
>        撤销选择
>    }
>}
>        
>回溯四部曲：
>回溯参数
>终止条件
>单层递归逻辑
>选择其他分支（撤销选择 重置状态） 
>
>回溯算法能解决如下问题：
>
>- 组合问题：N个数里面按一定规则找出k个数的集合
>- 排列问题：N个数按一定规则全排列，有几种排列方式
>- 切割问题：一个字符串按一定规则有几种切割方式
>- 子集问题：一个N个数的集合里有多少符合条件的子集
>- 棋盘问题：N皇后，解数独等等

### 77组合

>输入: n = 4, k = 2
>输出: [[2,4], [3,4], [2,3], [1,2],[1,3], [1,4]]
>
>```java
>List<List<Integer>> res = new ArrayList<>();
>    List<Integer> temp = new ArrayList<>();
>
>    public List<List<Integer>> combine(int n, int k) {
>        backtrack(n, 1, k);
>        return res;
>    }
>
>    public void backtrack(int n, int start, int k) {
>        if (k == temp.size()) {
>            res.add(new ArrayList<>(temp));
>        }
>        for (int i = start; i <= n; i++) {
>            temp.add(i);
>            backtrack(n, i + 1, k);
>            temp.remove(temp.size() - 1);
>        }
>    }
>```
>
>

### 39组合总和

>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。
>
>输入：candidates = [2,3,6,7], target = 7
>输出：[[2,2,3],[7]]
>解释：
>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
>7 也是一个候选， 7 = 7 。
>仅有这两种组合。
>
>```java
>public class Solution {
>    List<List<Integer>> result = new ArrayList<>();
>	List<Integer> tempList=new ArrayList<>();
>    public List<List<Integer>> combinationSum(int[] candidates, int target) {
>        Arrays.sort(candidates);
>        backtrack(candidates, target, 0);
>        return result;
>    }
>
>    public void backtrack(int[] nums, int remain, int start) {
>        if (remain < 0) {
>            return;
>        }
>        if (remain == 0) {
>            result.add(new ArrayList<>(tempList));
>        }
>        for (int i = start; i < nums.length; i++) {
>            tempList.add(nums[i]);
>            //下一次还是从当前位置搜，这里注意的是传start的原因是避免从开头重新搜重复，目标是remain - nums[i]
>            backtrack(nums, remain - nums[i], i);
>            tempList.remove(tempList.size() - 1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        int[] test = {2, 3, 6, 7};
>        List<List<Integer>> l = s.combinationSum(test, 7);
>        System.out.print(l);
>    }
>}
>```
>
>

### 40组合总和II

>给定一个候选编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用 一次 。
>
>输入: candidates = [10,1,2,7,6,1,5], target = 8,
>输出:
>[
>[1,1,6],
>[1,2,5],
>[1,7],
>[2,6]
>]
>
>```java
>public class Solution {
>    List<List<Integer>> result = new ArrayList<>();
>    List<Integer> tempList = new ArrayList<>();
>
>    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
>        Arrays.sort(candidates);
>        backtrack(candidates, target, 0);
>        return result;
>    }
>
>    public void backtrack(int[] nums, int remain, int start) {
>        if (remain < 0) {
>            return;
>        }
>        if (remain == 0) {
>            result.add(new ArrayList<>(tempList));
>        }
>        for (int i = start; i < nums.length; i++) {
>            //对同层的数据去重而不是对同一分支上的数据去重
>            if (i > start && nums[i] == nums[i - 1]) {
>				continue;
>			}
>            tempList.add(nums[i]);
>            //下一次是从下一个位置搜，目标是remain - nums[i]
>            backtrack(nums, remain - nums[i], i + 1);
>            tempList.remove(tempList.size() - 1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        int[] test = {10, 1, 2, 7, 6, 1, 5};
>        List<List<Integer>> l = s.combinationSum2(test, 8);
>        System.out.print(l);
>    }
>}
>```
>
>

### 216组合总和III

>只使用数字1到9,每个数字最多使用一次,取k个数组成和为n
>
>```java
>public class Solution {
>    List<List<Integer>> res = new ArrayList<>();
>    List<Integer> temp = new ArrayList<>();
>
>    public List<List<Integer>> combinationSum3(int k, int n) {
>        backtrack(1,  n, k);
>        return res;
>    }
>
>    public void backtrack(int start, int target, int k) {
>        if (target < 0 || (temp.size() == k && target != 0)) {
>            return;
>        }
>        if (temp.size() == k) {
>            res.add(new ArrayList<>(temp));
>            return;
>        }
>        for (int i = start; i <= 9; i++) {
>            temp.add(i);
>            backtrack(i + 1, target - i, k);
>            temp.remove(temp.size() - 1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        System.out.print(s.combinationSum3(3, 9));
>    }
>}
>```
>
>

### 78子集

>输入：nums = [1,2,3]
>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
>
>```java
>public class Solution {
>    List<List<Integer>> result = new ArrayList<>();
>    List<Integer> tempList = new ArrayList<>();
>
>    public List<List<Integer>> subsets(int[] nums) {
>        backtrack(nums, 0);
>        return result;
>    }
>
>    public void backtrack(int nums[], int start) {
>        result.add(new ArrayList<>(tempList));
>        for (int i = start; i < nums.length; i++) {
>            tempList.add(nums[i]);
>            //从下一个位置搜
>            backtrack(nums, i + 1);
>            tempList.remove(tempList.size() - 1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        System.out.print(s.subsets(new int[]{1, 2, 3}));
>    }
>}
>```
>
>

### 90子集II

>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
>
>输入：nums = [1,2,2]
>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
>示例 2：
>
>```java
>public class Solution {
>    List<List<Integer>> res = new ArrayList<>();
>    List<Integer> tempList = new ArrayList<Integer>();
>
>    public List<List<Integer>> subsetsWithDup(int[] nums) {
>        Arrays.sort(nums);
>        backtrack(nums, 0);
>        return res;
>    }
>
>    public void backtrack(int[] nums, int start) {
>        res.add(new ArrayList<>(tempList));
>        for (int i = start; i < nums.length; i++) {
>            if (i > start && nums[i] == nums[i - 1]) {
>                continue;
>            }
>            tempList.add(nums[i]);
>            //从下一个位置搜
>            backtrack(nums, i + 1);
>            tempList.remove(tempList.size() - 1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        int[] test = {1, 2, 2};
>        System.out.print(s.subsetsWithDup(test));
>    }
>}
>```
>
>

### 46全排列

>输入：nums = [1,2,3]
>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
>
>```java
>public class Solution {
>    List<List<Integer>> result = new ArrayList<>();
>    List<Integer> tempList = new ArrayList<>();
>
>    public List<List<Integer>> permute(int[] nums) {
>        boolean[] used = new boolean[nums.length];
>        backtrack(nums, used);
>        return result;
>    }
>
>    public void backtrack(int[] nums, boolean[] used) {
>        if (tempList.size() == nums.length) {
>            result.add(new ArrayList<>(tempList));
>            return;
>        }
>        for (int i = 0; i < nums.length; i++) {
>            if (used[i]) {
>                continue;
>            }
>            used[i] = true;
>            tempList.add(nums[i]);
>            backtrack(nums, used);
>            used[i] = false;
>            tempList.remove(tempList.size() - 1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        int[] test = {1, 2, 3};
>        System.out.print(s.permute(test));
>    }
>}
>```
>
>

### 47全排列II

>输入：nums = [1,1,2]
>输出：
>[[1,1,2],
> [1,2,1],
> [2,1,1]]
>
>```java
>public class Solution {
>    List<List<Integer>> result = new ArrayList<>();
>    List<Integer> tempList = new ArrayList<>();
>
>    public List<List<Integer>> permuteUnique(int[] nums) {
>        //注意这里要排序
>        Arrays.sort(nums);
>        backtrack(nums, new boolean[nums.length]);
>        return result;
>    }
>
>    public void backtrack(int[] nums, boolean[] used) {
>        if (tempList.size() == nums.length) {
>            result.add(new ArrayList<>(tempList));
>            return;
>        }
>        for (int i = 0; i < nums.length; i++) {
>            //1.想同数刚刚被使用 2.相同数刚刚被撤销
>            // 要么这个数字被用过了，要么与前一个相等而且前一个也没被用过
>            if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) {
>                continue;
>            }
>            used[i] = true;
>            tempList.add(nums[i]);
>            backtrack(nums, used);
>            used[i] = false;
>            tempList.remove(tempList.size() - 1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        int[] test = {1, 2, 1};
>        System.out.print(s.permuteUnique(test));
>    }
>}
>
>```
>
>

### 17电话号码的字母组合

>给出数字到字母的映射如下（与电话按键相同）, 1 不对应任何字母。
>
>输入：digits = "23"
>输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
>
>```java
>//采用一个队列，每次循环时将队列中长度等于当前长度的字符串拿出来然后拼接上新的字符串的每一个字符塞到队尾
>//比如队列里边现在已经有了a,b,c然后新来了一个数字3，那就把队列里的都拼上3中的每一个字母塞回队列末尾
>class Solution {
>        public List<String> letterCombinations(String digits) {
>            LinkedList<String> res = new LinkedList<String>();
>            if (digits.isEmpty()) return res;
>            String[] map = {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
>            res.add("");
>            for (int i = 0; i < digits.length(); i++) {
>                int x = Character.getNumericValue(digits.charAt(i));
>                while (res.peek().length() == i) {
>                    String str = res.poll();
>                    for (char c : map[x].toCharArray())
>                        res.add(str + c);
>                }
>            }
>            return res;
>        }
>    }
>```
>
>```java
>//这里的数是字母组成的数，数宽是第一个字母的宽度，数深是digits的长度，而不是数字组成的
>public class Solution2 {
>    public List<String> res = new ArrayList<>();
>    public StringBuilder temp = new StringBuilder();
>    String[] map = {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
>
>    public List<String> letterCombinations(String digits) {
>        if(digits==null || digits.length()==0){
>            return res;
>        }
>        backtrack(digits, 0);
>        return res;
>    }
>
>    public void backtrack(String digits, int index) {
>        if (temp.toString().length() == digits.length()) {
>            res.add(temp.toString());
>            return;
>        }
>        String str = map[digits.charAt(index) - '0'];
>        for (int i = 0; i < str.length(); i++) {
>            temp.append(str.charAt(i));
>            backtrack(digits, index + 1);
>            temp.deleteCharAt(temp.length() - 1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution2 solution = new Solution2();
>        System.out.println(solution.letterCombinations(""));
>    }
>}
>```
>
>

### 131分割回文串

>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
>
>示例 1：
>
>输入：s = "aab"
>输出：[["a","a","b"],["aa","b"]]
>示例 2：
>
>输入：s = "a"
>输出：[["a"]]
>
>```java
>public class Solution {
>    public List<List<String>> res = new ArrayList<>();
>    public List<String> temp = new ArrayList<>();
>
>    public List<List<String>> partition(String s) {
>        backtrack(0, s);
>        return res;
>    }
>
>    public void backtrack(int start, String s) {
>        //当切割线切到了最后面，就说明找到了一种解法,start用以标记切割的位置
>        if (start == s.length()) {
>            res.add(new ArrayList<>(temp));
>            return;
>        }
>        //从后边接续切
>        for (int i = start; i < s.length(); i++) {
>            if (isPalindrome(s, start, i)) {
>                temp.add(s.substring(start, i + 1));
>                backtrack(i+1, s);
>                temp.remove(temp.size() - 1);
>            }
>        }
>    }
>
>    private boolean isPalindrome(String s, int startIndex, int end) {
>        for (int i = startIndex, j = end; i < j; i++, j--) {
>            if (s.charAt(i) != s.charAt(j)) {
>                return false;
>            }
>        }
>        return true;
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        System.out.println(s.partition("aab"));
>    }
>}
>```
>
>

### 93恢复IP地址

>示例 1：
>
>输入：s = "25525511135"
>输出：["255.255.11.135","255.255.111.35"]
>示例 2：
>
>输入：s = "0000"
>输出：["0.0.0.0"]
>示例 3：
>
>输入：s = "101023"
>输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
>
>```java
>public class Solution {
>    List<String> res = new ArrayList<>();
>    StringBuilder temp = new StringBuilder();
>
>    public List<String> restoreIpAddresses(String s) {
>        if (s.length() < 4 || s.length() > 12) {
>            return res;
>        }
>        backtrack(s, 0, 0);
>        return res;
>    }
>
>    //s一直透传,start是从下一个位置开始搜,pointNum是增加的点数
>    public void backtrack(String s, int start, int pointNum) {
>        //点数量为4时，分隔结束
>        if (pointNum == 4 && start == s.length()) {
>            res.add(temp.substring(0, temp.length() - 1));
>            return;
>        }
>        //点数已经到4了或者字符串已经到结尾了但是还不符合条件的结束
>        if (start == s.length() || pointNum == 4) {
>            return;
>        }
>        //向后最多截取3位
>        for (int i = start; i < start + 3 && i < s.length(); i++) {
>            String substr = s.substring(start, i + 1);
>            if (isValid(substr)) {
>                temp.append(substr).append(".");
>                backtrack(s, i + 1, pointNum + 1);
>                temp.delete(temp.length() - substr.length() - 1, temp.length());
>            }
>        }
>    }
>
>    /*判断是不是合格的点分数*/
>    public boolean isValid(String s) {
>        if (s.charAt(0) == '0') {
>            return s.equals("0");
>        }
>        int num = Integer.parseInt(s);
>        return num <= 255 && num > 0;
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        String str = "25525511135";
>        System.out.print(s.restoreIpAddresses(str));
>    }
>}
>```
>
>

### 491递增子序列

>给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
>
>**示例 1：**
>
>```
>输入：nums = [4,6,7,7]
>输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
>```
>
>**示例 2：**
>
>```
>输入：nums = [4,4,3,2,1]
>输出：[[4,4]]
>```
>
>```java
>class Solution {
>    List<Integer> temp = new ArrayList<>();
>    List<List<Integer>> res = new ArrayList<>();
>
>    public List<List<Integer>> findSubsequences(int[] nums) {
>        backtrack(0, nums);
>        return res;
>    }
>
>    public void backtrack(int start, int[] nums) {
>        if (temp.size() > 1) {
>            res.add(new ArrayList<>(temp));
>        }
>        Set<Integer> brother = new HashSet<>();
>        for (int i = start; i < nums.length; i++) {
>            // 剪枝
>            // 如果上一个加入子集的数比当前准备加入的数大，则接着尝试下一个数看能否找到比上一个数更大的数加入子集
>            if (!temp.isEmpty() && temp.get(temp.size()-1) > nums[i]) {
>                continue;
>            }
>            // 去重：如果父节点下面有2个一样的可能性则跳过后面的重复的子节点选择
>            if (brother.contains(nums[i])) {
>                continue;
>            }
>            temp.add(nums[i]);
>            brother.add(nums[i]);
>            backtrack(i+1,nums);
>            temp.remove(temp.size()-1);
>        }
>    }
>
>    public static void main(String[] args) {
>        Solution solution = new Solution();
>        System.out.println(solution.findSubsequences(new int[]{4, 6, 7, 7}));
>    }
>}
>```
>
>

### 22括号生成

>输入：n = 3
>输出：["((()))","(()())","(())()","()(())","()()()"]
>
>```java
>class Solution {
>    public List<String> generateParenthesis(int n) {
>		List<String> list=new ArrayList<String>();
>		backtrack(list,"",0,0,n);
>		return list;      
>    }
>  
>  //通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，如果左括号数量不大于 nn，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。
>	public void backtrack(List<String> list,String str,int begin,int end,int max){
>		if(str.length()==2*max){
>			 list.add(str);
>			 return;
>		}
>		if(begin<max)//此处不需要回退状态是因为str还是原来的str
>			 backtrack(list, str+"(", begin+1, end, max);
>		if(end<begin)
>			 backtrack(list, str+")", begin, end+1, max);
>	}
>}
>```
>
>

### 301删除无效的括号

>给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。返回所有可能的结果。答案可以按 任意顺序 返回。
>
>示例 1：
>
>输入：s = "()())()"
>输出：["(())()","()()()"]
>示例 2：
>
>输入：s = "(a)())()"
>输出：["(a())()","(a)()()"]
>示例 3：
>
>```java
>public class Solution {
>    List<String> res = new ArrayList<>();
>
>    public List<String> removeInvalidParentheses(String s) {
>        // 计算出要移除的左右括号数
>        int lr = 0;
>        int rr = 0;
>        for (int i = 0; i < s.length(); i++) {
>            if (s.charAt(i) == '(') {
>                lr++;
>            }
>            if (s.charAt(i) == ')') {
>                if (lr > 0) {
>                    lr--;
>                } else {
>                    rr++;
>                }
>            }
>        }
>        backTrack(0, lr, rr, s);
>        return res;
>    }
>
>    // 回溯，移除括号
>    void backTrack(int start, int lr, int rr, String s) {
>        // 完成条件
>        if (lr == 0 && rr == 0 && isValid(s)) {
>            res.add(s);
>        }
>        for (int i = start; i < s.length(); i++) {
>            if (i > start && s.charAt(i) == s.charAt(i - 1)) {
>                continue;
>            }
>            if (s.charAt(i) == '(' && lr > 0) {
>                backTrack(i, lr - 1, rr, s.substring(0, i) + s.substring(i + 1));
>            }
>            if (s.charAt(i) == ')' && rr > 0) {
>                backTrack(i, lr, rr - 1, s.substring(0, i) + s.substring(i + 1));
>            }
>        }
>    }
>
>    // 判定是否有效
>    boolean isValid(String s) {
>        Deque<Character> stack = new LinkedList<>();
>        for (int i = 0; i < s.length(); i++) {
>            if (!stack.isEmpty() && s.charAt(i) == ')' && stack.peek() == '(') {
>                stack.pop();
>                continue;
>            }
>            if (s.charAt(i) != '(' && s.charAt(i) != ')') {
>                continue;
>            }
>            stack.push(s.charAt(i));
>        }
>        return stack.isEmpty();
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        System.out.print(s.removeInvalidParentheses("()())()"));
>    }
>}
>```
>
>

### 79单词搜索

>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
>输入：board = [
>							["A","B","C","E"],
>							["S","F","C","S"],
>							["A","D","E","E"]
>], word = "ABCCED"
>输出：true
>
>```java
>public class Solution {
>public boolean exist(char[][] board, String word) {
>   char[] w = word.toCharArray();
>   boolean[][] visited = new boolean[board.length][board[0].length];
>   for (int i = 0; i < board.length; i++) {
>       for (int j = 0; j < board[i].length; j++) {
>           if (exist(board, i, j, 0, w, visited)) {
>               return true;
>           }
>       }
>   }
>   return false;
>}
>
>  //i用来标记搜到了单词的第i个位置
>public boolean exist(char[][] board, int x, int y, int i, char[] word, boolean[][] visited) {
>  //不合法的除掉
>   if (x < 0 || y < 0 || x == board.length || y == board[x].length) {
>       return false;
>   }
>  //xy未知的字母不等于单词的第i个字母除掉
>   if (board[x][y] != word[i]) {
>       return false;
>   }
>  //长度等于单词长度时找到了返回，顺带给i加一个计数
>   if ((i += 1) == word.length) {
>       return true;
>   }
>   boolean res = false;
>   visited[x][y] = true;
>  //向左找
>   if (x > 0 && !visited[x - 1][y]) {
>       res = res || exist(board, x - 1, y, i, word, visited);
>   }
>  //向右找
>   if (x + 1 < visited.length && !visited[x + 1][y]) {
>       res = res || exist(board, x + 1, y, i, word, visited);
>   }
>  //向上找
>   if (y > 0 && !visited[x][y - 1]) {
>       res = res || exist(board, x, y - 1, i, word, visited);
>   }
>  //向下找
>   if (y + 1 < visited[x].length && !visited[x][y + 1]) {
>       res = res || exist(board, x, y + 1, i, word, visited);
>   }
>  //四个方向都没找到
>   if (!res) {
>       visited[x][y] = false;
>   }
>   return res;
>}
>
>public static void main(String[] args) {
>   char[][] board = {
>           {'A', 'B', 'C', 'E'},
>           {'S', 'F', 'C', 'S'},
>           {'A', 'D', 'E', 'E'}
>   };
>   String[] strs = {"ABCCED", "A", "ABCB"};
>   Solution s = new Solution();
>   for (String str : strs) {
>       System.out.println(s.exist(board, str));
>   }
>}
>}
>```
>
>

### 51N皇后

>让棋盘上的横竖斜线都不攻击
>
>```java
>public class Solution {
>    List<List<String>> res = new ArrayList<>();
>
>    public List<List<String>> solveNQueens(int n) {
>        char[][] chessboard = new char[n][n];
>        for (char[] c : chessboard) {
>            Arrays.fill(c, '.');
>        }
>        backTrack(n, 0, chessboard);
>        return res;
>    }
>
>    public void backTrack(int n, int row, char[][] chessboard) {
>        if (row == n) {
>            res.add(Array2List(chessboard));
>            return;
>        }
>
>        for (int col = 0;col < n; ++col) {
>            if (isValid (row, col, n, chessboard)) {
>                chessboard[row][col] = 'Q';
>                backTrack(n, row+1, chessboard);
>                chessboard[row][col] = '.';
>            }
>        }
>    }
>
>    public List Array2List(char[][] chessboard) {
>        List<String> list = new ArrayList<>();
>        for (char[] c : chessboard) {
>            list.add(String.copyValueOf(c));
>        }
>        return list;
>    }
>
>    //检查棋盘是否合理，给出行、列、
>    public boolean isValid(int row, int col, int n, char[][] chessboard) {
>        // 放置一个以后，对之前的每一行的这一列做检查
>        for (int i=0; i<row; i++) {
>            if (chessboard[i][col] == 'Q') {
>                return false;
>            }
>        }
>
>        // 检查45度对角线，往左上角检查
>        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
>            if (chessboard[i][j] == 'Q') {
>                return false;
>            }
>        }
>
>        // 检查135度对角线，往右上角检查
>        for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
>            if (chessboard[i][j] == 'Q') {
>                return false;
>            }
>        }
>        return true;
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        System.out.println(s.solveNQueens(4));
>    }
>}
>```
>
>

### 37解数独

>行列九宫格都不重复
>
>```java
>public class Solution {
>    public void solveSudoku(char[][] board) {
>        solveSudokuHelper(board);
>    }
>
>    private boolean solveSudokuHelper(char[][] board){
>        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
>        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
>        for (int i = 0; i < 9; i++){ // 遍历行
>            for (int j = 0; j < 9; j++){ // 遍历列
>                if (board[i][j] != '.'){ // 跳过原始数字
>                    continue;
>                }
>                for (char k = '1'; k <= '9'; k++){ // (i, j) 这个位置放k是否合适
>                    if (isValidSudoku(i, j, k, board)){
>                        board[i][j] = k;
>                        if (solveSudokuHelper(board)){ // 如果找到合适一组立刻返回
>                            return true;
>                        }
>                        board[i][j] = '.';
>                    }
>                }
>                // 9个数都试完了，都不行，那么就返回false
>                return false;
>                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
>                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
>            }
>        }
>        // 遍历完没有返回false，说明找到了合适棋盘位置了
>        return true;
>    }
>
>    //在row行col列填入val值是否合理
>    private boolean isValidSudoku(int row, int col, char val, char[][] board){
>        // 同行是否重复
>        for (int i = 0; i < 9; i++){
>            if (board[row][i] == val){
>                return false;
>            }
>        }
>        // 同列是否重复
>        for (int j = 0; j < 9; j++){
>            if (board[j][col] == val){
>                return false;
>            }
>        }
>        // 9宫格里是否重复
>        int startRow = (row / 3) * 3;
>        int startCol = (col / 3) * 3;
>        for (int i = startRow; i < startRow + 3; i++){
>            for (int j = startCol; j < startCol + 3; j++){
>                if (board[i][j] == val){
>                    return false;
>                }
>            }
>        }
>        return true;
>    }
>
>    public static void main(String[] args) {
>        Solution s = new Solution();
>        char[][] board={
>                {'5','3','.','.','7','.','.','.','.'},
>                {'6','.','.','1','9','5','.','.','.'},
>                {'.','9','8','.','.','.','.','6','.'},
>                {'8','.','.','.','6','.','.','.','3'},
>                {'4','.','.','8','.','3','.','.','1'},
>                {'7','.','.','.','2','.','.','.','6'},
>                {'.','6','.','.','.','.','2','8','.'},
>                {'.','.','.','4','1','9','.','.','5'},
>                {'.','.','.','.','8','.','.','7','9'}
>        };
>        s.solveSudoku(board);
>        for (char[] bb : board) {
>            for (char b : bb) {
>                System.out.print(b);
>            }
>            System.out.println();
>        }
>    }
>}
>```
>
>

# 动态规划

## 斐波那契数列

### 爬楼梯

- 普通爬楼梯

>爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶
>
>```java
>f[i]=f[i-1]+f[i-2];//本质斐波那契
>```

- 最小花费爬楼梯

>一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
>
>```java
>class Solution {
>    public int minCostClimbingStairs(int[] cost) {
>        if(cost.length==1)  return cost[0];
>        if(cost.length==2)	return Math.min(cost[0], cost[1]);
>        int[] dp=new int[cost.length];
>        dp[0]=cost[0];
>        dp[1]=cost[1];
>        for(int i=2;i<cost.length;i++)
>        	dp[i]=Math.min(dp[i-2]+cost[i], dp[i-1]+cost[i]);
>        return Math.min(dp[cost.length-1],dp[cost.length-2]);
>    }
>}
>```
>
>

- 变态爬楼梯

>- 0-12共13个数构成一个环，从0出发，每次走1步，走n步回到0共有多少种走法
>
>青蛙跳台阶的变种问题
>
>```java
>/**
> * dp[i][j]表示从0走i步到j，要走4步到0，先算走3步到1或者走3步到9
> * */
>public class testdama {
>    public static void main(String[] args) {
>        int circleLength = 10;
>        int step = 4;
>        int[][] dp=new int[step + 1][circleLength];
>        dp[0][0] = 1;
>        for(int i = 1; i <= step; i++){
>            for(int j = 0; j < circleLength; j++){
>                dp[i][j] = dp[i - 1][(j + 1) % circleLength] + dp[i - 1][(j - 1 + circleLength) % circleLength];
>            }
>        }
>        for(int i = 0; i <= step; i++){
>            for(int j = 0; j < circleLength; j++){
>                System.out.print(dp[i][j]+" ");
>            }
>            System.out.println();
>        }
>        System.out.println(dp[step][0]);
>    }
>}
>```
>
>

### 强盗抢劫

- 打家劫舍

>```java
>dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);
>```

- 打家劫舍II

>环形打劫
>
>```java
>算[0...n-2]与[1...n-1]的打劫情况
>```
>
>

- 打家劫舍III

>二叉树打劫
>
>```java
>class Solution {
>    public int rob(TreeNode root) {
>        int[] result = robInternal(root);
>        return Math.max(result[0], result[1]);
>    }
>
>    public int[] robInternal(TreeNode root) {
>        if (root == null) return new int[2];
>        int[] result = new int[2];
>
>        int[] left = robInternal(root.left);
>        int[] right = robInternal(root.right);
>        //0代表不偷当前节点，1代表偷当前节点
>        //不偷当前节点,左孩子能偷到的钱 + 右孩子能偷到的钱
>        result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
>        //偷当前节点,左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数
>        result[1] = left[0] + right[0] + root.val;
>
>        return result;
>    }
>}
>```
>
>

### 信件错排

>有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量
>
>**思路**：要么前面i-1个都错了，那就随便换一下当前的，有i-1种换法，要么前面只有一封错了，那就只能跟那一封换也有i-1种换法，dp[i]代表i=封信全部错排的方法数
>
>```java
>dp[i]=(i-1)(dp[i-1]+dp[i-2])
>```
>
>

### 母牛生产

>母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。
>
>**思路**：这跟兔子生产一样，斐波那契数列最初就是研究兔子生产关系的
>
>```java
>dp[i]=dp[i-1]+dp[i-3]
>```
>
>

## 路径

### 矩阵最小路径和

>从矩阵左上角走到矩阵右下角的最短路径和
>
>`dp[i][j]=dp[i-1][j]+dp[i][j-1]`

### 矩阵总路径数

>统计从矩阵左上角到右下角的路径总数
>
>`dp[i][j]=dp[i-1][j]+dp[i][j-1]`

### 矩阵总路径数II

>有障碍物
>
>```java
>class Solution {
>    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
>        int row = obstacleGrid.length;
>        int col = obstacleGrid[0].length;
>        int dp[] = new int[col];//压缩状态
>        int index=0;
>        for(int i=0;i<col;i++){//给首行赋值
>            if(obstacleGrid[0][i]==0){
>                dp[i]=1;
>            }else{
>                for(int j=i;j<col;j++){//遇到障碍物时要将障碍物后边的都赋值为0
>                    dp[j]=0;
>                }
>                break;
>            }
>        }
>        
>        for (int i = 0; i < row; i++) {
>            for (int j = 0; j < col; j++) {
>                if (obstacleGrid[i][j] == 1) {
>                    dp[j] = 0;
>                } else if (i - 1 >= 0 && j - 1 >= 0) {
>                    dp[j] = dp[j] + dp[j - 1];
>                }
>            }
>        }
>        return dp[col - 1];
>    }
>}
>```
>
>

### 最小三角路径和

>通路是一个三角形
>
>```java
>public int minimumTotal(List<List<Integer>> triangle) {
>            for(int i=1;i< triangle.size();i++){
>            for(int j=0;j<triangle.get(i).size();j++){
>                if(j==0){
>                    triangle.get(i).set(j, triangle.get(i-1).get(j)+triangle.get(i).get(j));
>                }
>                else if(j==triangle.get(i).size()-1){
>                    triangle.get(i).set(j, triangle.get(i-1).get(j-1)+triangle.get(i).get(j));
>                }else{
>                    triangle.get(i).set(j, Math.min(triangle.get(i-1).get(j-1),triangle.get(i-1).get(j))+triangle.get(i).get(j));
>                }
>            }
>        }
>        return triangle.get(triangle.size()-1).stream().min(Comparator.comparingInt(o -> o)).get();
>    }
>//自下而上加会简单一些
>```
>
>

## 数组区间

### 数组区间和

>求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]

### 数组中等差递增子区间的个数

>```java
>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。
>
>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。
>```
>
>```java
>public int numberOfArithmeticSlices(int[] A) {
>    if (A == null || A.length == 0) {
>        return 0;
>    }
>    int n = A.length;
>    int[] dp = new int[n];
>    for (int i = 2; i < n; i++) {
>        if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
>           //dp[i - 1]以i-1结尾能构成子区间的都能以i结尾构成子区间，
>           //加的1表示A[i-2], A[i-1], A[i]这个以前不是的现在也是了
>            dp[i] = dp[i - 1] + 1;
>        }
>    }
>    int total = 0;
>    for (int cnt : dp) {
>        total += cnt;
>    }
>    return total;
>}
>```
>
>

## 分割整数

### 整数拆分

>**输入**: n = 10
>**输出**: 36
>**解释**: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
>
>```java
>class Solution {
>    public int integerBreak(int n) {
>        int[] dp=new int[n+1];
>        dp[1]=1;
>        for(int i=2;i<=n;i++)
>          for(int j=1;j<=i-1;j++){//注意至少要拆成2个数，那就是每个数都在1~i-1之间
>            //看看是之前形成的分割更大还是新形成的分割更大
>            //新形成的分割看看是j*(i-j), j*dp[i-j]哪个更大
>            //比如分割10的时候，刚刚算完了j=6为分割点的最大值，现在到7为分割点了，看是7*3大还是7*dp[3]大还是之前已经算好的最大分割大
>            dp[i]=Math.max(dp[i],Math.max(j*(i-j), j*dp[i-j]));
>          }
>        return dp[n];
>    }
>}
>```
>
>

### 按照平方数分割整数

>输入：n = 12
>输出：3 
>解释：12 = 4 + 4 + 4
>
>```java
>class Solution {
>    public int numSquares(int n) {
>        int[] dp = new int[n + 1];
>        for (int i = 1; i <= n; i++) {//对于1-n的每一个数都算出组成它的最小平方分割数
>            dp[i] = i;//最差情况下都切为1
>            for (int j = 1; j * j <= i; j++) {
>                //对于1到j*j小于i的j，切为一个值的平方与i - j * j的最小切割,加的1是可以用切为的那个平方
>                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
>            }
>        }
>        return dp[n];
>    }
>}
>//比如对于10来说，是切为1，dp[9]或者4，dp[6]或者9，dp[1]
>```
>
>

### 分割整数构成字符串（解码）

>输入：s = "226"
>输出：3
>解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6)
>
>```java
>public int numDecodings(String s) {
>    if (s == null || s.length() == 0) {
>        return 0;
>    }
>    int n = s.length();
>    int[] dp = new int[n + 1];//表示截止到某一位的解码方法数
>    dp[0] = 1;
>    dp[1] = s.charAt(0) == '0' ? 0 : 1;//第一个如果是0的话不能解码
>    for (int i = 2; i <= n; i++) {
>        int one = Integer.valueOf(s.substring(i - 1, i));//切出当前位
>        if (one != 0) {
>            dp[i] += dp[i - 1];
>        }
>        if (s.charAt(i - 2) == '0') {
>            continue;
>        }
>        int two = Integer.valueOf(s.substring(i - 2, i));//切出当前位加上当前位的前一位
>        if (two <= 26) {
>            dp[i] += dp[i - 2];
>        }
>    }
>    return dp[n];
>}
>```
>
>

## 子序列与子串

>子序列不连续，子串连续

### 最长递增子序列的长度

>输入：nums = [10,9,2,5,3,7,101,18]
>输出：4
>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
>
>```java
>class Solution {
>    public int lengthOfLIS(int[] nums) {
>        if(nums.length<1)
>            return -1;
>        int[] dp=new int[nums.length];
>        int max=1;
>        for(int i=0;i<nums.length;i++){
>            for(int j=0;j<i;j++){
>                if(nums[j]<nums[i]){
>                    dp[i]=Math.max(dp[i],dp[j]+1);
>                }
>            }
>            if(dp[i]==0){
>                dp[i]=1;//就算递减序列最短长度也是1
>            }
>            max=Math.max(dp[i],max);
>        }
>        return max;
>    }
>}
>```
>
>

### 最长递增子序列的个数

>输入: [1,3,5,4,7]
>输出: 2
>解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
>
>```java
>public class Solution {
>    public static void main(String[] args) {
>        int[] nums=new int[]{1,3,5,4,7};
>        int[] dp=new int[nums.length];//到当前值的上升子序列的最长长度
>        int[] cnt=new int[nums.length];//到当前值的上升子序列的个数
>        for(int i=0;i<nums.length;i++){
>            dp[i]=1;
>            cnt[i]=1;
>            for(int j=0;j<i;j++){
>                if(nums[j]<nums[i]){
>                    if(dp[j]+1>dp[i]){
>                        //如果这里成立，表示加入第j个数成为了一个新的上升序列，此时应当刷新所有关于i的信息
>                        dp[i]=dp[j]+1;
>                        cnt[i]=cnt[j];
>                    }else if(dp[j]+1==dp[i]){
>                        //如果这里成立，表示到第i个数组成的上升序列加上第j个数是一个新的上升序列，比如之前有三个3，这有一个4，那所有的3的个数都满足条件
>                        cnt[i]+=cnt[j];
>                    }
>                }
>            }
>        }
>        int maxLen=0;
>        int res=0;
>        //找到那个最长的序列，然后把他们的达到数加起来
>        for(int i=0;i<dp.length;i++){
>            if(dp[i]>maxLen){
>                maxLen=dp[i];//找到最长的
>                res=cnt[i];//同时用这个最长值对应的计数值刷新这个结果
>            }else if(dp[i]==maxLen){
>                res+=cnt[i];//如果当前值等于最长值，就加上它的计数
>            }
>        }
>
>        for(int i=0;i<dp.length;i++){
>            System.out.print(dp[i]+" ");
>        }
>        System.out.println();
>        for(int i=0;i<dp.length;i++){
>            System.out.print(cnt[i]+" ");
>        }
>        System.out.println();
>
>        System.out.println(res);
>    }
>}
>```
>
>

### 最长摆动子序列

>**输入**: [1,17,5,10,13,15,10,5,16,8]
>**输出**: 7
>**解释**： [1,17,10,13,10,16,8].
>
>```java
>public int wiggleMaxLength(int[] nums) {
>if (nums == null || nums.length == 0) {
>   return 0;
>}
>int up = 1, down = 1;
>//up表示以当前数字结尾而且当前数字是波峰时的长度
>//down表示以当前数字结尾而且当前数字是波谷时的长度
>for (int i = 1; i < nums.length; i++) {
>   if (nums[i] > nums[i - 1]) {
>       up = down + 1;//比如这是一个递增序列，up一直保持在2，up增长需要依赖于down增长
>   } else if (nums[i] < nums[i - 1]) {
>       down = up + 1;//递减同理
>   }
>}
>return Math.max(up, down);
>}
>```
>
>

### 最长公共子序列

>**输入**：text1 = "abcde", text2 = "ace" 
>**输出**：3  
>**解释**：最长公共子序列是 "ace" ，它的长度为 3 。
>
>```java
>/**
>dp[i][j]标识从text1的0~i-1，从text2的0~j-1的最长公共子序列的长度
>**/
>public static void main(String[] args) {
>        String text1 = "bsbininm";
>        String text2 = "jmjkbkjkv";
>        int dp[][] = new int[text1.length() + 1][text2.length() + 1];
>        for (int i = 1; i <= text1.length(); i++) {
>            for (int j = 1; j <= text2.length(); j++) {
>                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
>                    dp[i][j] = dp[i - 1][j - 1] + 1;
>                } else {
>                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
>                }
>            }
>        }
>        for (int i = 0; i <= text1.length(); i++) {
>            for (int j = 0; j <= text2.length(); j++) {
>                System.out.print(dp[i][j] + " ");
>            }
>            System.out.println();
>        }
>        System.out.println(dp[text1.length()][text2.length()]);
>    }
>```
>
>

### 最长公共子串

>给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。
>
>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
>输出：3
>解释：长度最长的公共子数组是 [3,2,1] 。
>
>```java
>public static void main(String[] args) {
>   int[] nums1 = new int[]{1, 2, 3, 2, 1};
>   int[] nums2 = new int[]{3, 2, 1, 4, 7};
>   int dp[][] = new int[nums1.length + 1][nums2.length + 1];
>   int max=0;
>   for (int i = 1; i <= nums1.length; i++) {
>       for (int j = 1; j <= nums2.length; j++) {
>           if (nums1[i - 1] == nums2[j - 1]) {
>               dp[i][j] = dp[i - 1][j - 1] + 1;
>               max=Math.max(max, dp[i][j]);
>           } else {
>               dp[i][j] = 0;
>           }
>       }
>   }
>   for (int i = 1; i <= nums1.length; i++) {
>       for (int j = 1; j <= nums2.length; j++) {
>           System.out.print(dp[i][j] + " ");
>       }
>       System.out.println();
>   }
>   System.out.println(max);
>}
>```
>
>

### 最长回文子串

>给你一个字符串 `s`，找到 `s`中最长的回文子串
>**输入**：s = "babad"
>**输出**："bab"
>**思路**：`dp[i][j]`表示从i到j的子串是否是一个回文，计算时从下到上，从左到右而且只算上半部分三角，那是因为计算[1..4]是需要依赖于[2..3]，即右上角的值依赖于左下角的值
>
>```java
>public class solution {
>public static void main(String[] args) {
>   String str="babad";
>   int strLength=str.length();
>   if(strLength<2){
>       System.out.println(str);
>   }
>   int maxLen=1;
>   int begin=0;
>   boolean[][] dp=new boolean[strLength][strLength];
>   for(int i=strLength-1;i>=0;i--){
>       for(int j=i;j<strLength;j++){
>           if(i==j){
>               //单个字母一定是回文字符串
>               dp[i][j]=true;
>           }else {
>//字母i与字母j一样，长度小于2时一定是回文，长度不小于2那就追溯退掉这俩字母的中间串;核心逻辑
>               dp[i][j] = (str.charAt(i) == str.charAt(j)) && (j - i + 1 <= 2 || dp[i + 1][j - 1]);
>           }
>           if (dp[i][j] && j - i + 1 > maxLen) {
>               maxLen = j - i + 1;//标记最长
>               begin = i;//标记开始位置
>           }
>       }
>   }
>   for(int i=0;i<strLength;i++){
>       for(int j=0;j<strLength;j++){
>           System.out.print(dp[i][j]+" ");
>       }
>       System.out.println();
>   }
>   System.out.println(str.substring(begin,begin+maxLen));
>}
>}
>```
>
>| （i，j） | 0b   | 1a   | 2b   | 3a   | 4d   |
>| -------- | ---- | ---- | ---- | ---- | ---- |
>| 0b       | T    |      | T    |      |      |
>| 1a       |      | T    |      | T    |      |
>| 2b       |      |      | T    |      |      |
>| 3a       |      |      |      | T    |      |
>| 4d       |      |      |      |      | T    |
>
>```java
>//另一种方法，中心扩展法
>class Solution {
>    public String longestPalindrome(String s) {
>        if (s == null || s.length() < 1) {
>            return "";
>        }
>        int start = 0, end = 0;
>        for (int i = 0; i < s.length(); i++) {
>            int len1 = expandAroundCenter(s, i, i);
>            int len2 = expandAroundCenter(s, i, i + 1);
>            int len = Math.max(len1, len2);
>            if (len > end - start) {
>                start = i - (len - 1) / 2;
>                end = i + len / 2;
>            }
>        }
>        return s.substring(start, end + 1);
>    }
>
>    public int expandAroundCenter(String s, int left, int right) {
>        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
>            --left;
>            ++right;
>        }
>        return right - left - 1;
>    }
>}
>```
>
>

### 最长回文子序列

>```java
>class Solution {
>public int longestPalindromeSubseq(String s) {
>   if (s == null || s.length() == 0) {
>       return 0;
>   }
>   //dp[i][j]代表从i到j的序列的最长回文子序列
>   int[][] dp = new int[s.length()][s.length()];
>   int maxLen = 1;
>   for (int i = s.length() - 1; i >= 0; i--) {
>       for (int j = i; j < s.length(); j++) {
>           if (j == i) {
>               dp[i][j] = 1;
>           } else if (j == i + 1) {
>               dp[i][j] = s.charAt(i) == s.charAt(j) ? 2 : 1;
>               if (dp[i][j] > maxLen) {
>                   maxLen = dp[i][j];
>               }
>           } else {
>               dp[i][j] = s.charAt(i) == s.charAt(j) ? dp[i + 1][j - 1] + 2 :
>                       Math.max(Math.max(dp[i + 1][j - 1],dp[i+1][j]),dp[i][j-1]);
>               if (dp[i][j] > maxLen) {
>                   maxLen = dp[i][j];
>               }
>           }
>       }
>   }
>   /*for (int[] ints : dp) {
>       for (int anInt : ints) {
>           System.out.print(anInt + " ");
>       }
>       System.out.println();
>   }*/
>   return maxLen;
>}
>}
>```
>
>

### 回文子串数目

>```java
>class Solution {
>    public int countSubstrings(String s) {
>        int res = 0;
>        boolean[][] dp = new boolean[s.length()][s.length()];
>        for (int i = s.length() - 1; i >= 0; i--) {
>            for (int j = i; j < s.length(); j++) {
>                if (j == i) {
>                    dp[i][j] = true;
>                    res += 1;
>                } else if (j == i + 1 && s.charAt(i) == s.charAt(j)) {
>                    dp[i][j] = true;
>                    res += 1;
>                } else if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
>                    dp[i][j] = true;
>                    res += 1;
>                }
>            }
>        }
>        return res;
>    }
>}
>```
>
>

### 最长数对列

>**输入**：[[1,2], [2,3], [3,4]]
>**输出**：2
>**解释**：最长的数对链是 [1,2] -> [3,4]
>
>```java
>public int findLongestChain(int[][] pairs) {
>    if (pairs == null || pairs.length == 0) {
>        return 0;
>    }
>    Arrays.sort(pairs, (a, b) -> (a[0] - b[0]));
>    int n = pairs.length;
>    int[] dp = new int[n];
>    Arrays.fill(dp, 1);
>    for (int i = 1; i < n; i++) {
>        for (int j = 0; j < i; j++) {
>            if (pairs[j][1] < pairs[i][0]) {
>                dp[i] = Math.max(dp[i], dp[j] + 1);
>            }
>        }
>    }
>    return Arrays.stream(dp).max().orElse(0);
>}
>```
>
>

### 最大数组和

>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。
>
>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
>输出：6
>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
>
>```java
>class Solution {
>    public int maxSubArray(int[] nums) {
>        if (nums.length < 1)
>            return -1;
>        int max = nums[0];
>        int res = max;
>        for (int i = 1; i < nums.length; i++) {
>            if (max < 0) {
>                max = nums[i];
>            }else {
>                max+=nums[i];
>            }
>            res=Math.max(res, max);
>        }
>        return res;
>    }
>}
>```
>
>

### 最大数组积

>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。测试用例的答案是一个 32-位 整数。子数组 是数组的连续子序列。
>
>输入: nums = [2,3,-2,4]
>输出: 6
>解释: 子数组 [2,3] 有最大乘积 6。
>
>```java
>public class testdama {
>public static void main(String[] args) {
>   int[] nums=new int[]{2,3,-2,4};
>   int[] dpMax=new int[nums.length];
>   int[] dpMin=new int[nums.length];
>   if(nums.length<=1)
>       System.out.println(nums[0]);
>   dpMax[0]=dpMin[0]=nums[0];
>   for(int i=1;i<nums.length;i++){
>       dpMax[i]=Math.max(dpMax[i - 1] * nums[i], Math.max(nums[i], dpMin[i - 1] * nums[i]));
>       dpMin[i]=Math.min(dpMin[i - 1] * nums[i], Math.min(nums[i], dpMax[i - 1] * nums[i]));
>   }
>
>   for (int i = 0; i < nums.length; ++i) {
>       System.out.print(dpMax[i]+" ");
>   }
>   System.out.println();
>   for (int i = 0; i < nums.length; ++i) {
>       System.out.print(dpMin[i]+" ");
>   }
>   System.out.println();
>
>   int ans = dpMax[0];
>   for (int i = 1; i < nums.length; ++i) {
>       ans = Math.max(ans, dpMax[i]);
>   }
>   System.out.println(ans);
>}
>}
>```
>
>```java
>class Solution {
>public int maxProduct(int[] nums) {
>   int min=nums[0];//维持一个最小的负数
>   int max=nums[0];
>   int result=nums[0];
>   for(int i=1;i<nums.length;i++){
>       int temp1=nums[i]*max;
>       int temp2=nums[i]*min;
>       min=Math.min(nums[i],Math.min(temp1, temp2));
>       max=Math.max(nums[i], Math.max(temp1, temp2));
>       result=Math.max(result, max);
>   }
>   return result;
>}
>}
>```
>
>

### 最大正方形

>在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。
>
>输入：matrix = [
>		["1","0","1","0","0"],
>		["1","0","1","1","1"],
>		["1","1","1","1","1"],
>		["1","0","0","1","0"]
>]
>输出：4
>
>```java
>public class testdama {
>    public static void main(String[] args) {
>        char[][] matrix=new char[][]{
>                {'1','0','1','0','0'},
>                {'1','0','1','1','1'},
>                {'1','1','1','1','1'},
>                {'1','0','0','1','0'}
>        };
>        if(matrix.length==0||matrix[0].length==0){
>            System.out.println(-1);
>        }
>        int dp[][]=new int[matrix.length][matrix[0].length];
>        int max=0;
>        for(int i=0;i<matrix.length;i++){
>            for(int j=0;j<matrix[0].length;j++){
>                if(matrix[i][j]=='1') {
>                    if (i == 0 || j == 0) {
>                        dp[i][j]=1;
>                    }else {
>                        //取其上边，左边，左上边的最小值
>                        dp[i][j]=Math.min(Math.min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1;
>                    }
>                }
>                max=Math.max(max, dp[i][j]*dp[i][j]);
>            }
>        }
>
>        for(int i=0;i<matrix.length;i++){
>            for(int j=0;j<matrix[0].length;j++){
>                System.out.print(dp[i][j]+" ");
>            }
>            System.out.println();
>        }
>        System.out.println(max);
>    }
>}
>```
>
>

## 背包问题

### 简单背包

>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。
>
>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：
>
>- 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。
>- 第 i 件物品添加到背包中，`dp[i][j] = dp[i-1][j-w] + v。`
>
>```java
>// W 为背包总体积
>// N 为物品数量
>// weights 数组存储 N 个物品的重量
>// values 数组存储 N 个物品的价值
>public int knapsack(int W, int N, int[] weights, int[] values) {
>   int[][] dp = new int[N + 1][W + 1];
>   for (int i = 1; i <= N; i++) {
>       int w = weights[i - 1], v = values[i - 1];
>       for (int j = 1; j <= W; j++) {
>           if (j >= w) {
>               //当前最大值要么不放这个物品，要么放这个物品，取决于哪个大
>               dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
>           } else {
>               dp[i][j] = dp[i - 1][j];
>           }
>       }
>   }
>   return dp[N][W];
>}
>```
>
>优化空间
>
>因为 `dp[j-w] `表示 `dp[i-1][j-w]`，因此不能先求` dp[i][j-w]`，防止将 `dp[i-1][j-w]` 覆盖。也就是说要先计算 `dp[i][j]` 再计算 `dp[i][j-w]`，在程序实现时需要按倒序来循环求解。
>
>```java
>public int knapsack(int W, int N, int[] weights, int[] values) {
>   int[] dp = new int[W + 1];
>   for (int i = 1; i <= N; i++) {
>       int w = weights[i - 1], v = values[i - 1];
>       for (int j = W; j >= 1; j--) {
>           if (j >= w) {
>               dp[j] = Math.max(dp[j], dp[j - w] + v);
>           }
>       }
>   }
>   return dp[W];
>}
>```
>
>

### 分割等和子集

>**输入**：nums = [1,5,11,5]
>**输出**：true
>**解释**：数组可以分割成 [1, 5, 5] 和 [11] 。
>
>```java
>//可以看成一个背包大小为 sum/2 的 0-1 背包问题，就是在数组中挑几个数看他的和是不是能等于sum/2，剩下的另一半自然也等于sum/2。
>public boolean canPartition(int[] nums) {
>        int sum = computeArraySum(nums);
>        if (sum % 2 != 0) {
>            return false;
>        }
>        int W = sum / 2;
>        boolean[] dp = new boolean[W + 1];//存不存在这种组合
>        dp[0] = true;
>        for (int num : nums) {// 0-1 背包一个物品只能用一次
>              //顺序计算的话会覆盖前边的值，只计算到num是为了使i - num不越界
>               for (int i = W; i >= num; i--) {   // 从后往前，先计算 dp[i] 再计算 dp[i-num]
>                     dp[i] = dp[i] || dp[i - num];
>               }
>        }
>        return dp[W];
>    }
>
>    private int computeArraySum(int[] nums) {
>        int sum = 0;
>        for (int num : nums) {
>               sum += num;
>        }
>        return sum;
>    }
>```
>
>

### 目标和

>**输入**：nums = [1,1,1,1,1], target = 3
>**输出**：5
>**解释**：一共有 5 种方法让最终目标和为 3 。
>-1 + 1 + 1 + 1 + 1 = 3
>+1 - 1 + 1 + 1 + 1 = 3
>+1 + 1 - 1 + 1 + 1 = 3
>+1 + 1 + 1 - 1 + 1 = 3
>+1 + 1 + 1 + 1 - 1 = 3
>
>```java
>/*
>假设存在这种方法，取一些数出来，加正号他们的和是X,另一些加符号他们的和是Y,
>X-Y=taregt        ....(1)
>Y=sum(nums)-X     ....(2)
>由(1),(2)式可得X=(target + sum(nums))/2,因此只需要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。问题转化为Subset Sum，求其中可不可以找到多少组数使得其和为(target + sum(nums))/2
>*/
>public int findTargetSumWays(int[] nums, int S) {
>        int sum = computeArraySum(nums);
>        if (sum < Math.abs(target) || (sum + S) % 2 == 1) {
>            return 0;
>        }
>        int W = (sum + S) / 2;
>        int[] dp = new int[W + 1];//和为i的有多少种方法，已有的方法加上对nums[i]取差的方法
>        dp[0] = 1;
>        for (int num : nums) {
>            for (int i = W; i >= num; i--) {
>                dp[i] = dp[i] + dp[i - num];
>            }
>        }
>        return dp[W];
>    }
>
>    private int computeArraySum(int[] nums) {
>        int sum = 0;
>        for (int num : nums) {
>            sum += num;
>        }
>        return sum;
>    }
>```
>
>

### 01 字符构成最多的字符串

>输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
>输出：4
>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
>其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
>
>```java
>//这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。
>public int findMaxForm(String[] strs, int m, int n) {
>    if (strs == null || strs.length == 0) {
>        return 0;
>    }
>    int[][] dp = new int[m + 1][n + 1];
>    for (String s : strs) {    // 每个字符串只能用一次
>        int ones = 0, zeros = 0;
>        for (char c : s.toCharArray()) {
>            if (c == '0') {
>                zeros++;
>            } else {
>                ones++;
>            }
>        }
>        for (int i = m; i >= zeros; i--) {
>            for (int j = n; j >= ones; j--) {
>                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
>            }
>        }
>    }
>    return dp[m][n];
>}
>```
>
>

### 找零钱的最少硬币数

>**输入**：coins = [1, 2, 5], amount = 11
>**输出**：3 
>**解释**：11 = 5 + 5 + 1
>
>```java
>public class Solution {
>public static void main(String[] args) {
>int amount=27;
>int[] coins=new int[]{2,5,10,1};
>int[] dp=new int[amount+1];
>Arrays.fill(dp,amount+1);//用来判断能否满足条件
>dp[0]=0;
>for(int i=1;i<=amount;i++){
>  for(int j=0;j<coins.length;j++){
>      if(i>=coins[j]){
>          dp[i]=Math.min(dp[i], dp[i-coins[j]]+1);
>      }
>  }
>}
>for(int i=0;i<dp.length;i++){
>  System.out.print(dp[i]+" ");
>}
>System.out.println(dp[amount]>amount?-1:dp[amount]);
>}
>}
>
>public int coinChange(int[] coins, int amount) {
>   if (amount == 0 || coins == null) return 0;
>   int[] dp = new int[amount + 1];
>   for (int coin : coins) {
>       for (int i = coin; i <= amount; i++) {//从coin开始算，比coin小的也不可能再优化了
>           if (coin == i) {
>               dp[i] = 1;
>            //dp[i]=0说明还没被计算过
>           } else if (dp[i - coin] != 0 && dp[i] == 0) {
>               dp[i] = dp[i - coin] + 1;
>           //dp[i]!=0说明计算过了，要取最小值以免被覆盖
>           } else if (dp[i - coin] != 0) {
>               dp[i] = Math.min(dp[i], dp[i - coin] + 1);
>           }
>       }
>   }
>   return dp[amount] == 0 ? -1 : dp[amount];
>}
>```
>
>

### 找零钱的硬币数组合

>输入：amount = 5, coins = [1, 2, 5]
>输出：4
>解释：有四种方式可以凑成总金额：
>5=5
>5=2+2+1
>5=2+1+1+1
>5=1+1+1+1+1
>
>```java
>/**
> dp表示i块钱时，有的组成方法
> */
> public static void main(String[] args) {
>         int amount=3;
>         int[] coins=new int[]{2};
>         int[] dp=new int[amount+1];
>         dp[0]=1;
>         for(int coin:coins){
>             for(int i=coin;i<=amount;i++){
>                 dp[i]+=dp[i-coin];
>             }
>         }
>         System.out.println(dp[amount]);
>     }
>```
>
>

### 字符串按单词列表分割

>**输入**: s = "leetcode", wordDict = ["leet", "code"]
>**输出**: true
>**解释**: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
>
>dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 "leetcode"：
>
>```html
>["lee", "tc", "cod"]
>```
>
>求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。
>
>```java
>public boolean wordBreak(String s, List<String> wordDict) {
>    int n = s.length();
>    boolean[] dp = new boolean[n + 1];//以i结尾的字符串是否能完全匹配
>    dp[0] = true;
>    for (int i = 1; i <= n; i++) {
>        for (String word : wordDict) {   
>            int len = word.length();
>            if (len <= i && word.equals(s.substring(i - len, i))) {
>                dp[i] = dp[i] || dp[i - len];
>            }
>        }
>    }
>    return dp[n];
>}
>```
>
>

### 组合总和

>输入：nums = [1,2,3], target = 4
>输出：7
>解释：
>所有可能的组合为：
>(1, 1, 1, 1)
>(1, 1, 2)
>(1, 2, 1)
>(1, 3)
>(2, 1, 1)
>(2, 2)
>(3, 1)
>请注意，顺序不同的序列被视作不同的组合。
>
>涉及顺序的完全背包。
>
>```java
>public int combinationSum4(int[] nums, int target) {
>    if (nums == null || nums.length == 0) {
>        return 0;
>    }
>    int[] maximum = new int[target + 1];
>    maximum[0] = 1;
>    Arrays.sort(nums);
>    for (int i = 1; i <= target; i++) {
>        for (int j = 0; j < nums.length && nums[j] <= i; j++) {
>            maximum[i] += maximum[i - nums[j]];
>        }
>    }
>    return maximum[target];
>}
>```
>
>

## 买卖股票

[动态规划股票问题通解](https://xiaochen1024.com/courseware/60b4f11ab1aa91002eb53b18/61963bcdc1553b002e57bf13)

>**`dp[i][j][0,1]`代表第i天交易j次手中持有和不持有股票时能获得的最大利润**
>
>1. `dp[i][k][0]`  **第i天 交易k次 0手中没有股票**
>2. `dp[i][k][1]`  **第i天 交易k次 1手中有股票**
>
>
>
>**最大利润是以下两种情况的最大值**
>
>**今天没有持有股票，分为两种情况**：
>
>1. `dp[i - 1][k][0]` **昨天没有持有，今天不操作**
>2. `dp[i - 1][k][1] + prices[i]` **昨天持有，今天卖出，今天手中就没有股票了**
>
>**今天不持有股票的最大利润**: `dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i])`
>
>
>
>**今天持有股票，分为两种情况**：
>
>1. `dp[i - 1][k][1] `**昨天持有，今天不操作**
>2. `dp[i - 1][k - 1][0] - prices[i] `**昨天没有持有，今天买入，注意在买入的时候记一次数**
>
>**今天持有股票的最大利润**：`dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0]-prices[i])`

### 买卖股票I

>只允许买卖一次，相当于k=1
>**思路**：
>
>>` dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i])`
>>` dp[i][1][1] = Math.max(dp[i - 1][1][1], dp[i - 1][0][0] - prices[i])`
>>`Math.max(dp[i - 1][1][1], -prices[i])` // k=0时 没有交易次数，`dp[i - 1][0][0] `= 0
>>k是固定值1，不影响结果，所以可以不用管，简化之后如下：
>>`dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])`
>>`dp[i][1] = Math.max(dp[i - 1][1], -prices[i])`
>>dp[i] 只和 dp[i - 1] 有关，可以去掉一维
>
>```java
>//交易次数1
>public class BuyAndSell121 {
>//k固定是1，删去一维，i天只与i-1天有关，删去一维
>public int maxProfit(int[] prices) {
>   int[] dp = new int[2];
>   dp[0] = 0;//第一天不持有时持有的利润
>   dp[1] = -prices[0];//第一天持有时持有的利润
>   for (int i = 1; i < prices.length; i++) {
>       //当前不持有，要么是前一天不持有，要么是前一天持有今天卖了
>       dp[0] = Math.max(dp[0], dp[1] + prices[i]);
>       //当前持有，要么是前一天持有，要么是前一天不持有今天买了，这里之所以用-prices[i]是因为k=0时没有交易次数
>       dp[1] = Math.max(dp[1], -prices[i]);
>   }
>   return dp[0];
>}
>}
>
>//语义化
>class Solution {
>    public int maxProfit(int[] prices) {
>        int buy = -prices[0], sell = 0;
>        for (int i = 1; i < prices.length; i++) {
>            buy = Math.max( - prices[i], buy);
>            sell = Math.max(buy + prices[i], sell);
>        }
>        return sell;
>    }
>}
>```
>
>

### 买卖股票II

>交易次数无限制，相当于k = infinity
>
>**思路**：
>
>>` dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i])`
>>` dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i])`
>> k不影响结果，简化之后如下:
>>` dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])`
>>`dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i])`
>>dp[i] 只和 dp[i - 1] 有关，可以去掉一维
>
>```java
>//交易次数无限制
>public class BuyAndSell122 {
>   public int maxProfit(int[] prices) {
>       int[] dp = new int[2];
>       dp[0] = 0;//不持有
>       dp[1] = -prices[0];//持有
>       for (int i = 1; i < prices.length; i++) {
>           //当前不持有，要么是前一天不持有，要么是前一天持有今天卖了
>           dp[0] = Math.max(dp[0], dp[1] + prices[i]);
>           ////当前持有，要么是前一天持有，要么是前一天不持有今天买了
>           dp[1] = Math.max(dp[1], dp[0] - prices[i]);
>       }
>       return dp[0];
>   }
>}
>//语义化
>class Solution {
>    public int maxProfit(int[] prices) {
>           int buy = -prices[0], sell = 0;
>        for (int i = 1; i < prices.length; i++) {
>            buy = Math.max(sell - prices[i], buy);
>            sell = Math.max(buy + prices[i], sell);
>        }
>        return sell;
>    }
>}
>```
>
>

### 买卖股票III

>只允许交易2次，k=2
>
>**思路**：
>
>>`dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i])`
>>` dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i])`
>> k对结果有影响 不能舍去，只能对k进行循环
>
>> ```java
>> for (let i = 0; i < n; i++) {
>>         for (let k = maxK; k >= 1; k--) {
>>        dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
>>        dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
>>        }
>> }
>> ```
>
>>k=2，直接写出循环的结果
>
>>```java
>>dp[i][2][0] = Math.max(dp[i - 1][2][0], dp[i - 1][2][1] + prices[i])
>>dp[i][2][1] = Math.max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i])
>
>>dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i])
>>dp[i][1][1] = Math.max(dp[i - 1][1][1], dp[i - 1][0][0] - prices[i])
>>Math.max(dp[i - 1][1][1], -prices[i]) //k=0时 没有交易次数，dp[i - 1][0][0] = 0
>>
>>```
>
>>去掉i这一维度
>
>>```java
>>dp[2][0] = Math.max(dp[2][0], dp[2][1] + prices[i])
>>dp[2][1] = Math.max(dp[2][1], dp[1][0] - prices[i])
>
>>dp[1][0] = Math.max(dp[1][0], dp[1][1] + prices[i])
>>dp[1][1] = Math.max(dp[1][1], dp[0][0] - prices[i])
>>Math.max(dp[1][1], -prices[i]) //k=0时 没有交易次数，dp[i - 1][0][0] = 0
>>
>>```
>
>```java
>//k=2
>public class BuyAndSell123 {
>   //[3,3,5,0,0,3,1,4]
>   public int maxProfit(int[] prices) {
>       int[][] dp = new int[3][2];
>       dp[2][1]=dp[1][1]=-prices[0];
>       dp[2][0]=dp[1][0]=0;
>       for (int i = 1; i < prices.length; i++) {
>           dp[2][0] = Math.max(dp[2][0], dp[2][1] + prices[i]);
>           dp[2][1] = Math.max(dp[2][1], dp[1][0] - prices[i]);
>
>           dp[1][0] = Math.max(dp[1][0], dp[1][1] + prices[i]);
>           // k=0时 没有交易次数，dp[i - 1][0][0] = 0
>           dp[1][1] = Math.max(dp[1][1], -prices[i]);
>       }
>       return dp[2][0];
>   }
>}
>//直接使用k=2特例求解
>public int maxProfit(int[] prices) {
>        int[][][] dp=new int[prices.length][3][2];
>        dp[0][1][1]= dp[0][2][1]=-prices[0];
>        dp[0][1][0]= dp[0][2][0]=0;
>        for(int i=1;i<prices.length;i++){
>            for(int j=1;j<=2;j++){
>                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
>                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
>            }
>        }
>        return dp[prices.length-1][2][0];
>    }
>```
>
>

### 买卖股票IV

>限定交易次数 最多次数为 k
>
>**思路**：
>
>>采用完整的递推策略
>
>```java
>//可以交易k次
>public class BuyAndSell188 {
>    public int maxProfit(int[] prices, int k) {
>        //[第几天][还可以交易k次][不持有0，持有1]，dp代表当前能获得的最大利润
>        int[][][] dp = new int[prices.length][k + 1][2];
>        for (int j = 0; j <= k; j++) {
>            dp[0][j][0] = 0;//第一天不持有
>            dp[0][j][1] = -prices[0];//第一天持有
>        }
>        for (int i = 1; i < prices.length; i++) {
>            for (int j = 1; j <= k; j++) {
>                //不持有股票要么是前一天就不持有，要么是前一天持有今天卖掉
>                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
>                //持有股票要么是前一天就不持有，要么是前一天不持有今天买了，买的时候要把次数扣减
>                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
>            }
>        }
>        int ans = 0;
>        for (int j = 0; j <= k; j++) {
>            ans = Math.max(ans, dp[prices.length - 1][j][0]);
>        }
>        return ans;
>    }
>}
>```
>
>

### 买卖股票V

> 含有冷冻期，无限次交易
>
> **思路**：
>
> >每次买入时从前天开始
>
> ```java
> public class BuyAndSell309 {
>     public int maxProfit(int[] prices) {
>         int[][] dp = new int[prices.length][2];
>         dp[0][0] = 0;//第一天不持有
>         dp[0][1] = -prices[0];//第一天持有
> 
>         dp[1][0] = Math.max(dp[0][0], prices[1] + dp[0][1]);//第二天不持有
>         dp[1][1] = Math.max(-prices[1], dp[0][1]);//第二天持有
> 
>         for (int i = 2; i < prices.length; i++) {
>             // 当前不持有，要么是前一天不持有，要么是前一天持有今天卖了
>             dp[i][0] = Math.max(dp[i - 1][0], prices[i] + dp[i - 1][1]);
>             //今天持有，要么是昨天不持有，要么是前天不持有今天买了，注意在此
>             dp[i][1] = Math.max(dp[i - 2][0] - prices[i], dp[i - 1][1]);
>         }
>         return dp[prices.length - 1][0];
>     }
> }
> ```
>
> 

### 买卖股票VI

>含有手续费，无限次交易
>
>**思路**：
>
>>每次买入时扣掉手续费
>>`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)`
>>`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])`
>
>>与k无关，i只与i-1有关
>
>```java
>public class BuyAndSell714 {
>public int maxProfit(int[] prices, int fee) {
>   int[] dp = new int[2];
>   dp[0] = 0;//不持有
>   dp[1] = -prices[0];//持有
>   for (int i = 1; i < prices.length; i++) {
>       //当前不持有，要么是前一天不持有，要么是前一天持有今天卖了,这里买卖都可以扣，但是如果买的时候扣那第一天也要扣
>       dp[0] = Math.max(dp[0], dp[1] + prices[i] - fee);
>       ////当前持有，要么是前一天持有，要么是前一天不持有今天买了
>       dp[1] = Math.max(dp[1], dp[0] - prices[i]);
>   }
>   return dp[0];
>}
>}
>
>//语义化
>public int maxProfit(int[] prices, int fee) {
>        int buy = -prices[0], sell = 0;
>        for (int i = 1; i < prices.length; i++) {
>            buy = Math.max(buy, sell - prices[i]);
>            sell = Math.max(sell, buy + prices[i] - fee);
>        }
>        return sell;
>}
>```
>
>

## 字符串编辑

### 删除两个字符串的字符使它们相等

>输入: word1 = "sea", word2 = "eat"
>输出: 2
>解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
>
>```java
>//可以转换为求两个字符串的最长公共子序列问题。
>public int minDistance(String word1, String word2) {
>    int m = word1.length(), n = word2.length();
>    int[][] dp = new int[m + 1][n + 1];
>    for (int i = 1; i <= m; i++) {
>        for (int j = 1; j <= n; j++) {
>            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
>                dp[i][j] = dp[i - 1][j - 1] + 1;
>            } else {
>                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
>            }
>        }
>    }
>    return m + n - 2 * dp[m][n];
>}
>```
>
>

### 编辑距离

>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。
>
>你可以对一个单词进行如下三种操作：
>
>插入一个字符
>删除一个字符
>替换一个字符
>
>输入：word1 = "intention", word2 = "execution"
>输出：5
>解释：
>intention -> inention (删除 't')
>inention -> enention (将 'i' 替换为 'e')
>enention -> exention (将 'n' 替换为 'x')
>exention -> exection (将 'n' 替换为 'c')
>exection -> execution (插入 'u')
>
>```java
>public int minDistance(String word1, String word2) {
>    if (word1 == null || word2 == null) {
>        return 0;
>    }
>    int m = word1.length(), n = word2.length();
>    int[][] dp = new int[m + 1][n + 1];
>    for (int i = 1; i <= m; i++) {
>        dp[i][0] = i;
>    }
>    for (int i = 1; i <= n; i++) {
>        dp[0][i] = i;
>    }
>    for (int i = 1; i <= m; i++) {
>        for (int j = 1; j <= n; j++) {
>            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
>                dp[i][j] = dp[i - 1][j - 1];
>            } else {
>                dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;
>            }
>        }
>    }
>    return dp[m][n];
>}
>```
>
>

### 复制粘贴字符

>输入：3
>输出：3
>解释：
>最初, 只有一个字符 'A'。
>第 1 步, 使用 Copy All 操作。
>第 2 步, 使用 Paste 操作来获得 'AA'。
>第 3 步, 使用 Paste 操作来获得 'AAA'。
>
>```java
>public int minSteps(int n) {
>    int[] dp = new int[n + 1];
>    int h = (int) Math.sqrt(n);
>    for (int i = 2; i <= n; i++) {
>        dp[i] = i;
>        for (int j = 2; j <= h; j++) {
>            if (i % j == 0) {
>                dp[i] = dp[j] + dp[i / j];
>                break;
>            }
>        }
>    }
>    return dp[n];
>}
>```
>
>

### 正则表达式匹配

>你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
>
>'.' 匹配任意单个字符
>'*' 匹配零个或多个前面的那一个元素
>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
>
>```java
>public boolean isMatch(String s, String p) {
>
>        int sLength = s.length();
>        int pLength = p.length();
>
>        // 初始化 dp 数组， 默认dp[i][0] 初始化为false：对应s非空， p空串的情况
>        boolean[][] dp = new boolean[sLength + 1][pLength + 1];
>        dp[0][0] = true;
>        for (int j = 2; j <= pLength; j += 2) {
>            //如果往前两个是*的话可以通过0次匹配消除
>            dp[0][j] = dp[0][j - 2] && (p.charAt(j - 1) == '*');
>        }
>
>        for (int i = 1; i <= sLength; i++) {
>            for (int j = 1; j <= pLength; j++) {
>                if (p.charAt(j - 1) == '*') {//
>                    if (j >= 2) {
>                        //dp[i][j - 2]只要能匹上就可以，因为*可以视为匹配0次,丢弃当前字符与前一个字符
>                        //将*字符与当前字符组成一个
>                        dp[i][j] = (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) || dp[i][j - 2];
>                    }
>                } else if (p.charAt(j - 1) == '.' || s.charAt(i - 1) == p.charAt(j - 1)) {//.能代替任意的数据或者当前相等也行
>                    dp[i][j] = dp[i - 1][j - 1];
>                }
>            }
>        }
>        /*for (boolean[] i : dp) {
>            for (boolean j : i) {
>                System.out.print(j + " ");
>            }
>            System.out.println();
>        }*/
>        return dp[sLength][pLength];
>    }
>```
>
>

## 其它问题

### 312戳气球

>输入：nums = [3,1,5,8]
>输出：167
>解释：
>nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
>coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
>
>```java
>class Solution {
>public int maxCoins(int[] nums) {
>   int n = nums.length;
>   int[][] dp = new int[n + 2][n + 2];
>   int[] val = new int[n + 2];
>   val[0] = val[n + 1] = 1;
>   for (int i = 1; i <= n; i++) {
>       val[i] = nums[i - 1];//首尾补1便于计算
>   }
>   for (int i = n - 1; i >= 0; i--) {
>       for (int j = i + 2; j <= n + 1; j++) {
>           for (int k = i + 1; k < j; k++) {
>               int sum = val[i] * val[k] * val[j];
>               sum += dp[i][k] + dp[k][j];
>               dp[i][j] = Math.max(dp[i][j], sum);
>           }
>       }
>   }
>   return dp[0][n + 1];
>}
>}
>```
>
>

### 接雨水

>**输入**：height = [0,1,0,2,1,0,1,3,2,1,2,1]
>**输出**：6
>**解释**：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
>**思路**：就是找到每一个柱子的左右最小值就是这个柱子能接的雨水量
>
>```java
>class Solution {
>    public int trap(int[] height) {
>        int n=height.length;
>        int[] maxLeft=new int[n];
>        
>        maxLeft[0]=height[0];
>        for(int i=1;i<n;i++){
>            maxLeft[i]=Math.max(maxLeft[i-1],height[i]);
>        }
>        
>        int[] maxRight=new int[n];
>        maxRight[n-1]=height[n-1];
>        for(int i=n-2;i>=0;i--){
>            maxRight[i]=Math.max(maxRight[i+1],height[i]);
>        }
>
>        int result=0;
>        for(int i=0;i<n;i++){
>            result+=Math.min(maxLeft[i],maxRight[i])-height[i];
>        }
>        return result;
>    }
>}
>```
>
>

### 最长有效括号

>```java
>)()()) //4个
>()(())  //6个
>```
>
>```java
>public int longestValidParentheses(String s) {
>    int res = 0;
>    int[] dp = new int[s.length()];
>    for (int i = 1; i < s.length(); i++) {
>        if (s.charAt(i) == ')') {
>            if (s.charAt(i - 1) == '(') {
>                dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
>            } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
>                int lastValidLeftBrackets = i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0;
>                dp[i] = dp[i - 1] + lastValidLeftBrackets + 2;
>            }
>        }
>        res = Math.max(res, dp[i]);
>    }
>    return res;
>}
>```

## 理论

> 可以用动态规划解决的问题具有如下特征：
>
> - 求最优解问题（最大值和最小值）
>
> - 求可行性（True 或 False）
>
> - 求方案总数
>
> - 数据结构不可排序（Unsortable）---最小K个数
>
> - 算法不可使用交换（Non-swappable）---八皇后、全排列
>
>   ```
>   525、53、560、152、238、724、1477、713、1352、801、673、300、1143、115、940、1425、121、122、309、714、123、188、873、1027、1055、368、413、91、639、338、801、583、32、132、871、818、120、64、221、931、343、85、363
>                 
>   区间问题
>   5、647、1000、516、1147、730、1312、312、546、1039
>                 
>   背包问题
>   5、647、1000、516、1147、730、1312、312、546、1039
>                 
>   方案总数问题
>   62、63、96、95、1155、940
>                 
>   复杂问题
>   887、1067、600、1012
>   ```
>
>   

# 双指针

## 11盛最多水的容器

>输入：[1,8,6,2,5,4,8,3,7]
>输出：49 
>解释：垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49(7个距离*7的高度)。
>思路：每次移动短板，因为移动长板高度不会变，距离短一格一定比当前盛水少
>
>```java
>class Solution {
>    public int maxArea(int[] height) {
>         int left=0,right=height.length-1;
>        int thisArea,maxArea=0;
>        while(left<right){
>        	thisArea=(right-left)*Math.min(height[left], height[right]);
>        	maxArea=Math.max(thisArea, maxArea);
>        	if(height[left]>height[right])
>        		right--;
>        	else
>        		left++;
>        }
>        return maxArea;
>    }
>}
>```
>
>

## 76最小覆盖子串

>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
>
>示例 1：
>输入：s = "ADOBECODEBANC", t = "ABC"
>输出："BANC"
>
>```java
>class Solution {
>    public String minWindow(String s, String t) {
>        if (s == null || s == "" || t == null || t == "" || s.length() < t.length()) {
>            return "";
>        }
>        //维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数
>        //ASCII表总长128
>        int[] need = new int[128];
>        int[] have = new int[128];
>
>        //将目标字符串指定字符的出现次数记录
>        for (int i = 0; i < t.length(); i++) {
>            need[t.charAt(i)]++;
>        }
>
>        //分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)
>        //已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置
>        int left = 0, right = 0, min = s.length() + 1, count = 0, start = 0;
>        while (right < s.length()) {
>            char r = s.charAt(right);
>            //说明该字符不被目标字符串需要，此时有两种情况
>            // 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断
>            // 2.循环已经开始一段时间，此处又有两种情况
>            //  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时
>            //      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可
>            //  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针
>            if (need[r] == 0) {
>                right++;
>                continue;
>            }
>            //当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1
>            //是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数
>            if (have[r] < need[r]) {
>                count++;
>            }
>            //已有字符串中目标字符出现的次数+1
>            have[r]++;
>            //移动右指针
>            right++;
>            //当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次
>            while (count == t.length()) {
>                //挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置
>                if (right - left < min) {
>                    min = right - left;
>                    start = left;
>                }
>                char l = s.charAt(left);
>                //如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针
>                if (need[l] == 0) {
>                    left++;
>                    continue;
>                }
>                //如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，
>                //就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1
>                if (have[l] == need[l]) {
>                    count--;
>                }
>                //已有字符串中目标字符出现的次数-1
>                have[l]--;
>                //移动左指针
>                left++;
>            }
>        }
>        //如果最小长度还为初始值，说明没有符合条件的子串
>        if (min == s.length() + 1) {
>            return "";
>        }
>        //返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串
>        return s.substring(start, start + min);
>    }
>}
>```
>
>

## 环形链表II

>找出环形链表的入口，一种解法是用哈希表，首次能在哈希表找到的即为入口节点，另一种是如下的双指针，相遇以后再次从开头出发再次相遇时即为入口点。
>
>```java
>public class Solution {
>    public ListNode detectCycle(ListNode head) {
>        if (head == null) {
>            return null;
>        }
>        ListNode slow = head, fast = head;
>        while (fast != null) {
>            slow = slow.next;
>            if (fast.next != null) {
>                fast = fast.next.next;
>            } else {
>                return null;
>            }
>            if (fast == slow) {
>                ListNode ptr = head;
>                while (ptr != slow) {
>                    ptr = ptr.next;
>                    slow = slow.next;
>                }
>                return ptr;
>            }
>        }
>        return null;
>    }
>}
>```
>
>

# 贪心

## 分饼干

>思路：优先满足胃口大的，排序两个数组，从右到左遍历，用大饼干首先满足胃口大的小孩
>
>

## 无重叠区间

>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。
>
>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
>输出: 1
>解释: 移除 [1,3] 后，剩下的区间没有重叠。
>
>思路：先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。
>
>```java
>class Solution {
>    public int eraseOverlapIntervals(int[][] intervals) {
>        if (intervals.length == 0) {
>            return 0;
>        }
>        
>        Arrays.sort(intervals, new Comparator<int[]>() {
>            public int compare(int[] interval1, int[] interval2) {
>                return interval1[1] - interval2[1];
>            }
>        });
>
>        int n = intervals.length;
>        int right = intervals[0][1];
>        int ans = 1;
>        for (int i = 1; i < n; ++i) {
>            if (intervals[i][0] >= right) {
>                ++ans;
>                right = intervals[i][1];
>            }
>        }
>        return n - ans;
>    }
>}
>```
>
>

## 合并区间

>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
>输出：[[1,6],[8,10],[15,18]]
>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
>
>```java
>class Solution {
>    public int[][] merge(int[][] intervals) {
>        ArrayList<int[]> res = new ArrayList<>();
>        Arrays.sort(intervals, Comparator.comparingInt(o -> o[0]));
>        int start = intervals[0][0], end = intervals[0][1];
>        for (int i = 1; i < intervals.length; i++) {
>            if (intervals[i][0] <= end) {
>                end = Math.max(intervals[i][1],end);
>            } else {
>                res.add(new int[]{start, end});
>                start = intervals[i][0];
>                end = intervals[i][1];
>            }
>        }
>        res.add(new int[]{start, end});
>        return res.toArray(new int[res.size()][]);
>    }
>}
>```
>
>

## 跳跃游戏

>输入：nums = [2,3,1,1,4]
>输出：true
>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
>
>思路：不用考虑每一步跳跃到那个位置，而是尽可能的跳跃到最远的位置，看最多能覆盖的位置，不断更新能覆盖的距离。
>
>```java
>class Solution {
>    public boolean canJump(int[] nums) {
>        int currentMaxLength=0;
>        for(int i=0;i<nums.length;i++){
>            if(i>currentMaxLength){
>                return false;
>            }
>            if(currentMaxLength>=nums.length){
>                return true;
>            }
>            currentMaxLength=Math.max(currentMaxLength, i+nums[i]);
>        }
>        return true;
>    }
>}
>```
>
>

# 二分查找

## 基本框架及其变种

```java
/*
 *二分搜索实际上是不断卡left和right的过程，卡到什么位置，取决于你的实际需求
 *如果是要取到第一个，那就要严格卡left，除非目标元素确实比它大，否则不移动左界
 *如果是要取最后一个，那就要严格卡right，除非目标元素确实比它小，否则不移动右界
 */
public class BinarySearch1 {
    //正常的二分搜索，检索到那个数字为止，有重复的随机返回了
    public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
            /**
             * 加等号是因为当两个数指到同一个位置时，这个位置又刚好是要找的数,
             * 比如3，4两个数，找4，第一次二分，指向了3没找到,继续左指针右移，此时两指针同位置
             * */
            int mid=left+(right-left)/2;//避免溢出，两边取闭区间
            if(nums[mid]==x)//这里找到就为止
                return mid;
            else if(nums[mid]<x)//这是卡着left不让它动
                left=mid+1;
            else                //尽量移动right
                right=mid-1;
        }
        return -1;
    }
}

//二分搜索变种，寻找元素第一次出现的位置,只要卡着left不动，右边即使等于也让它往前移
public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
        int mid=left+(right-left)/2;
        if(left<=nums.length-1&&nums[mid]<x)
        left=mid+1;
        else
        right=mid-1;
        }
        if(left<nums.length&&nums[left]==x)return left;//这里要注意
        return -1;
}

//二分搜索变种，寻找元素最后一次出现的位置,只要卡着right不动,左边即使等于也让它往后移
public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]<=x)
        left=mid+1;
        else
        right=mid-1;
        }
        if(right>=0&&nums[right]==x)return right;
        return -1;
}

//二分搜索变种，寻找第一个大于目标元素的位置
public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]<=x)
        left=mid+1;
        else
        right=mid-1;
        }
        if(right+1>=nums.length)return -1;
        return right+1;
}

//二分搜索变种，寻找第一个小于目标元素的位置
public int binarySearch(int[] nums,int x){
        int left=0,right=nums.length-1;
        while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]<x)
        left=mid+1;
        else
        right=mid-1;
        }
        return left-1;
}


```

## 4寻找两个正序数组的中位数

>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 **O(log (m+n))** 。
>
>输入：nums1 = [1,3], nums2 = [2]
>输出：2.00000
>解释：合并数组 = [1,2,3] ，中位数 2
>思路：转化为求两个数组的第k小的元素，采用二分每次丢弃一半
>
>```java
>public class Main {
>
>    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
>        int length1 = nums1.length, length2 = nums2.length;
>        int totalLength = length1 + length2;
>        if (totalLength % 2 == 1) {//总共奇数个的话寻找中间一个
>            int midIndex = totalLength / 2;
>            double median = getKthElement(nums1, nums2, midIndex + 1);
>            return median;
>        } else {//总共偶数个的话寻找中间两个求均值
>            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
>            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
>            return median;
>        }
>    }
>
>   /* 
>   主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较（这里的 "/" 表示整除）
>         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
>         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
>         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
>         * 这样 pivot 本身最大也只能是第 k-1 小的元素
>         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
>         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
>         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
>*/
>    public int getKthElement(int[] nums1, int[] nums2, int k) {
>        int length1 = nums1.length, length2 = nums2.length;
>        int index1 = 0, index2 = 0;
>        int kthElement = 0;
>
>        while (true) {
>            // 边界情况
>            if (index1 == length1) {
>                return nums2[index2 + k - 1];
>            }
>            if (index2 == length2) {
>                return nums1[index1 + k - 1];
>            }
>            if (k == 1) {
>                return Math.min(nums1[index1], nums2[index2]);
>            }
>
>            // 正常情况
>            int half = k / 2;
>            int newIndex1 = Math.min(index1 + half, length1) - 1;
>            int newIndex2 = Math.min(index2 + half, length2) - 1;
>            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
>            if (pivot1 <= pivot2) {//哪个数组中间的值小的话就把那一半去掉，因为肯定不会在那一边
>                k -= (newIndex1 - index1 + 1);//更新k值
>                index1 = newIndex1 + 1;//向前推进索引
>            } else {
>                k -= (newIndex2 - index2 + 1);
>                index2 = newIndex2 + 1;
>            }
>        }
>    }
>}
>```
>
>

## 搜索旋转排序数组

>**输入**：nums = [4,5,6,7,0,1,2], target = 0
>**输出**：4
>**思路**：找到最小的值然后切分，然后对子序列进行二分查找
>
>```java
>class Solution {
>        public int search(int[] nums, int target) {
>            if (nums.length == 0) return -1;
>            int min = findMin(nums);
>            int left = 0, right = nums.length - 1;
>            if (target > nums[nums.length - 1])
>                right = min - 1;
>            else
>                left = min;
>            while (left <= right) {
>                int mid = left + (right - left) / 2;
>                if (nums[mid] == target) return mid;
>                else if (nums[mid] > target) right = mid - 1;
>                else left = mid + 1;
>            }
>            return -1;
>        }
>
>        public int findMin(int[] nums) {
>            int left = 0, right = nums.length - 1;
>            while (left < right) {
>                int mid = left + (right - left) / 2;
>                if (nums[mid] > nums[right]) left = mid + 1;
>                else right = mid;
>            }
>            return left;
>        }
>    }
>```
>
>

## 34在排序数组中查找元素的第一个和最后一个位置

>```java
>//做两次二分搜索，一次搜最早一次搜最晚合并结果
>class Solution {
>    public int[] searchRange(int[] nums, int target) {
>        if(nums.length==0)return new int[]{-1,-1};
>		int start=-1,end=-1;
>		int left=0,right=nums.length-1;
>		while(left<=right){
>			int mid=left+(right-left)/2;
>			if(nums[mid]<target)left=mid+1;
>			else right=mid-1;
>		}
>		if(left<=nums.length-1&&nums[left]==target)start=left;
>		left=0;
>		right=nums.length-1;
>		while(left<=right){
>			int mid=left+(right-left)/2;
>			if(nums[mid]<=target)left=mid+1;
>			else right=mid-1;
>		}
>		if(right>=0&&nums[right]==target)end=right;
>		return new int[]{start,end};  
>    }
>}
>```
>
>

# 滑动窗口

## 无重复字符的最长子串

>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
>
>输入: s = "abcabcbb"
>输出: 3 
>解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
>思路：
>
>```java
>class Solution {
>    public int lengthOfLongestSubstring(String s) {
>       if(s.length()==0||s==null)return 0;
>        Map<Character,Integer> map=new HashMap<Character,Integer>();
>        int max=0;
>        int left=0;
>        for(int i=0;i<s.length();i++){
>          //如果窗口已经包含这个字母了，就将最左侧的指针划出到不包含这个字母的最远位置
>        	if(map.containsKey(s.charAt(i))){
>            	left=Math.max(map.get(s.charAt(i))+1,left); 
>          }  		      
>        	map.put(s.charAt(i), i);//每次更新每个字母的最新位置
>        	max=Math.max(max, i-left+1); //获取最新的长度
>        }
>        return max;
>}
>}
>```
>
>

# 位运算

# 递归&分治

## 理论

```
递归三要素
递归函数以及参数
递归终止条件
递归单层搜索逻辑

递归伪代码模版：
function recursion(level, param1, param2, ...) {
  //递归终止条件
  if (level > MAX_LEVEL) {
    // output result
    return;
  }
  //处理当前层
  process_data(level, data, ...);

  //进入下一层
  recursion(level + 1, p1, ...);

  //重置状态
  reverse_state(level);
}

分治伪代码模版：
function divide_conquer(problem, param1, param2, ...){
  if(problem === null){
    // return result
  }

  //分割问题
  subproblem = split_problem(problem, data)

  //计算子问题
  subResult1 = divide_conquer(subproblem[0], p1, ...)
  subResult2 = divide_conquer(subproblem[1], p1, ...)
  subResult3 = divide_conquer(subproblem[2], p1, ...)
  ...

  result = process_resule(subResult1, subResult2, subResult3,...)
}
```

## 124二叉树中的最大路径和

>输入：root = [-10,9,20,null,null,15,7]
>输出：42
>解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
>思路：每个节点维护一个“最大贡献值”，所谓最大贡献值是为了计算父节点选取该路径时能获得的最大值加成
>
>```java
>class Solution {
>		int maxSum = Integer.MIN_VALUE;
>
>    public int maxPathSum(TreeNode root) {
>        maxGain(root);
>        return maxSum;
>    }
>
>    public int maxGain(TreeNode node) {
>        if (node == null) {
>            return 0;
>        }
>        
>        // 递归计算左右子节点的最大贡献值, 只有在最大贡献值大于 0 时，才会选取对应子节点
>        int leftGain = Math.max(maxGain(node.left), 0);
>        int rightGain = Math.max(maxGain(node.right), 0);
>
>        // 计算通过该节点的最大路径和
>        int priceNewpath = node.val + leftGain + rightGain;
>
>        // 更新答案
>        maxSum = Math.max(maxSum, priceNewpath);
>
>        // 返回节点的最大贡献值，要么用左枝通过该节点，要么用右枝通过该节点
>        return node.val + Math.max(leftGain, rightGain);
>    }
>
>}
>```
>
>

# 单调栈

## 理论

```java
//所谓单调栈就是栈中元素是单调的
stack<int> st;
//此处一般需要给数组最后添加结束标志符
for (遍历这个数组)
{
	if (栈空 || 栈顶元素大于等于当前比较元素)
	{
		入栈;
	}
	else
	{
		while (栈不为空 && 栈顶元素小于当前元素)
		{
			栈顶元素出栈;
			更新结果;
		}
		当前数据入栈;
	}
}
```

## 84柱状图中最大矩形

>输入：heights = [2,1,5,6,2,3]
>输出：10
>解释：最大的矩形为5,6圈出来的，面积为 10
>
>```java
>class Solution {
>    public int largestRectangleArea(int[] heights) {
>        int n = heights.length;
>        int[] left = new int[n];
>        int[] right = new int[n];
>        
>        Deque<Integer> mono_stack = new ArrayDeque<Integer>();
>        //找出每一个柱子左边离他最近的最小的值
>        for (int i = 0; i < n; ++i) {
>            while (!mono_stack.isEmpty() && heights[mono_stack.peek()] >= heights[i]) {
>                mono_stack.pop();
>            }
>            left[i] = (mono_stack.isEmpty() ? -1 : mono_stack.peek());
>            mono_stack.push(i);
>        }
>
>        mono_stack.clear();
>        //找出每一个柱子左边离他最近的最小的值
>        for (int i = n - 1; i >= 0; --i) {
>            while (!mono_stack.isEmpty() && heights[mono_stack.peek()] >= heights[i]) {
>                mono_stack.pop();
>            }
>            right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());
>            mono_stack.push(i);
>        }
>        
>        int ans = 0;
>        for (int i = 0; i < n; ++i) {
>            //更新矩形的答案
>            ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);
>        }
>        return ans;
>    }
>}
>```
>
>

## 85最大矩形

>输入：matrix = [
>["1","0","1","0","0"],
>["1","0","1","1","1"],
>["1","1","1","1","1"],
>["1","0","0","1","0"]
>]
>输出：6
>解释：最大矩形为连续1组成的矩形。
>
>```java
>class Solution {
>    public int maximalRectangle(char[][] matrix) {
>        int m = matrix.length;
>        if (m == 0) {
>            return 0;
>        }
>        int n = matrix[0].length;
>        int maxArea = 0;
>        int[] heights = new int[n];         // 柱高
>        for (int row = 0; row < m; row++) {
>            // 一行一行遍历，保存柱高
>            // 一层一层遍历，保存柱高，相当于计算柱状图中的最大矩形
>            for (int col = 0; col < n; col++) {
>                if (matrix[row][col] == '1') {
>                    heights[col] += 1;
>                } else {
>                    heights[col] = 0;
>                }                          
>            }
>            maxArea = Math.max(maxArea, largestArea(heights));
>        }        
>        return maxArea;
>    }
>    // LeetCode 84
>    public int largestArea(int[] heights) {
>        int n = heights.length;
>        if (n == 0) {
>            return 0;
>        }
>
>        int[] left = new int[n];
>        int[] right = new int[n];
>        Arrays.fill(right, n);
>
>        Stack<Integer> stack = new Stack<>();
>        for (int i = 0; i < n; i++) {
>            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {
>                right[stack.peek()] = i;
>                stack.pop();
>            }
>            left[i] = stack.isEmpty() ? -1 : stack.peek();
>            stack.push(i);
>        }
>        int res = 0;
>        for (int i = 0; i < n; i++) {
>            res = Math.max(res, (right[i] - left[i] - 1) * heights[i]);
>        }
>        return res;
>    }
>}
>```
>
>

## 239滑动窗口最大值

>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
>输出：[3,3,5,5,6,7]
>解释：
>滑动窗口的位置                最大值
>
>---------------               -----
>[1  3  -1] -3  5  3  6  7       3
> 1 [3  -1  -3] 5  3  6  7       3
> 1  3 [-1  -3  5] 3  6  7       5
> 1  3  -1 [-3  5  3] 6  7       5
> 1  3  -1  -3 [5  3  6] 7       6
> 1  3  -1  -3  5 [3  6  7]      7
>
>```java
>class Solution {
>    public int[] maxSlidingWindow(int[] nums, int k) {
>        int n = nums.length;
>        Deque<Integer> deque = new LinkedList<Integer>();
>        for (int i = 0; i < k; ++i) {
>            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
>                deque.pollLast();//加入一个比较大的值时，那些小的值都会被删除
>            }
>            deque.offerLast(i);
>        }
>
>        int[] ans = new int[n - k + 1];//存储结果
>        ans[0] = nums[deque.peekFirst()];
>        for (int i = k; i < n; ++i) {
>            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
>                deque.pollLast();//同上
>            }
>            deque.offerLast(i);
>            while (deque.peekFirst() <= i - k) {
>                deque.pollFirst();//如果已经不在窗口范围了，删除，注意栈顶的元素就是离当前最近的最小的元素
>            }
>            ans[i - k + 1] = nums[deque.peekFirst()];
>        }
>        return ans;
>    }
>}
>```
>
>

# set&map

## 两数之和

>每次将sum-nums[i]放入一个map，如果已有说明符合

## 两数之和II

>有序数组
>
>```java
>class Solution {
>    public ListNode removeNthFromEnd(ListNode head, int n) {
>        ListNode start=new ListNode(-1);
>        start.next=head;
>        ListNode fast=start;
>        ListNode slow=start;
>        int index=1;
>        while(index<=n){
>            fast=fast.next;
>            index+=1;
>        }
>        while(fast.next!=null){
>            fast=fast.next;
>            slow=slow.next;
>        }
>        slow.next=slow.next.next;
>        return start.next;
>    }
>}
>```
>
>

## 三数之和

>```java
>class Solution {
>    public List<List<Integer>> threeSum(int[] nums) {
>      List<List<Integer>> res=new ArrayList<List<Integer>>();
>      Arrays.sort(nums);
>      for(int i=0;i<nums.length-2;i++){
>        if(nums[i]>0)break;
>        if(i==0||(i>0&&nums[i]!=nums[i-1])){
>          //从这个数的右边、最后一个数开始双指针查找
>          int left=i+1,right=nums.length-1,sum=-nums[i];
>          while(left<right){
>            if(nums[left]+nums[right]==sum){
>                res.add(Arrays.asList(nums[i],nums[left],nums[right]));
>                while(left<right&&nums[left++]==nums[left]);
>                while(left<right&&nums[right--]==nums[right]);
>            }
>                 else if(nums[left]+nums[right]>sum)right--;
>                 else left++;
>          }
>        }
>      }
>      return res;
>    }
>}
>```
>
>

## 最长连续序列

>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
>
>示例 1：
>
>输入：nums = [100,4,200,1,3,2]
>输出：4
>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
>
>```java
>class Solution {
>    public int longestConsecutive(int[] nums) {
>        Set<Integer> num_set = new HashSet<Integer>();
>        for (int num : nums) {
>            num_set.add(num);
>        }
>
>        int longestStreak = 0;
>
>        for (int num : num_set) {
>            if (!num_set.contains(num - 1)) {
>                int currentNum = num;
>                int currentStreak = 1;
>
>                while (num_set.contains(currentNum + 1)) {
>                    currentNum += 1;
>                    currentStreak += 1;
>                }
>
>                longestStreak = Math.max(longestStreak, currentStreak);
>            }
>        }
>
>        return longestStreak;
>    }
>}
>```
>
>

# 栈&队列

## 有效的括号

>使用栈的入栈出栈模拟即可
>
>```java
>class Solution {
>    public boolean isValid(String s) {
>        Stack<Character> stack=new Stack<Character>();
>        for(char c:s.toCharArray()){
>        if(c=='(')
>        	stack.push(')');
>        else if(c=='[')
>        	stack.push(']');
>        else if(c=='{')
>        	stack.push('}');
>        else if(stack.isEmpty()||stack.pop()!=c)
>        	return false;
>        }
>        return stack.isEmpty();
>    }
>}
>```
>
>



# 数组 & 矩阵

## 下一个排列

>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。
>
>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
>
>思路：能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：
>
>1. 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。
>2. 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。
>3. 4,5,2,6,3,1->找出2,3->4,5,3,6,2,1(交换)->4,5,3,1,2,6(重排)
>
>```java
>class Solution {
>    public void nextPermutation(int[] nums) {
>		int place=0;
>        for(int i=nums.length-2;i>=0;i--)
>        	if(nums[i]<nums[i+1]){
>        		place=i;//找出较小数的位置
>        		break;
>        	}
>        swap(place,nums);
>        //重排
>        Arrays.sort(nums,place+1,nums.length);
>    }
>	public void swap(int place,int[] nums){
>		int pos=nums.length-1,min=Integer.MAX_VALUE;
>		for(int i=nums.length-1;i>=place;i--)//在较小数的右侧找出大于较小数最小值
>			if(nums[i]<min&&nums[i]>nums[place]){
>				min=nums[i];
>				pos=i;
>			}
>     //交换较小数与较大数
>			int temp=nums[place];
>			nums[place]=nums[pos];
>			nums[pos]=temp;		
>	}
>}
>```
>
>

## 除自身以外数组的乘积

>输入: nums = [1,2,3,4]
>输出: [24,12,8,6]
>
>```java
>class Solution {
>    public int[] productExceptSelf(int[] nums) {
>        int length = nums.length;
>        int[] answer = new int[length];
>
>        // answer[i] 表示索引 i 左侧所有元素的乘积
>        // 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1
>        answer[0] = 1;
>        for (int i = 1; i < length; i++) {
>            answer[i] = nums[i - 1] * answer[i - 1];
>        }
>
>        // R 为右侧所有元素的乘积
>        // 刚开始右边没有元素，所以 R = 1
>        int R = 1;
>        for (int i = length - 1; i >= 0; i--) {
>            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
>            answer[i] = answer[i] * R;
>            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
>            R *= nums[i];
>        }
>        return answer;
>    }
>}
>```
>
>

## 169多数元素

>给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。采用投票算法解决。
>
>```java
>//使用投票算法
>class Solution {
>    public int majorityElement(int[] nums) {
>        int temp=nums[0];
>	int count=0;
>	for(int i=0;i<nums.length;i++){
>		if(count==0){
>			count=1;
>			temp=nums[i];
>		}
>		else if(nums[i]!=temp){
>			count--;
>		}
>		else 
>			count++;
>	}
>	return temp;   
>    }
>}
>```
>
>

## 283移动零

>把零移到一起
>
>```java
>class Solution {
>    public void moveZeroes(int[] nums) {
>        int left = 0, right = 0;
>        while (right < nums.length) {
>            if (nums[right] != 0) {
>                swap(nums, left, right);
>                left++;
>            }
>            right++;
>        }
>        System.out.println(Arrays.toString(nums));
>    }
>
>    public void swap(int[] nums, int i, int j) {
>        int temp = nums[i];
>        nums[i] = nums[j];
>        nums[j] = temp;
>    }
>}
>```
>
>

## 缺失数字

>输入：nums = [9,6,4,2,3,5,7,0,1]
>输出：8
>
>将这些数字分别与从1到n做个异或，存在的会被异或抵消
>
>```java
>class Solution {
>    public int missingNumber(int[] nums) {
>        int result=0;
>       for(int i=0;i<nums.length;i++){
>    	  result^=i;
>    	  result^=nums[i];
>       }
>       return result^nums.length;
>    }
>}
>```
>
>所有缺失的数字
>
>输入：nums = [4,3,2,7,8,2,3,1]
>输出：[5,6]
>
>```java
>class Solution {
>    public List<Integer> findDisappearedNumbers(int[] nums) {
>        List<Integer> result=new ArrayList<Integer>();
>		for(int i=0;i<nums.length;i++)
>			if(nums[Math.abs(nums[i])-1]>0)
>			   nums[Math.abs(nums[i])-1]=-nums[Math.abs(nums[i])-1];
>		for(int i=0;i<nums.length;i++)
>			if(nums[i]>0)
>			    result.add(i+1);
>		return result;	
>    }
>}
>```
>
>

## 重复数字

>把每个数字换到对应的位置上，给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。
>
>```java
>class Solution {
>    public int findRepeatNumber(int[] nums) {
>        for(int i=0;i<nums.length;i++){
>            while(i!=nums[i]){
>                if(nums[i]==nums[nums[i]]){
>                    return nums[i];
>                }
>                swap(nums, nums[i], i);
>            }
>        }
>        return -1;
>    }
>
>    private void swap(int[] nums, int i, int j) {
>        int temp = nums[i];
>        nums[i] = nums[j];
>        nums[j] = temp;
>    }
>}
>```
>
>

# 字符串

## 回文字符串

- [[LeetCode\] 9. Palindrome Number 验证回文数字](https://www.cnblogs.com/grandyang/p/4125510.html)

  - 121是一个回文数字，-121不是，给定一个数字判断是否是回文数字，而且不允许转字符串

  - 思路：求出位数，然后通过斜杠求除法，%求余数，依次对比

    ```java
    public boolean isPalindrome(int x) {
            if(x<0) return false;
            int n=1;
            while(x/n>10){//求那么多位数的0
                n*=10;
            }
            while(x>0){
                int low=x%10;//低位
                int high=x/n;//高位
                if(low!=high)return false;
                x=(x%n)/10;//剥离前后位
                n=n/100;//剥离两个0
            }
            return true;
    }
    ```

- [LeetCode\] Valid Palindrome 验证回文字符串](https://www.cnblogs.com/grandyang/p/4030114.html)

  - "A man, a plan, a canal: Panama"是回文字符串`"race a car"` 不是回文字符串
  - 给定一个字符串，判断是否为回文字符串
  - 使用双指针，遇到不是字符串的跳过即可-

## 压缩字符串

>输入："aabcccccaaa"
>输出："a2b1c5a3"
>
>```java
>class Solution {
>    public String compressString(String S) {
>        int index = 0;
>        char c;
>        String res = "";
>        while (index < S.length()) {
>            int count = 0;
>            c=S.charAt(index);
>            while (index<S.length() && c == S.charAt(index)) {
>                count++;
>                index++;
>            }
>            res += String.valueOf(c) + count;
>        }
>        return S.length() > res.length() ? res : S;
>    }
>}
>```
>
>

# 字典树

## 208实现Trie

>输入
>["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
>[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
>输出
>[null, null, true, false, true, null, true]
>
>解释
>Trie trie = new Trie();
>trie.insert("apple");
>trie.search("apple");   // 返回 True
>trie.search("app");     // 返回 False
>trie.startsWith("app"); // 返回 True
>trie.insert("app");
>trie.search("app");     // 返回 True
>
>```java
>class Trie {
>    private Trie[] children;
>    private boolean isEnd;
>
>    public Trie() {
>        children = new Trie[26];
>        isEnd = false;
>    }
>    
>    public void insert(String word) {
>        Trie node = this;
>        for (int i = 0; i < word.length(); i++) {
>            char ch = word.charAt(i);
>            int index = ch - 'a';
>            if (node.children[index] == null) {
>                node.children[index] = new Trie();
>            }
>            node = node.children[index];
>        }
>        node.isEnd = true;
>    }
>    
>    public boolean search(String word) {
>        Trie node = searchPrefix(word);
>        return node != null && node.isEnd;
>    }
>    
>    public boolean startsWith(String prefix) {
>        return searchPrefix(prefix) != null;
>    }
>
>    private Trie searchPrefix(String prefix) {
>        Trie node = this;
>        for (int i = 0; i < prefix.length(); i++) {
>            char ch = prefix.charAt(i);
>            int index = ch - 'a';
>            if (node.children[index] == null) {
>                return null;
>            }
>            node = node.children[index];
>        }
>        return node;
>    }
>```
>
>

# 并查集&拓扑排序

## 207课程表

>输入：numCourses = 2, prerequisites = [[1,0]]
>输出：true
>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
>
>```java
>public class Solution {
>    List<List<Integer>> edges;
>    int[] indeg;
>    public boolean canFinish(int numCourses, int[][] prerequisites) {
>        edges = new ArrayList<>();
>        for (int i = 0; i < numCourses; ++i) {
>            edges.add(new ArrayList<>());
>        }
>        indeg = new int[numCourses];
>        for (int[] info : prerequisites) {
>            edges.get(info[1]).add(info[0]);//每个节点指向的所有节点
>            ++indeg[info[0]];//每个节点的入度，需要先修的课程入度加1
>        }
>
>        Queue<Integer> queue = new LinkedList<>();
>        for (int i = 0; i < numCourses; ++i) {
>            if (indeg[i] == 0) {
>                queue.offer(i);//把那些入度是0的放入队列里
>            }
>        }
>
>        int visited = 0;
>        while (!queue.isEmpty()) {
>            ++visited;//从队列里拿出一个节点
>            int u = queue.poll();
>            //拿走这个节点以后，它指向的节点各减去一个入度
>            for (int v: edges.get(u)) {
>                --indeg[v];
>                //减完以后，如果入度是0就放入队列
>                if (indeg[v] == 0) {
>                    queue.offer(v);
>                }
>            }
>        }
>
>        return visited == numCourses;
>    }
>```
>
>

399除法求值

>输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
>输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
>解释：
>条件：a / b = 2.0, b / c = 3.0
>问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
>结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
>
>```java
>public class Solution {
>    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
>        int equationsSize = equations.size();
>
>        UnionFind unionFind = new UnionFind(2 * equationsSize);
>        /*System.out.println(unionFind);
>        Solution.UnionFind(parent=[0, 1, 2, 3], weight=[1.0, 1.0, 1.0, 1.0])
>        */
>        // 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码
>        Map<String, Integer> hashMap = new HashMap<>(2 * equationsSize);
>        int id = 0;
>        for (int i = 0; i < equationsSize; i++) {
>            List<String> equation = equations.get(i);
>            String var1 = equation.get(0);
>            String var2 = equation.get(1);
>
>            if (!hashMap.containsKey(var1)) {
>                hashMap.put(var1, id);
>                id++;
>            }
>            if (!hashMap.containsKey(var2)) {
>                hashMap.put(var2, id);
>                id++;
>            }
>            unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);
>        }
>        /*System.out.println(unionFind);
>        Solution.UnionFind(parent=[1, 2, 2, 3], weight=[2.0, 3.0, 1.0, 1.0])
>        */
>
>        // 第 2 步：做查询
>        int queriesSize = queries.size();
>        double[] res = new double[queriesSize];
>        for (int i = 0; i < queriesSize; i++) {
>            String var1 = queries.get(i).get(0);
>            String var2 = queries.get(i).get(1);
>
>            Integer id1 = hashMap.get(var1);
>            Integer id2 = hashMap.get(var2);
>
>            if (id1 == null || id2 == null) {
>                res[i] = -1.0d;
>            } else {
>                res[i] = unionFind.isConnected(id1, id2);
>            }
>        }
>        /*System.out.println(unionFind);
>        Solution.UnionFind(parent=[2, 2, 2, 3], weight=[6.0, 3.0, 1.0, 1.0])
>        */
>        return res;
>    }
>
>    @Data
>    private class UnionFind {
>
>        private int[] parent;
>
>        /**
>         * 指向的父结点的权值
>         */
>        private double[] weight;
>
>
>        public UnionFind(int n) {
>            this.parent = new int[n];
>            this.weight = new double[n];
>            for (int i = 0; i < n; i++) {
>                parent[i] = i;
>                weight[i] = 1.0d;
>            }
>        }
>
>        public void union(int x, int y, double value) {
>            int rootX = find(x);
>            int rootY = find(y);
>            if (rootX == rootY) {
>                return;
>            }
>
>            parent[rootX] = rootY;
>            weight[rootX] = weight[y] * value / weight[x];
>        }
>
>        /**
>         * 路径压缩
>         *
>         * @param x
>         * @return 根结点的 id
>         */
>        public int find(int x) {
>            if (x != parent[x]) {
>                int origin = parent[x];
>                parent[x] = find(parent[x]);
>                weight[x] *= weight[origin];
>            }
>            return parent[x];
>        }
>
>        public double isConnected(int x, int y) {
>            int rootX = find(x);
>            int rootY = find(y);
>            if (rootX == rootY) {
>                return weight[x] / weight[y];
>            } else {
>                return -1.0d;
>            }
>        }
>    }
>
>    public static void main(String[] args) {
>        List<List<String>> equations = List.of(List.of("a", "b"), List.of("b", "c"));
>        double[] values=new double[]{2.0,3.0};
>        List<List<String>> queries = List.of(List.of("a", "c"), List.of("b", "a"), List.of("a", "e"), List.of("a", "a"), List.of("x", "x"));
>        Solution solution = new Solution();
>        System.out.println(Arrays.toString(solution.calcEquation(equations, values, queries)));
>    }
>}
>
>```
>
>

# 其他类型题

# 排序

| 排序算法 | 时间复杂度 | 稳定性 |
| -------- | ---------- | ------ |
| 冒泡     | O(n^2)     | 稳定   |
| 选择     | O(n^2)     | 不稳定 |
| 插入     | O(n^2)     | 稳定   |
| 希尔     | O(nlogn)   | 不稳定 |
| 归并     | O(nlogn)   | 稳定   |
| 快排     | O(nlogn)   | 不稳定 |
| 堆排     | O(nlogn)   | 不稳定 |
| 计数     | O(n+k)     | 稳定   |
| 桶排     | O(n+k)     | 稳定   |
| 基数     | O(n+k)     | 稳定   |



## 快排

```java
public class QuickSort {
	public int partition(int nums[],int low,int high){
		int temp=nums[low];
		while(low<high){
			while(low<high&&nums[high]>=temp)high--;//元素全相同，必须保留一个等号，保证指针能移动下去
			nums[low]=nums[high];
			while(low<high&&nums[low]<temp)low++;
			nums[high]=nums[low];
		}
		nums[low]=temp;
		return low;
	}

	public void quickSort(int nums[],int low,int high){
		if(low<high){
			int pivoloc=partition(nums, low, high);
			quickSort(nums, low, pivoloc-1);
			quickSort(nums, pivoloc+1, high);
		}
	}

	public int[] quickSort(int nums[]){
		quickSort(nums,0,nums.length-1);
		return nums;
	}
}
```

```java
/*利用快排，找出元素的前k个小的值和第k小的值
 **/
public static int kthMin3(int[] nums,int left,int right,int k){
        int pivot=partion(nums, left, right);
        if(pivot==k-1)return pivot;
        else if(pivot>k-1)
        return kthMin3(nums, left, pivot-1, k);
        else
        return kthMin3(nums, pivot+1, right, k);
        }

public static int kthMin3(int[] nums,int k){
        return nums[kthMin3(nums, 0, nums.length-1, k)];
        }

public static void topKMin3(int[] nums,int k){
        kthMin3(nums, 0, nums.length-1, k);
        }
```

## 堆排

```java
//调节堆，从i到length进行调节，调节完以后i节点到length-1节点就是堆，在[i...length-1]上只有i不满足堆的定义
	public void adjustHeap(int nums[],int i,int length){//数组，以i节点为根开始调节，数组长度
		int temp=nums[i];
		for(int k=2*i+1;k<length;k=k*2+1){//以i节点的左节点开始比较
			if(k+1<length&&nums[k]<nums[k+1])//K+1是i节点的右节点，它俩哪个大k就取哪个
				k++;
			if(nums[k]>temp){//如果左右节点较大的那个值比原始的根大，一直替换下去
				nums[i]=nums[k];//左右节点较大的那个值换掉根，但是那个节点值不必变
				i=k;//由于i节点取了k节点的值，往子节点跳一层继续比较
				}else {//没调节直接结束了
				break;
			}
		}
		nums[i]=temp;//最后把那个值用根补上
	}
	public int[] heapSort(int nums[]){
		for(int i=nums.length/2-1;i>=0;i--) {//从最后一个非叶子节点开始调节，nums[nums.length/2-1]是最后一个非叶子节点
			adjustHeap(nums, i, nums.length);
		}
		for(int j=nums.length-1;j>0;j--){
			su.swap(nums, 0, j);
			adjustHeap(nums, 0, j);
		}
		return nums;	
	}
```

## 冒泡

```java
public class BubbleSort {
	SortUtil su=new SortUtil();
	//冒泡排序,它的外循环是排序的轮数，内循环是每一轮的相邻数据的两两比较
	//时间复杂度是o(n^2),空间复杂度是O(1)
	public int[] bubbleSort(int[] nums){
		for(int i=0;i<nums.length-1;i++)
			for(int j=0;j<nums.length-i-1;j++)
				if(nums[j]>nums[j+1])//稳定
				    su.swap(nums,j,j+1);
		return nums;	
	}

	//改进的冒泡排序算法，改进之处在于如果某一轮没有发生过交换，那么就是后边的都有序了，就不需要再排了
	//时间复杂度是o(n^2),空间复杂度是O(1)
	public int[] improvedBubbleSort(int[] nums){
		for(int i=0;i<nums.length-1;i++){
			boolean flag=true;
			for(int j=0;j<nums.length-i-1;j++)
				if(nums[j]>nums[j+1]){//稳定
				    su.swap(nums,j,j+1);
				    flag=false;
				}
			if(flag)
			   break;
		}
		return nums;	
	}
}
```

## 插入

```java
public class InsertSort {
	SortUtil su=new SortUtil();
	//插入排序算法，外层循环仍然是排序的轮数，内层循环是插入的过程
	//时间复杂度是o(n^2),空间复杂度是O(1)
	public int[] insertSort(int[] nums){
		for(int i=1;i<nums.length;i++){
			int j=i;
			while(j>0&&nums[j]<nums[j-1]){//稳定
				su.swap(nums, j, j-1);
				j--;
			}
		}		
		return nums;	
	}

	//改进的排序插入算法，在寻找插入位置的过程中使用二分查找
	public int[] improvedInsertSort(int[] nums){
		for(int i=1;i<nums.length;i++){
			int temp=nums[i];
			int left=0,right=i-1;
			while(left<=right){
				int mid=left+(right-left)/2;
				if(nums[mid]<=temp)
					left=mid+1;
				else 
					right=mid-1;
			}
			for(int j=i;j>right+1;j--)
				nums[j]=nums[j-1];
			nums[right+1]=temp;
		}	
		return nums;	
	}
}
```

## 归并

```java
public class MergeSort {
	//归并排序
	public void merge(int nums[],int left,int mid,int right,int temp[]){
		int i = left;
	    int j = mid+1;
	    int t = 0;
	    while (i<=mid && j<=right){
	        if(nums[i]<=nums[j]){
	            temp[t++] = nums[i++];
	        }else {
	            temp[t++] = nums[j++];
	        }
	    }
	    while(i<=mid){
	        temp[t++] = nums[i++];
	    }
	    while(j<=right){
	        temp[t++] = nums[j++];
	    }
	    t = 0;
	    while(left <= right){
	       nums[left++] = temp[t++];
	    }
	}

	public void mergeSort(int nums[],int left,int right,int []temp){
		 if(left<right){
	         int mid = (left+right)/2;
	         mergeSort(nums,left,mid,temp);
	         mergeSort(nums,mid+1,right,temp);
	         merge(nums,left,mid,right,temp);
	     }	
	}

	public int[] mergeSort(int nums[]){
		int[] temp = new int[nums.length];
	    mergeSort(nums,0,nums.length-1,temp);
	    return  nums;
	}
}
```

## 希尔

```java
public class ShellSort {
	SortUtil su=new SortUtil();
	//希尔排序
	public int[] shellSort(int nums[]){
		for(int gap=nums.length/2;gap>0;gap/=2){
			for(int i=gap;i<nums.length;i++){
				int j=i;
				while(j-gap>=0&&nums[j-gap]>nums[j]){
					su.swap(nums,j-gap,j);
					j-=gap;
				}
			}
		}
		return nums;	
	}
}
```

## 基数

```java
public class RadixSort {
	//基数排序
	public void radixHelp(int[] a, int exp) {
	    int[] output = new int[a.length];   
	    int[] buckets = new int[10];

	    for (int i = 0; i < a.length; i++)
	        buckets[ (a[i]/exp)%10 ]++;

	    for (int i = 1; i < 10; i++)
	        buckets[i] += buckets[i - 1];

	    for (int i = a.length - 1; i >= 0; i--) {
	        output[buckets[ (a[i]/exp)%10 ] - 1] = a[i];
	        buckets[ (a[i]/exp)%10 ]--;
	    }

	    for (int i = 0; i < a.length; i++)
	        a[i] = output[i];
	}
	
	public int[] radixSort(int nums[]){
		int exp; 
		int max = nums[0]; 
		for(int i=0;i<nums.length;i++)
			max=Math.max(nums[i], max);
	    for (exp = 1; max/exp > 0; exp *= 10)
	    	radixHelp(nums, exp);
		return nums;
	}
}
```

## 选择

```java
public class SelectSort {
	SortUtil su=new SortUtil();
	//选择排序算法，它的外循环是轮数，也可以说是一次从前到后为每一位选择值，内循环是选取这个值的过程
	//时间复杂度是o(n^2),空间复杂度是O(1)
	public int[] selectSort(int[] nums){
	    for(int i=0;i<nums.length-1;i++){
	    	int min=i;
	    	for(int j=i+1;j<nums.length;j++)
	    		if(nums[j]<nums[min])//不稳定，其不稳定如5 8 5 2 9
	    			min=j;
	    	if(min!=i)
	    	  su.swap(nums, i, min);
	    }
		return nums;	
	}
}
```

## 计数

```java
public class CountSort {
	//计数排序,适用于已经知道最大值与最小值并且二者差距不大，比如班级成绩，人们年龄等
	public int[] countSort(int nums[],int max,int min){
		int[] count=new int[max-min+1];
		for(int i=0;i<nums.length;i++){
			count[nums[i]-min]++;
		}
		int index=0;
		for(int i=0;i<count.length;i++)
			while(count[i]-->0)
				nums[index++]=i+min;
		return nums;	
	}
}
```

## 桶排

```java
public class BucketSort {
	//桶排序，适用于差距大，但是分布均匀的数字
	public int[] bucketSort(int nums[],int max,int min){
		int bucketNum=(max-min)/nums.length+1;
		List<List<Integer>> bucketArr = new ArrayList<>(bucketNum);
	    for(int i = 0; i < bucketNum; i++){
	        bucketArr.add(new ArrayList<Integer>());
	    }

	    for(int i = 0; i < nums.length; i++){
	        int num = (nums[i] - min) / (nums.length);
	        bucketArr.get(num).add(nums[i]);
	    }
	    
	    int index=0;
	    for(int i = 0; i < bucketArr.size(); i++){
	        Collections.sort(bucketArr.get(i));
	        for(int j = 0; j < bucketArr.get(i).size(); j++)
	        	nums[index++]=bucketArr.get(i).get(j);
	    }
		return nums;	
	}
}
```

## TOPK

```java
//使用java提供的优先队列
import java.util.PriorityQueue;

public class TopKMin {
	public static int[] topKMin(int[] nums,int k){
		int[] res=new int[k];
		//大根堆
		PriorityQueue<Integer> pq=new PriorityQueue<Integer>((o1, o2) -> o2-o1);
		for(int num:nums){
			pq.add(num);
			if(pq.size()>k)
				//往出弹大的值
				pq.poll();
		}
		int i=0;
        while(i<k)
        	res[i++]=pq.poll();
		return res;		
	}
	
	public static int kthMin(int[] nums,int k){
		PriorityQueue<Integer> pq=new PriorityQueue<Integer>((o1, o2) -> o2-o1);
		for(int num:nums){
			pq.add(num);
			if(pq.size()>k)
				pq.poll();
		}
		//弹完大的值，剩下堆顶的那个值就是第k小的
		return (int)(pq.toArray()[0]);
	}
	
	public static void main(String[] args){
		int[] test=new int[]{1,3,5,7,9,2,4,6,8,0};
		int[] res=topKMin(test, 3);
		for(int i:res)
			System.out.println(i);
		System.out.println(kthMin(test, 3));
	}
}
```

```java
//构建堆
public class TopKMin2 {
	//假设除了i位置，别的都满足大根堆的定义，现在调节大根堆
	public static void adjust(int[] nums,int i,int length){
		int temp=nums[i];
		for(int k=2*i+1;k<length;k=k*2+1){
			if(k+1<length&&nums[k]<nums[k+1])
				k++;
			if(temp<nums[k]){
				nums[i]=nums[k];
				i=k;
			}else
				break;		
		}
		nums[i]=temp;
	}
	
	public static void topKMin2(int[] nums,int k){
		for(int i=k/2-1;i>=0;i--)
			adjust(nums, i, k);//先调节一个大根堆
		for(int i=k;i<nums.length;i++){//新来的比根小就替换
			if(nums[i]<nums[0]){
				nums[0]=nums[i];
				adjust(nums, 0, k);
			}	
		}
	}
	
	//只要来的比根上的小，就换掉根，然后调节
	public static int kthMin2(int[] nums,int k){
		for(int i=k/2-1;i>=0;i--)
			adjust(nums, i, k);//先调节一个大根堆
		for(int i=k;i<nums.length;i++){//新来的比根小就替换
			if(nums[i]<nums[0]){
				nums[0]=nums[i];
				adjust(nums, 0, k);
			}	
		}
		return nums[0];
	}
	
	public static void main(String[] args){
		int[] test=new int[]{1,3,5,7,9,2,4,6,8,0};		
		System.out.println(kthMin2(test, 3));
		for(int i=0;i<3;i++)
			System.out.println(test[i]);
	}
}
```

```java
//利用快排
public class TopKMin3 {
	public static int partion(int[] nums,int left,int right){
		int temp=nums[left];
		while(left<right){
		while(left<right&&nums[right]>=temp)right--;
		  nums[left]=nums[right];
		while(left<right&&nums[left]<temp)left++;
		  nums[right]=nums[left];
		}
		nums[left]=temp;
		return left;
	}
	public static int kthMin3(int[] nums,int left,int right,int k){
		int pivot=partion(nums, left, right);
		if(pivot==k-1)return pivot;
		else if(pivot>k-1)
			return kthMin3(nums, left, pivot-1, k);
		else
			return kthMin3(nums, pivot+1, right, k);
	}

	public static int kthMin3(int[] nums,int k){
		return nums[kthMin3(nums, 0, nums.length-1, k)];
	}

	public static void topKMin3(int[] nums,int k){
		kthMin3(nums, 0, nums.length-1, k);
	}

	public static void main(String[] args){
		int[] test=new int[]{1,3,5,7,9,2,4,6,8,0};
		//将这个元素与原数组比较，自然可以找到前k个
		System.out.println(kthMin3(test, 6));
//		topKMin3(test,4);
//		for(int i=0;i<test.length;i++){
//			System.out.println(test[i]);
//		}
	}
}
```

# Top 100

[题目](https://leetcode.cn/problem-list/2cktkvj/)

```
easy：
1. 两数之和(hashmap)
20. 有效的括号(栈)
21. 合并两个有序链表(递归或者迭代)
70. 爬楼梯(菲波)
94. 二叉树的中序遍历(递归加迭代)
101. 对称二叉树(递归)
104. 二叉树的最大深度(迭代)
121. 买卖股票的最佳时机(贪心或者动归)
136. 只出现一次的数字(异或)
141. 环形链表(快慢指针)
160. 相交链表(双指针两次遍历)
169. 多数元素(投票算法)
206. 反转链表(递归或者迭代)
226. 翻转二叉树(递归或者迭代)
234. 回文链表(复制到数组或者快慢指针+翻转链表)
283. 移动零(双指针)
338. 比特位计数(动态规划) bits[i] = bits[i >> 1] + (i & 1);//偶数就是一半，奇数是一半+1
448. 找到所有数组中消失的数字(对对应位置赋负数，大于0的位置就是没有存在的负数)
461. 汉明距离(每次右移一位然后&1运算可判断低位是不是1，是的话加起来)
543. 二叉树的直径(递归或者迭代)
617. 合并二叉树(递归或者迭代)

medium:
2. 两数相加(链表迭代)
3. 无重复字符的最长子串(滑动窗口)
5. 最长回文子串(动态规划)
11. 盛最多水的容器(双指针)
15. 三数之和(排序+双指针)
17. 电话号码的字母组合(回溯)
19. 删除链表的倒数第 N 个结点(双指针)
22. 括号生成(回溯)
31. 下一个排列(两遍扫描)
33. 搜索旋转排序数组(自下而上自左而右)
34. 在排序数组中查找元素的第一个和最后一个位置(二分)
39. 组合总和(回溯)
46. 全排列(回溯)
48. 旋转图像(纯数学推导)
49. 字母异位词分组(单词排序+map)
53. 最大子数组和(动态规划)
55. 跳跃游戏(贪心)
56. 合并区间(数组排序)
62. 不同路径(动态规划)
64. 最小路径和(动态规划)
75. 颜色分类(双指针)
78. 子集(回溯)
79. 单词搜索(回溯)
96. 不同的二叉搜索树(动态规划+数学推导)
98. 验证二叉搜索树(递归验证)
102. 二叉树的层序遍历(广搜)
105. 从前序与中序遍历序列构造二叉树(递归构造)
114. 二叉树展开为链表(迭代)
128. 最长连续序列(哈希表)
139. 单词拆分(动态规划)
142. 环形链表II(双指针)
146. LRU缓存(借助linkedlist实现)
148. 排序链表(归并排序)
152. 乘积最大子数组(动态规划)
155. 最小栈(栈设计)
198. 打家劫舍(动态规划)
200. 岛屿数量(搜索)
207. 课程表(搜索)
208. 实现 Trie (前缀树)
215. 数组中的第K个最大元素(堆)
221. 最大正方形(动态规划)
236. 二叉树的最近公共祖先(递归)
238. 除自身以外数组的乘积(前缀和)
240. 搜索二维矩阵II(查找)
253. 会议室II(贪心)
279. 完全平方数(动态规划)
287. 寻找重复数(位运算)
300. 最长递增子序列(动态规划)
309. 最佳买卖股票时机含冷冻期(动态规划)
322. 零钱兑换(动态规划)
337. 打家劫舍III(树+动态规划)
347. 前 K 个高频元素(哈希表)
394. 字符串解码()
399. 除法求值(搜索)
406. 根据身高重建队列(贪心)
416. 分割等和子集(动态规划)
437. 路径总和III(搜索)
438. 找到字符串中所有字母异位词(哈希表)
494. 目标和(动态规划)
538. 把二叉搜索树转换为累加树(搜索)
560. 和为K的子数组()
581. 最短无序连续子数组(可能是升序排序)
621. 任务调度器(贪心)
647. 回文子串(动态规划)
739. 每日温度()

hard：
4. 寻找两个正序数组的中位数(二分)
10. 正则表达式匹配()动态规划
23. 合并K个升序链表(分治)
32. 最长有效括号(动态规划)
42. 接雨水(双指针)
72. 编辑距离(动态规划)
76. 最小覆盖子串(滑动窗口)
84. 柱状图中最大的矩形(单调栈)
85. 最大矩形(动态规划)
124. 二叉树中的最大路径和(动态规划)
239. 滑动窗口最大值(滑动窗口)
297. 二叉树的序列化与反序列化(搜索)
301. 删除无效的括号(回溯)
312. 戳气球(动态规划)
```

![脑图](https://pic.leetcode-cn.com/1630892220-MyzuIE-阿飞算法.png)
