# IO

## 零拷贝

1. 四次拷贝与四次上下文切换

   <img src="https://s2.loli.net/2022/03/26/a2xDh1ZyvrHOIcM.png" alt="拷贝与切换" style="zoom:50%;" />

   以发送磁盘文件为例子

   - 发起read系统调用（用户态->内核态），CPU 负责将数据从磁盘搬运到内核空间的 Page Cache 中
   - read 系统调用完毕（内核态->用户态），CPU 负责将数据从内核空间的 Page Cache 搬运到用户空间的缓冲区
   - write 系统调用（用户态->内核态），CPU 负责将数据从用户空间的缓冲区搬运到内核空间的 Socket 缓冲区中
   - write 系统调用完毕（内核态->用户态）,CPU 负责将数据从内核空间的 Socket 缓冲区搬运到的网络中

2. DMA技术

   DMA 技术就是我们在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMAC）。 

   DMAC 有其局限性，DMAC 仅仅能用于设备间**交换数据时进行数据拷贝**，设备内部的数据拷贝还需要 CPU 来亲力亲为。例如， CPU 需要负责内核空间与用户空间之间的数据拷贝（内存内部的拷贝）。

   零拷贝的特点是 CPU 不全程负责内存中的数据写入其他组件，CPU 仅仅起到管理的作用。但注意，零拷贝不是不进行拷贝，而是 CPU 不再全程负责数据拷贝时的搬运工作。如果数据本身不在内存中，那么必须先通过某种方式拷贝到内存中（这个过程 CPU 可以仅仅负责管理，DMAC 来负责具体数据拷贝），因为数据只有在内存中，才能被转移，才能被 CPU 直接读取计算。

3. 零拷贝技术主要有以下几种方案

   >- sendfile
   >
   >  应用场景：**用户从磁盘读取一些文件数据后不需要经过任何计算与处理就通过网络传输出去**
   >
   >  典型应用是消息队列，sendfile主要用到了两个技术
   >
   >  - **利用 DMA 技术**
   >
   >    DMA 负责磁盘到内核空间中的 Page cache（read buffer）的数据拷贝以及从内核空间中的 socket buffer 到网卡的数据拷贝。
   >
   >  - **传递文件描述符代替数据拷贝**
   >
   >    传递文件描述可以代替数据拷贝，这是由于两个原因：
   >
   >    - page cache 以及 socket buffer 都在内核空间中；
   >    - 数据在传输中没有被更新；
   >
   >  **注意事项**：一些物理网卡不支持
   >
   >  由于 sendfile 仅仅对应一次系统调用，而传统文件操作则需要使用 read 以及 write 两个系统调用。
   >
   >  正因为如此，sendfile 能够将用户态与内核态之间的上下文切换从 4 次讲到 2 次。另一方面，我们需
   >
   >  要注意 sendfile 系统调用的局限性。如果应用程序需要对从磁盘读取的数据进行写操作，例如解密或
   >
   >  加密，那么 sendfile 系统调用就完全没法用。这是因为用户线程根本就不能够通过 sendfile 系统调用
   >
   >  得到传输的数据。
   >
   >- mmap
   >
   >  mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。
   >
   >- Direct I/O
   >
   >  在 Direct I/O 技术中，数据直接存储在用户空间中，绕过了内核。
   >
   >  **Direct I/O 的读写非常有特点：**
   >
   >  - Write 操作：由于其不使用 page cache，所以其进行写文件，如果返回成功，数据就真的落盘了（不考虑磁盘自带的缓存）；
   >  - Read 操作：由于其不使用 page cache，每次读操作是真的从磁盘中读取，不会从文件系统的缓存中读取。
   >
   >  **优点**
   >
   >  1. **降低系统级别的管理对应用程序访问数据的影响**。
   >  2. **高性能**。
   >
   >  **缺点**
   >
   >  1. 由于设备之间的数据传输是通过 DMA 完成的，因此**用户空间的数据缓冲区内存页必须进行 page pinning（页锁定）**，这是为了防止其物理页框地址被交换到磁盘或者被移动到新的地址而导致 DMA 去拷贝数据的时候在指定的地址找不到内存页从而引发缺页错误，而页锁定的开销并不比 CPU 拷贝小，所以为了避免频繁的页锁定系统调用，应用程序必须分配和注册一个持久的内存池，用于数据缓冲。
   >  2. 如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。
   >  3. 在应用层引入直接 I/O 需要应用层自己管理，这带来了额外的系统复杂性

   

   

   

     

