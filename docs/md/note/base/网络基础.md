## 物理层、数据链路层、网络层

1. 开始时，单机不与别的计算机连接
2. 两台计算机时，各开一个网口用线直连就可以通信
3. 三台、四台....n台计算机时，两两互联需要n*(n-1)/根线，而且单台计算机也开不了那么多口，此时发明了**集线器**，所有计算机连接到集线器上，集线器有很多口，每个口收到信号都广播出去，集线器在**物理层**上工作
4. 集线器转发给所有计算机信号，计算机怎么知道信息是不是发给自己的呢？需要一个唯一标识，发送端加上这个唯一标识，这个标识就是**mac地址**
5. 集线器解决了数据线混乱的问题，但是要给一台电脑发信息却要发给连接到集线器上的所有计算机，这样既不安全又不节省网络资源，需要进化一下，让集线器只发给目标mac地址指向的那台计算机，于是**交换机**诞生了，交换机在**数据链路层**工作，他有端口与mac地址的映射。
6. 这个小范围的网路就是**以太网**
7. 随着数量计算机数量越来越多，可以将其中一台交换机的一个端口连到另一台交换机B上，另一台交换机再连计算机，这样网络得到了扩充，但是要注意这个端口记录的是B上连着的全部计算的mac地址，而不是只有一条，这在几百台计算机的时候还好，但是计算机发展到几万、几十万时就有问题了
8. 要解决这个问题，需要将另一台交换机换成一个有mac地址的设备，于是**路由器**诞生了，路由器有mac地址还能转发数据，他在**网络层**工作，它的每一个端口都有mac地址
9. 什么时候将消息发给路由器呢？可以将一些固定前缀的机器映射到一个端口上，但是这就要求这些机器的网卡要基本一致但是这是不可能的，所以给每台机器分配一个**IP地址**，mac不可变但是IP可变。
10. 当要发送数据时，可以说**将 IP 地址为 192.168.0 开头的全部发送给到路由器**
11. 现在数据包包含了源mac,目标mac,源ip,目标ip,当机器在一个子网时，不转交路由器，否则转交路由器。
12. 计算机如何知道哪个设备是路由器呢？答案是默认**网关**，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。
13. 路由器收到消息以后，如何判断发给哪个端口呢？**路由表**
14. 如何根据IP获取mac地址呢？ARP

## 总结

**从各个节点的视角来看**

**电脑视角**：

- 首先我要知道我的 IP 以及对方的 IP
- 通过子网掩码判断我们是否在同一个子网
- 在同一个子网就通过 arp 获取对方 mac 地址直接扔出去
- 不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去

**交换机视角：**

- 我收到的数据包必须有目标 MAC 地址
- 通过 MAC 地址表查映射关系
- 查到了就按照映射关系从我的指定端口发出去
- 查不到就所有端口都发出去

**路由器视角：**

- 我收到的数据包必须有目标 IP 地址
- 通过路由表查映射关系
- 查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）
- 查不到则返回一个路由不可达的数据包

## 网络拓扑

**这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？**

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9HTGVoNDJ1SW5YUXg5RWlhV3dtRTBrYnk5OFFnNG5hRFV4MUpPengzRVVGWDY2eEZyRXp4dzlEYURobzZ0YjhwYVBraEl3WFRMRU5SSjV5VTB5N05vWXcvNjQw?x-oss-process=image/format,png)

**详细过程文字描述：**

根据这个拓扑，A给F发数据包的流程如下：

 首先 A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网内，于是决定发送给默认网关（192.168.0.254）

**2.** A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址。

**3.** A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9HTGVoNDJ1SW5YUzhwTndCNElycVBCT1ZpYk85Yk1XNjJzVHRMZ0dHWWZ6cGw1SngxSmFFakt5QUdmSzN6NjBwNEZKRWZoTmlhTDFqcXRhQlRLaWJHRDdpY1EvNjQw?x-oss-process=image/format,png)

**4.** 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器1

**5.** 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5

**6.** 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从 2 号口发出去。

**7.** 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从 1 号口把数据包送出去。

**8.** 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。

**9.** 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，发现应该从其 6 号端口出去，于是从 6 号端口把数据包发出去。

**10.** **F 最终收到了数据包！**并且发现目的 MAC 地址就是自己，于是收下了这个包

## 传输层

前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个**程序**（进程）呢？所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：**端口号**。

然后你在要发送的数据包上，增加了传输层的头部，**源端口号**与**目标端口号**。

![图解 | 你管这破玩意儿叫TCP？](https://img-blog.csdnimg.cn/img_convert/0d8ed6ecaeff0c48951469d5834b6869.png)

OK，这样你将原本主机到主机的通信，升级为了**进程和进程之间的通信**。你没有意识到，你不知不觉实现了 **UDP 协议**！

1. 由于网络的不可靠，数据包可能在半路丢失
   
   于是设计了如下方案，A 每发一个包，都必须收到来自 B 的**确认**（ACK），再发下一个，否则在一定时间内没有收到确认，就**重传**这个包。你管它叫**停止等待协议**。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，**可靠交付**。

2. 停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。

3. A 在发送的数据包中增加一个**序号**（seq），同时 B 要在 ACK 包上增加一个**确认号**（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫**累计确认**或**累计应答**。

4. 有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。怎么解决呢？
   
   很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的发送速率，就好了。B 怎么告诉 A 呢？每次发送数据包给 A 时，顺带传过来一个值，叫窗口大小（win)，这个值就表示 B 的接收能力。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。

5. B 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？
   
   很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。
   
   ![assa](https://img-blog.csdnimg.cn/img_convert/90c1e6c8f4b5d5cfbbb5aab777ae071e.png)

   当 A 不断发送数据包时，已发送的最后一个序号就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。而 B 在发给 A 的 ACK 包中，每一个都可以**重新设置**一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。

6. 但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了**网络拥塞**。
   
   拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受网络环境的影响。
   
   拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。
   
   但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过试探，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。

## 常见面试题

### 三次握手

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

**三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

### 四次挥手

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### 慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

### 快重传与快回复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

[HTTP相关](http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E4%B8%80-%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5) 

### 说说 HTTP 和HTTPS 的区别？

### 对称加密和非对称加密的区别和原理？

### 常见的状态码有哪些?

### HTTP header有哪些？

### Get和Post的区别？

### DNS寻址过程？

### 在浏览器中输入一个www.baidu.com后执行的全部过程？

> 域名解析 -> 建立TCP连接（三次握手）-> 发起http请求 -> 服务器响应http请求，浏览器得到html代码 -> 浏览器解析html代码，并请求html代码中的资源（如 js、css、图片等）-> 浏览器对页面进行渲染呈献给用户。

### Session、Cookie 的区别

### 有哪些 web 性能优化技术?

> - DNS查询优化
> - 客户端缓存
> - 优化TCP连接
> - 避免重定向
> - 网络边缘的缓存
> - 条件缓存
> - 压缩和代码极简化
> - 图片优化

### XSS与CSRF攻击
