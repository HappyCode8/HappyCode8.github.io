# Linux
## Linux常用命令

1. 查看占用了8080端口号的进程`lsof -i:8080`

2. 查看当前在哪个目录下`pwd`

3. `chmod a+x `文件 赋予文件可执行权限

4. 文件追加`cat 1.txt>>2.tx`

5. 文件覆盖`cat 1.txt>2.txt`

6. 文件清空`cat /dev/null>2.txt `

7. 查看某个关键字前几行后几行cat filename|grep '关键字' -A4(后四行) -B4(前四行)

8. 查看已删除空间却没有释放的进程`lsof -n / |grep deleted `

9. 在标准unix/linux下的grep命令中，通过以下参数控制上下文的显示

   grep -C 10 keyword catalina.out 显示file文件中匹配keyword字串那行以及上下10行

   grep -B 10 keyword catalina.out 显示keyword及前10行

   grep -A 10 keyword catalina.out 显示keyword及后10行

## 一段初始化JVM的脚本

```shell
#!/usr/bin/env bash

function init() {
    APP_KEY="com.sankuai.scoai.pallas"

    if [ -z "$LOG_PATH" ]; then  #如果LOG_PATH长度为0，拼接LOG_PATH
        LOG_PATH="/opt/logs/$APP_KEY"
    fi

    mkdir -p $LOG_PATH  #建立目录

    if [ -z "$WORK_PATH" ]; then  #如果WORK_PATH长度为0，拼接WORK_PATH
        WORK_PATH="/opt/meituan/$APP_KEY"
    fi

    JAVA_CMD="java"
    if ! command -v $JAVA_CMD >/dev/null 2>&1; then #如果不支持直接执行java命令，拼接JAVA_CMD
        JAVA_CMD="/usr/local/$JAVA_CMD/bin/java"
    fi

    JVM_ARGS="-server -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.net.preferIPv6Addresses=false"
    #-server 服务器模式
    #-Dfile.encoding java文件编码
    #-Dsun.jnu.encoding 操作系统默认编码

    if [ -z "$JVM_GC" ]; then
        JVM_GC="-XX:+UseG1GC -XX:G1HeapRegionSize=4M -XX:InitiatingHeapOccupancyPercent=40 -XX:MaxGCPauseMillis=100 -XX:+TieredCompilation -XX:CICompilerCount=4 -XX:-UseBiasedLocking -Xlog:gc*:$LOG_PATH/gc.log:time,uptime:filecount=20,filesize=50M"
    #-XX:+UseG1GC 使用G1垃圾回收器
    #-XX:G1HeapRegionSize=4M 堆内存中一个Region的大小可以通过-XX:G1HeapRegionSize参数指定，大小区间只能是1M、2M、4M、8M、16M和32M
    #-XX:InitiatingHeapOccupancyPercent 当老年代大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc(当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制
    #-XX:MaxGCPauseMillis=100 	设置G1收集过程目标时间
    #-XX:+TieredCompilation  这个参数主要用于是否开启JVM的分层编译
    #-XX:CICompilerCount 最大并行编译数
    #-XX:-UseBiasedLocking 不使用偏向锁
    #--Xlog:gc*:$LOG_PATH/gc.log:time,uptime:filecount=20,filesize=50M 指明GC日志存放位置[格式采用时间：到现在系统运行时间]，保留20个文件，每50M就轮换

    fi

    if [ -z "$JVM_EXT_ARGS" ]; then
        JVM_EXT_ARGS=""
    fi

    if [ -z "$JVM_HEAP" ]; then
        JVM_HEAP=`getJVMMemSizeOpt`
    fi
}


function run() {
    EXEC="exec"
    CONTEXT=/
    EXEC_JAVA="$EXEC $JAVA_CMD $JVM_ARGS $JVM_EXT_ARGS $JVM_HEAP $JVM_GC \
    -XX:ErrorFile=$LOG_PATH/vmerr.log \
    -XX:HeapDumpPath=$LOG_PATH/HeapDump"
    # -XX:ErrorFile系统奔溃时的日志
    # -XX:HeapDumpPath 堆快照路径

    if [ "$UID" = "0" ]; then
        ulimit -n 1024000 # 修改最大连接数
        umask 000 # 去掉权限
    else
        echo $EXEC_JAVA 
    fi
    cd $WORK_PATH
    pwd
    targetPackage=`find . -maxdepth 1 -type f \( -name "*.jar" -o -name "*.war" \)`
    #找到当前文件夹中的深度为1的类型为文件的name为jar或war的
    
    env=`getEnv`
    SPRING_ENV=""
    if [ -n "$env" ]; then
        SPRING_ENV="--spring.profiles.active=$env"
    fi
    
	echo "this target jar will be executed: "$targetPackage
    $EXEC_JAVA -jar $targetPackage $SPRING_ENV 2>&1
}

function getTotalMemSizeMb() {
	memsizeKb=`cat /proc/meminfo|grep MemTotal|awk '{print $2}'`
    if [ -z "$memsizeKb" ]; then
        memsizeKb=8*1000*1000
    fi
	memsizeMb=$(( $memsizeKb/1024 ))
	echo $memsizeMb
}

function outputJvmArgs() {
	jvmSize=$1
	MaxMetaspaceSize=$2
	ReservedCodeCacheSize=$3
	echo "-Xss512k -Xmx"$jvmSize" -Xms"$jvmSize" -XX:MetaspaceSize="$MaxMetaspaceSize" -XX:MaxMetaspaceSize="$MaxMetaspaceSize" -XX:+AlwaysPreTouch -XX:ReservedCodeCacheSize="$ReservedCodeCacheSize" -XX:+HeapDumpOnOutOfMemoryError "
}
# -Xss设置每个线程的堆栈大小
# -Xmx JVM最大可用内存
# -Xms JVM初始内存
# -XX:MetaspaceSize  设置metaspace区域的最大值
# -XX:+AlwaysPreTouch 启动的时候真实的分配物理内存给jvm
# -XX:ReservedCodeCacheSize 设置Code Cache大小，JIT编译的代码都放在Code Cache中，若Code Cache空间不足则JIT无法继续编译，并且会去优化，比如编译执行改为解释执行，由此，性能会降低
# -XX:+HeapDumpOnOutOfMemoryError 当堆内存空间溢出时输出堆的内存快照


function getJVMMemSizeOpt() {
	memsizeMb=`getTotalMemSizeMb`

	#公司的机器内存比实际标的数字要小，比如8G实际是7900M左右，一般误差小于1G
	#内存分级，单位兆/M
	let maxSize_lvl1=63*1024
	let maxSize_lvl2=31*1024
	let maxSize_lvl3=21*1024
	let maxSize_lvl4=15*1024
	let maxSize_lvl5=7*1024
	let maxSize_lvl6=3*1024
	let maxSize_lvl7=1024
	let maxSize_lvl8=512

	if [[ $memsizeMb -gt $maxSize_lvl1 ]]
	then
		jvmSize="32g"
		MaxMetaspaceSize="2g"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl2 && $memsizeMb -le $maxSize_lvl1 ]]
	then
		jvmSize="24g"
		MaxMetaspaceSize="1g"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl3 && $memsizeMb -le $maxSize_lvl2 ]]
	then
		jvmSize="18g"
		MaxMetaspaceSize="512m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl4 && $memsizeMb -le $maxSize_lvl3 ]]
	then
		jvmSize="12g"
		MaxMetaspaceSize="512m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl5 && $memsizeMb -le $maxSize_lvl4 ]]
	then
		jvmSize="4g"
		MaxMetaspaceSize="512m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl6 && $memsizeMb -le $maxSize_lvl5 ]]
	then
		jvmSize="2g"
		MaxMetaspaceSize="256m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl7 && $memsizeMb -le $maxSize_lvl6 ]]
	then
		jvmSize="1g"
		MaxMetaspaceSize="256m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl8 && $memsizeMb -le $maxSize_lvl7 ]]
	then
		jvmSize="512m"
		MaxMetaspaceSize="256m"
		ReservedCodeCacheSize="240m"
	fi

	if [ $memsizeMb -le $maxSize_lvl8 ]; then
		echo "service start fail:not enough memory for MDP service"
		exit 1
	fi
	outputJvmArgs $jvmSize $MaxMetaspaceSize $ReservedCodeCacheSize
	exit 0
}

function getEnv(){
    FILE_NAME="/data/webapps/appenv"
    PROP_KEY="env"
    PROP_VALUE=""
    if [[ -f "$FILE_NAME" ]]; then
        PROP_VALUE=`cat ${FILE_NAME} | grep -w ${PROP_KEY} | cut -d'=' -f2`
    fi
    echo $PROP_VALUE
}

init
run
```

