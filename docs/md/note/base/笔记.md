# Linux
## Linux常用命令

1. 查看占用了8080端口号的进程`lsof -i:8080`

2. 查看当前在哪个目录下`pwd`

3. `chmod a+x `文件 赋予文件可执行权限

4. 文件追加`cat 1.txt>>2.tx`

5. 文件覆盖`cat 1.txt>2.txt`

6. 文件清空`cat /dev/null>2.txt `

7. 查看某个关键字前几行后几行cat filename|grep '关键字' -A4(后四行) -B4(前四行)

8. 查看已删除空间却没有释放的进程`lsof -n / |grep deleted `

9. 在标准unix/linux下的grep命令中，通过以下参数控制上下文的显示

   grep -C 10 keyword catalina.out 显示file文件中匹配keyword字串那行以及上下10行

   grep -B 10 keyword catalina.out 显示keyword及前10行

   grep -A 10 keyword catalina.out 显示keyword及后10行

## 一段初始化JVM的脚本

```shell
#!/usr/bin/env bash

function init() {
    APP_KEY="com.sankuai.scoai.pallas"

    if [ -z "$LOG_PATH" ]; then  #如果LOG_PATH长度为0，拼接LOG_PATH
        LOG_PATH="/opt/logs/$APP_KEY"
    fi

    mkdir -p $LOG_PATH  #建立目录

    if [ -z "$WORK_PATH" ]; then  #如果WORK_PATH长度为0，拼接WORK_PATH
        WORK_PATH="/opt/meituan/$APP_KEY"
    fi

    JAVA_CMD="java"
    if ! command -v $JAVA_CMD >/dev/null 2>&1; then #如果不支持直接执行java命令，拼接JAVA_CMD
        JAVA_CMD="/usr/local/$JAVA_CMD/bin/java"
    fi

    JVM_ARGS="-server -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.net.preferIPv6Addresses=false"
    #-server 服务器模式
    #-Dfile.encoding java文件编码
    #-Dsun.jnu.encoding 操作系统默认编码

    if [ -z "$JVM_GC" ]; then
        JVM_GC="-XX:+UseG1GC -XX:G1HeapRegionSize=4M -XX:InitiatingHeapOccupancyPercent=40 -XX:MaxGCPauseMillis=100 -XX:+TieredCompilation -XX:CICompilerCount=4 -XX:-UseBiasedLocking -Xlog:gc*:$LOG_PATH/gc.log:time,uptime:filecount=20,filesize=50M"
    #-XX:+UseG1GC 使用G1垃圾回收器
    #-XX:G1HeapRegionSize=4M 堆内存中一个Region的大小可以通过-XX:G1HeapRegionSize参数指定，大小区间只能是1M、2M、4M、8M、16M和32M
    #-XX:InitiatingHeapOccupancyPercent 当老年代大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc(当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制
    #-XX:MaxGCPauseMillis=100 	设置G1收集过程目标时间
    #-XX:+TieredCompilation  这个参数主要用于是否开启JVM的分层编译
    #-XX:CICompilerCount 最大并行编译数
    #-XX:-UseBiasedLocking 不使用偏向锁
    #--Xlog:gc*:$LOG_PATH/gc.log:time,uptime:filecount=20,filesize=50M 指明GC日志存放位置[格式采用时间：到现在系统运行时间]，保留20个文件，每50M就轮换

    fi

    if [ -z "$JVM_EXT_ARGS" ]; then
        JVM_EXT_ARGS=""
    fi

    if [ -z "$JVM_HEAP" ]; then
        JVM_HEAP=`getJVMMemSizeOpt`
    fi
}


function run() {
    EXEC="exec"
    CONTEXT=/
    EXEC_JAVA="$EXEC $JAVA_CMD $JVM_ARGS $JVM_EXT_ARGS $JVM_HEAP $JVM_GC \
    -XX:ErrorFile=$LOG_PATH/vmerr.log \
    -XX:HeapDumpPath=$LOG_PATH/HeapDump"
    # -XX:ErrorFile系统奔溃时的日志
    # -XX:HeapDumpPath 堆快照路径

    if [ "$UID" = "0" ]; then
        ulimit -n 1024000 # 修改最大连接数
        umask 000 # 去掉权限
    else
        echo $EXEC_JAVA 
    fi
    cd $WORK_PATH
    pwd
    targetPackage=`find . -maxdepth 1 -type f \( -name "*.jar" -o -name "*.war" \)`
    #找到当前文件夹中的深度为1的类型为文件的name为jar或war的
    
    env=`getEnv`
    SPRING_ENV=""
    if [ -n "$env" ]; then
        SPRING_ENV="--spring.profiles.active=$env"
    fi
    
	echo "this target jar will be executed: "$targetPackage
    $EXEC_JAVA -jar $targetPackage $SPRING_ENV 2>&1
}

function getTotalMemSizeMb() {
	memsizeKb=`cat /proc/meminfo|grep MemTotal|awk '{print $2}'`
    if [ -z "$memsizeKb" ]; then
        memsizeKb=8*1000*1000
    fi
	memsizeMb=$(( $memsizeKb/1024 ))
	echo $memsizeMb
}

function outputJvmArgs() {
	jvmSize=$1
	MaxMetaspaceSize=$2
	ReservedCodeCacheSize=$3
	echo "-Xss512k -Xmx"$jvmSize" -Xms"$jvmSize" -XX:MetaspaceSize="$MaxMetaspaceSize" -XX:MaxMetaspaceSize="$MaxMetaspaceSize" -XX:+AlwaysPreTouch -XX:ReservedCodeCacheSize="$ReservedCodeCacheSize" -XX:+HeapDumpOnOutOfMemoryError "
}
# -Xss设置每个线程的堆栈大小
# -Xmx JVM最大可用内存
# -Xms JVM初始内存
# -XX:MetaspaceSize  设置metaspace区域的最大值
# -XX:+AlwaysPreTouch 启动的时候真实的分配物理内存给jvm
# -XX:ReservedCodeCacheSize 设置Code Cache大小，JIT编译的代码都放在Code Cache中，若Code Cache空间不足则JIT无法继续编译，并且会去优化，比如编译执行改为解释执行，由此，性能会降低
# -XX:+HeapDumpOnOutOfMemoryError 当堆内存空间溢出时输出堆的内存快照


function getJVMMemSizeOpt() {
	memsizeMb=`getTotalMemSizeMb`

	#公司的机器内存比实际标的数字要小，比如8G实际是7900M左右，一般误差小于1G
	#内存分级，单位兆/M
	let maxSize_lvl1=63*1024
	let maxSize_lvl2=31*1024
	let maxSize_lvl3=21*1024
	let maxSize_lvl4=15*1024
	let maxSize_lvl5=7*1024
	let maxSize_lvl6=3*1024
	let maxSize_lvl7=1024
	let maxSize_lvl8=512

	if [[ $memsizeMb -gt $maxSize_lvl1 ]]
	then
		jvmSize="32g"
		MaxMetaspaceSize="2g"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl2 && $memsizeMb -le $maxSize_lvl1 ]]
	then
		jvmSize="24g"
		MaxMetaspaceSize="1g"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl3 && $memsizeMb -le $maxSize_lvl2 ]]
	then
		jvmSize="18g"
		MaxMetaspaceSize="512m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl4 && $memsizeMb -le $maxSize_lvl3 ]]
	then
		jvmSize="12g"
		MaxMetaspaceSize="512m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl5 && $memsizeMb -le $maxSize_lvl4 ]]
	then
		jvmSize="4g"
		MaxMetaspaceSize="512m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl6 && $memsizeMb -le $maxSize_lvl5 ]]
	then
		jvmSize="2g"
		MaxMetaspaceSize="256m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl7 && $memsizeMb -le $maxSize_lvl6 ]]
	then
		jvmSize="1g"
		MaxMetaspaceSize="256m"
		ReservedCodeCacheSize="240m"
	fi

	if [[ $memsizeMb -gt $maxSize_lvl8 && $memsizeMb -le $maxSize_lvl7 ]]
	then
		jvmSize="512m"
		MaxMetaspaceSize="256m"
		ReservedCodeCacheSize="240m"
	fi

	if [ $memsizeMb -le $maxSize_lvl8 ]; then
		echo "service start fail:not enough memory for MDP service"
		exit 1
	fi
	outputJvmArgs $jvmSize $MaxMetaspaceSize $ReservedCodeCacheSize
	exit 0
}

function getEnv(){
    FILE_NAME="/data/webapps/appenv"
    PROP_KEY="env"
    PROP_VALUE=""
    if [[ -f "$FILE_NAME" ]]; then
        PROP_VALUE=`cat ${FILE_NAME} | grep -w ${PROP_KEY} | cut -d'=' -f2`
    fi
    echo $PROP_VALUE
}

init
run
```

# IO

## 零拷贝

1. 四次拷贝与四次上下文切换

   <img src="https://s2.loli.net/2022/03/26/a2xDh1ZyvrHOIcM.png" alt="拷贝与切换" style="zoom:50%;" />

   以发送磁盘文件为例子

   - 发起read系统调用（用户态->内核态），CPU 负责将数据从磁盘搬运到内核空间的 Page Cache 中
   - read 系统调用完毕（内核态->用户态），CPU 负责将数据从内核空间的 Page Cache 搬运到用户空间的缓冲区
   - write 系统调用（用户态->内核态），CPU 负责将数据从用户空间的缓冲区搬运到内核空间的 Socket 缓冲区中
   - write 系统调用完毕（内核态->用户态）,CPU 负责将数据从内核空间的 Socket 缓冲区搬运到的网络中

2. DMA技术

   DMA 技术就是我们在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMAC）。 

   DMAC 有其局限性，DMAC 仅仅能用于设备间**交换数据时进行数据拷贝**，设备内部的数据拷贝还需要 CPU 来亲力亲为。例如， CPU 需要负责内核空间与用户空间之间的数据拷贝（内存内部的拷贝）。

   零拷贝的特点是 CPU 不全程负责内存中的数据写入其他组件，CPU 仅仅起到管理的作用。但注意，零拷贝不是不进行拷贝，而是 CPU 不再全程负责数据拷贝时的搬运工作。如果数据本身不在内存中，那么必须先通过某种方式拷贝到内存中（这个过程 CPU 可以仅仅负责管理，DMAC 来负责具体数据拷贝），因为数据只有在内存中，才能被转移，才能被 CPU 直接读取计算。

3. 零拷贝技术主要有以下几种方案

   >- sendfile
   >
   >  应用场景：**用户从磁盘读取一些文件数据后不需要经过任何计算与处理就通过网络传输出去**
   >
   >  典型应用是消息队列，sendfile主要用到了两个技术
   >
   >  - **利用 DMA 技术**
   >
   >    DMA 负责磁盘到内核空间中的 Page cache（read buffer）的数据拷贝以及从内核空间中的 socket buffer 到网卡的数据拷贝。
   >
   >  - **传递文件描述符代替数据拷贝**
   >
   >    传递文件描述可以代替数据拷贝，这是由于两个原因：
   >
   >    - page cache 以及 socket buffer 都在内核空间中；
   >    - 数据在传输中没有被更新；
   >
   >  **注意事项**：一些物理网卡不支持
   >
   >  由于 sendfile 仅仅对应一次系统调用，而传统文件操作则需要使用 read 以及 write 两个系统调用。
   >
   >  正因为如此，sendfile 能够将用户态与内核态之间的上下文切换从 4 次讲到 2 次。另一方面，我们需
   >
   >  要注意 sendfile 系统调用的局限性。如果应用程序需要对从磁盘读取的数据进行写操作，例如解密或
   >
   >  加密，那么 sendfile 系统调用就完全没法用。这是因为用户线程根本就不能够通过 sendfile 系统调用
   >
   >  得到传输的数据。
   >
   >- mmap
   >
   >  mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。
   >
   >- Direct I/O
   >
   >  在 Direct I/O 技术中，数据直接存储在用户空间中，绕过了内核。
   >
   >  **Direct I/O 的读写非常有特点：**
   >
   >  - Write 操作：由于其不使用 page cache，所以其进行写文件，如果返回成功，数据就真的落盘了（不考虑磁盘自带的缓存）；
   >  - Read 操作：由于其不使用 page cache，每次读操作是真的从磁盘中读取，不会从文件系统的缓存中读取。
   >
   >  **优点**
   >
   >  1. **降低系统级别的管理对应用程序访问数据的影响**。
   >  2. **高性能**。
   >
   >  **缺点**
   >
   >  1. 由于设备之间的数据传输是通过 DMA 完成的，因此**用户空间的数据缓冲区内存页必须进行 page pinning（页锁定）**，这是为了防止其物理页框地址被交换到磁盘或者被移动到新的地址而导致 DMA 去拷贝数据的时候在指定的地址找不到内存页从而引发缺页错误，而页锁定的开销并不比 CPU 拷贝小，所以为了避免频繁的页锁定系统调用，应用程序必须分配和注册一个持久的内存池，用于数据缓冲。
   >  2. 如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。
   >  3. 在应用层引入直接 I/O 需要应用层自己管理，这带来了额外的系统复杂性

   

