## 数仓为什么要分层

1. **维护成本降低**。试想一个上千行的代码从头一点点理解，有问题需要修改时的维护成本是相当高的，而且很容易出错。
2. **隔离变化**。试想一下，如果某天需要更换数据源A为C，只需要修改任务1的代码即可，对下游的可以做到屏蔽变化，无感知。
3. **增加了复用性**，**进而带来一致性的提升和开发效率的提升**。
4. **持久化可以用空间换时间，节省计算资源**。
5. **提升数据安全**。不管是对表还是对视图，都可以按照不同规则把权限开放给不同的人，保证数据流通的前提下提升数据安全。
6. **统一建设思路**。明确职责，明确开发的先后顺序，让不同的开发人员开发思路更加统一，以便不同的人员可以更好的协作，真正出现问题也更好的定位到哪一层。
7. **血缘清晰**。通过命名规范区分不同的层，可以使开发时都沿着同一个顺序进行生产，血缘关系更加清晰，避免开发和调度时的循环依赖。

## 两种架构模式

- **Lambda架构**

  此架构的思想是将离线计算和实时计算分离，包含三个模块：

  1. **Batch Layer（批处理层）**：对历史的全量数据进行批处理，准确性高但时效性低（一般有小时级或天级延迟）；
  2. **Real-time Layer（实时层）**：对短期的增量数据进行流式处理或微批处理，实现秒级或分钟级的低延迟，弥补批处理层的滞后性；
  3. **Serving Layer（服务层）**：汇总以上两层模块的处理结果，暴露给外部服务调用。

  业界的大多数数仓采用的是**Spark/Hive离线计算引擎 + Storm/Flink实时计算引擎 + OLAP/OLTP存储引擎**的组件选型，这本质上就是Lambda架构。

- **Kappa架构**

  此架构的思想是离线计算和实时计算合二为一，包含两个模块：

  1. **Real-time Layer（实时层）**：扩展了Lambda架构的实时层，既处理短期增量数据，也处理历史全量数据，兼顾准确性和时效性；
  2. **Serving Layer（服务层）**：与Lambda架构相同，收集实时层的计算结果并对外提供服务。

  Kappa架构适用于侧重实时数据处理的场景，典型的技术选型是**Kafka消息中间件 + Flink实时**计算引擎，业界也有越来越多的领域开始基于Kappa架构建设数仓。

  | 架构方式   | 优点                                                         | 缺点                                                         |
  | :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
  | Lambda架构 | 离线和实时计算分别采用最合适的技术选型，同时具备高准确性和低延迟性离线数据容易订正 | 需要搭建两套计算引擎，维护成本高需要确保两套引擎处理逻辑和结果完全一致，难度较高 |
  | Kappa架构  | 只需搭建一套引擎，维护成本低无需合并离线和实时处理结果       | 实时引擎处理历史大量数据时，难以达到与离线引擎相同的性能在进行复杂逻辑计算时，实时引擎可能会存在数据丢失、计算偏差等问题，准确性较差 |

  总结来说，Lambda架构是一种传统的、较为稳妥的方式，如果对大量数据的处理有很高的准确性要求，同时又可以容忍较高的延迟，可以选用此架构。Kappa架构更偏重于对实时数据的处理能力，如果追求数据的时效性，可以尝试此架构。

## 数据分层

1. **ODS层**：位于最底层，将原始数据（包含业务DB、业务日志、第三方采买等来源）经过清洗和规范化后入仓，在入仓前需要进行去噪、去重、去除脏数据、量纲统一等初步转换；
2. **DW层**：它是数仓的主体，围绕业务主题建立各种数据模型（通常是维度模型）。这一层由ODS层数据汇总加工产生，包含历史全量的、明细的数据；
3. **DM层**：它对DW层的数据进一步加工，生成轻度汇总的非明细数据。这一层的数据主要面向后续的业务查询、OLAP分析等；
4. **ADS层**：它基于前面三层的数据，计算出数据产品最终使用的结果数据。这一层是高度汇总的最终产出数据，一般会同步到MySQL、ES、Druid等其他OLTP/OLAP存储引擎中供查询分析使用。

![](https://img-blog.csdnimg.cn/20190612112948315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY1Njc5NA==,size_16,color_FFFFFF,t_70)

除了四层模型外，还有三层模型等其他划分方式，思想都大同小异，遵循“原始数据 -> 基础明细数据 -> 半成品数据 -> 成品数据”的路径进行层次划分。在实际构建数仓时，也需要结合具体的业务场景，灵活制定分层结构。

分层模型的好处显而易见，主要有以下几点：

1. **提升可维护性**：将复杂的数据生产逻辑拆解成各层的子逻辑，便于维护和定位问题；
2. **简化血缘关系**：只允许上层依赖下层，不允许反向依赖，避免混乱的数据流向；
3. **减少重复开发**：通过主题建模，开发一些通用的中间数据（例如维度表），实现复用；
4. **屏蔽原始数据**：通过设计良好的ODS层，数仓使用方不必了解原始数据的细节和异常即可接入。

## 维度建模

1. **星型模型：**较为简单，通常不能满足实际业务领域复杂场景的要求；
2. **雪花模型：**在星型模型的基础上，扩展了多层级的维表结构，消除了维表中的冗余，更好满足了范式设计要求。但其缺点在于结构较为复杂，开发难度大，然而其解决的冗余问题在数据仓库领域并不严重；
3. **星座模型：**在星型模型基础上，扩展了多事实表、共享维度表的结构，能更好地描述复杂业务场景下事件与实体的关系。

在实际数仓设计中，较多采用星座模型，存在多个不同主题的事实表，以及多个可共享的维度表。并在表结构的设计上采用适当冗余的反范式方法，简化用户查询。

## 架构过程

1. 首先，综合考虑数据时效性要求、准确性要求、计算逻辑复杂度、成本要求等因素，选取Lambda架构或Kappa架构；
2. 然后，借鉴经典的四层/三层模型，结合业务主题、业务复杂度、数据特点、数据规模等因素，构建业务数仓分层体系；
3. 最后，在建模理论（通常是维度建模思想）的指导下设计数据表，确定更细粒度的数据结构。至此数仓的架构设计工作基本完成。

## 表模型

[参考](https://blog.csdn.net/weixin_40983094/article/details/110001082)

1. 全量表

   全覆盖更新，不分区

2. 增量表

   按时间分区，每个时间只同步那些增加或者修改的数据

3. 快照表

   按时间分区，每个分区都同步全量的数据

4. 拉链表

   不分区，每天把变动的数据附加到表中同时指明每一条数据的生命周期

   >构建流水表的过程是用增量表与全量表联表处理再并入增量表

5. 流水表

   存储用户的每次操作