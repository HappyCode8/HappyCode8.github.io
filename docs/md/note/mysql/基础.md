# 开发

- 建表

  ```mysql
  CREATE TABLE `ai_sco_day_analyse` (
     `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '自增主键',
     `template_id` varchar(64) NOT NULL DEFAULT '' COMMENT '机器人id',
     `call_date` date NOT NULL DEFAULT '0000-00-00' COMMENT '日期',
     `template_version` varchar(16) NOT NULL DEFAULT '' COMMENT '机器人版本',
     `total_count` int(11) NOT NULL DEFAULT '0' COMMENT '通话总数',
     `through_count` int(11) NOT NULL DEFAULT '0' COMMENT '接通总数',
     `first_round_not_hangup_count` int(11) NOT NULL DEFAULT '0' COMMENT '首轮未挂断总数',
     `cooperate_count` int(11) NOT NULL DEFAULT '0' COMMENT '配合数',
     `success_count` int(11) NOT NULL DEFAULT '0' COMMENT '成功数',
     `see_through_count` int(11) NOT NULL DEFAULT '0' COMMENT '识破数',
     `nlu_distinguish_count` int(11) NOT NULL DEFAULT '0' COMMENT 'nlu实际识别的query数',
     `nlu_eff_count` int(11) NOT NULL DEFAULT '0' COMMENT 'nlu可识别query数',
     `antipathy_count` int(11) NOT NULL DEFAULT '0' COMMENT '反感数',
     `talking_time_len` int(11) NOT NULL DEFAULT '0' COMMENT '通话时长',
     `insert_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '本条记录创建时间',
     `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '本条记录修改时间',
     `is_visible` tinyint(1) NOT NULL DEFAULT '1',
     PRIMARY KEY (`id`),
     UNIQUE KEY `idx_call_date_tenant_id` (`call_date`,`template_id`,`template_version`)
  ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4
  ```

- 不常用sql语法

  ```sql
  -- case...when...
  select bot_id,
         bot_name,
         case when 条件1 then 'xx'
              when 条件2 then 'yy'
         else 'zz'
         end as 字段
  from 表名
  ```

  

# 事务

## 事务特性

A: 原子性（Atomicity）：要么全做，要么全不做

C: 一致性（Consistency）：所有事务在事务执行前后对于一个数据的读取结果都是相同的

I: 隔离性（Isolation）：最终提交前对其它事务不可见

D: 持久性（Durability）：一旦提交，修改会永远保存

只有满足一致性结果才是正确的；无并发时串行执行满足原子性就一定满足一致性；并发时还需要满足隔离性才能满足一致性；持久性是为了应对系统崩溃

## 并发一致性问题

- 丢失修改：两个事务在commit前先后修改，后边会覆盖前边的
- 读脏数据：A事务修改后但是没commit,B事务读了但是A事务回滚了
- 不可重复读：A读->B改->A再读，A两次不一样
- 幻读：不可重读的一种，A读一片范围->B插入->A再读，两次行数不一样

并发可以通过封锁实现，但是封锁需要用户自己控制相当复杂，数据库提供了事务隔离级别来解决

## 封锁

- 写锁：加此锁可以读取和更新，加锁期间别的事务不能对A加任何锁
- 读锁：加此锁只能读，加锁期间其余事务可以加读锁，不能加写锁
- 意向锁：意向锁都是表锁，加读锁前必须先获得意向读锁或更强的锁，加写锁前必须先获得意向写锁

三级封锁协议

- 一级封锁协议

  改数据时必须先加写锁直到事务结束释放，解决丢失修改问题，因为加写锁后就不能两个事务同时改了

- 二级封锁协议

  一级基础上，读时必须加读锁，读完马上释放，解决读脏数据，加读锁后读写隔离开了

- 三级封锁协议

  二级基础上，读时加读锁，直到事务结束才释放，解决不可重读

两段锁协议

加锁和解锁分为两个阶段进行，事务

# SQL优化

1. 最左匹配

   ```sql
   KEY `idx_shopid_orderno` (`shop_id`,`order_no`)
   select * from _t where orderno=''
   查询匹配从左往右匹配，要使用order_no走索引，必须查询条件携带shop_id或者索引(shop_id,order_no)调换前后顺序
   ```

2. 隐式转换

   ```sql
   KEY `idx_mobile` (`mobile`)
   select * from _user where mobile=12345678901
   mobile是字符类型，使用了数字，应该使用字符串匹配，否则MySQL会用到隐式替换，导致索引失效。
   ```

3. 大分页

   ```sql
   KEY `idx_a_b_c` (`a`, `b`, `c`)
   select * from _t where a = 1 and b = 2 order by c desc limit 10000, 10;
   对于大分页的场景，可以优先让产品优化需求，如果没有优化的，有如下两种优化方式：
   一种是把上一次的最后一条数据，也即上面的c传过来，然后做“c < xxx”处理，但是这种一般需要改接口协议，并不一定可行；‘
   另一种是采用延迟关联的方式进行处理，减少SQL回表，但是要记得索引需要完全覆盖才有效果，SQL改动如下：
   select t1.* from _t t1, (select id from _t where a = 1 and b = 2 order by c desc limit 10000, 10) t2 where t1.id = t2.id;
   ```

4. in+order by

   ```sql
   KEY `idx_shopid_status_created` (`shop_id`, `order_status`, `created_at`)
   select * from _order where shop_id = 1 and order_status in (1, 2, 3) order by created_at desc limit 10
   
   in查询在MySQL底层是通过n*m的方式去搜索，类似union，但是效率比union高。
   
   in查询在进行cost代价计算时（代价 = 元组数 * IO平均值），是通过将in包含的数值，一条条去查询获取元组数的，因此这个计算过程会比较的慢，所以MySQL设置了个临界值(eq_range_index_dive_limit)，5.6之后超过这个临界值后该列的cost就不参与计算了。因此会导致执行计划选择不准确。默认是200，即in条件超过了200个数据，会导致in的代价计算存在问题，可能会导致Mysql选择的索引不准确。
   
   可以(order_status, created_at)互换前后顺序，并且调整SQL为延迟关联。
   ```

5. 范围查询阻断，后续字段不能走索引

   ```sql
   KEY `idx_shopid_created_status` (`shop_id`, `created_at`, `order_status`)
   select * from _order where shop_id = 1 and created_at > '2021-01-01 00:00:00' and order_status = 10
   范围查询还有in between
   ```

6. 不等于、不包含不能用到索引的快速搜索

   ```sql
   在索引上，避免使用NOT、!=、<>、!<、!>、NOT EXISTS、NOT IN、NOT LIKE等。
   ```

7. 优化器选择不使用索引

   ```sql
   如果要求访问的数据量很小，则优化器还是会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。
   select * from _order where  order_status = 1
   查询出所有未支付的订单，一般这种订单是很少的，即使建了索引，也没法使用索引。
   ```

8. 复杂查询

   ```sql
   如果是统计某些数据，可能改用数仓进行解决
   如果是业务上就有那么复杂的查询，可能就不建议继续走SQL了，而是采用其他的方式进行解决，比如使用ES等进行解决
   ```

9. asc和desc混用

   ```sql
   desc 和asc混用时会导致索引失效。
   ```

10. 大数据

    ```sql
    对于推送业务的数据存储，可能数据量会很大，如果在方案的选择上，最终选择存储在MySQL上，并且做7天等有效期的保存。
    那么需要注意，频繁的清理数据，会照成数据碎片，需要联系DBA进行数据碎片处理。
    ```

# MySQL中使用json

1. 数据字段设置为json

   ```sql
   CREATE TABLE UserLogin (
       userId BIGINT NOT NULL,
       loginInfo JSON,
       PRIMARY KEY(userId)
   );
   ```

2. 检索json

   ```sql
   SELECT
       userId,
       JSON_UNQUOTE(JSON_EXTRACT(loginInfo,"$.cellphone")) cellphone,
       JSON_UNQUOTE(JSON_EXTRACT(loginInfo,"$.wxchat")) wxchat
   FROM UserLogin;
   简化版：
   SELECT 
       userId,
       loginInfo->>"$.cellphone" cellphone,
       loginInfo->>"$.wxchat" wxchat
   FROM UserLogin;
   ```

3. 在json某个字段上建立索引

   ```sql
   ALTER TABLE UserLogin ADD COLUMN cellphone VARCHAR(255) AS (loginInfo->>"$.cellphone");
   
   ALTER TABLE UserLogin ADD UNIQUE INDEX idx_cellphone(cellphone);
   
   上述 SQL 首先创建了一个虚拟列 cellphone，这个列是由函数 loginInfo->>"$.cellphone" 计算得到的。然后在这个虚拟列上创建一个唯一索引 idx_cellphone
   
   当然，我们可以在一开始创建表的时候，就完成虚拟列及函数索引的创建。如下表创建的列 cellphone 对应的就是 JSON 中的内容，是个虚拟列；uk_idx_cellphone 就是在虚拟列 cellphone 上所创建的索引。
   
   CREATE TABLE UserLogin (
       userId BIGINT,
       loginInfo JSON,
       cellphone VARCHAR(255) AS (loginInfo->>"$.cellphone"),
       PRIMARY KEY(userId),
       UNIQUE KEY uk_idx_cellphone(cellphone)
   );
   ```

4. 实例

   ```sql
   用户画像库表，不用json
   用户    |标签                                   |
   +-------+---------------------------------------+
   |David  |80后 ； 高学历 ； 小资 ； 有房 ；常看电影   |
   |Tom    |90后 ；常看电影 ； 爱外卖                 |
   
   缺点：不好搜索特定画像的用户，另外分隔符也是一种自我约定，在数据库中其实可以任意存储其他数据，最终产生脏数据。
   
   CREATE TABLE UserTag (
       userId bigint NOT NULL,
       userTags JSON,
       PRIMARY KEY (userId)
   );
   
   INSERT INTO UserTag VALUES (1,'[2,6,8,10]');
   INSERT INTO UserTag VALUES (2,'[3,10,12]');
   
   MySQL 8.0.17 版本开始支持 Multi-Valued Indexes，用于在 JSON 数组上创建索引，并通过函数 member of、json_contains、json_overlaps 来快速检索索引数据。所以你可以在表 UserTag 上创建 Multi-Valued Indexes
   
   ALTER TABLE UserTag
   ADD INDEX idx_user_tags ((cast((userTags->"$") as unsigned array)));
   
   如果想要查询用户画像为常看电影的用户，可以使用函数 MEMBER OF：
   SELECT * FROM UserTag WHERE 10 MEMBER OF(userTags->"$")
   
   如果想要查询画像为 80 后，且常看电影的用户，可以使用函数 JSON_CONTAINS：
   SELECT * FROM UserTag WHERE JSON_CONTAINS(userTags->"$", '[2,10]')
   
   如果想要查询画像为 80 后、90 后，且常看电影的用户，则可以使用函数 JSON_OVERLAP：
   SELECT * FROM UserTag WHERE JSON_OVERLAPS(userTags->"$", '[2,3,10]')
   
   
   ```

   
   
   ```sql
   group by a,b,c与group by 1,2,3
   +------------+--------------+-----------+
   | date       | services     | downloads |
   +------------+--------------+-----------+
   | 2016-05-31 | Apps         |         1 |
   | 2016-05-31 | Applications |         1 |
   | 2016-05-31 | Applications |         1 |
   | 2016-05-31 | Apps         |         1 |
   | 2016-05-31 | Videos       |         1 |
   | 2016-05-31 | Videos       |         1 |
   | 2016-06-01 | Apps         |         3 |
   | 2016-06-01 | Applications |         4 |
   | 2016-06-01 | Videos       |         2 |
   | 2016-06-01 | Apps         |         2 |
   +------------+--------------+-----------+
   
   select 
     date,
     if(services='Apps','Applications',services) as services,
     sum(downloads) as downloads
   from test.zvijay_test 
   group by date,services
   +------------+--------------+-----------+
   | date       | services     | downloads |
   +------------+--------------+-----------+
   | 2016-05-31 | Applications |         2 |
   | 2016-05-31 | Applications |         2 |
   | 2016-05-31 | Videos       |         2 |
   | 2016-06-01 | Applications |         4 |
   | 2016-06-01 | Applications |         5 |
   | 2016-06-01 | Videos       |         2 |
   +------------+--------------+-----------+
   
   
   select
     date,
     if(services='Apps','Applications',services) as services,
     sum(downloads) as downloads
   from test.zvijay_test
   group by date,2;
   +------------+--------------+-----------+
   | date       | services     | downloads |
   +------------+--------------+-----------+
   | 2016-05-31 | Applications |         4 |
   | 2016-05-31 | Videos       |         2 |
   | 2016-06-01 | Applications |         9 |
   | 2016-06-01 | Videos       |         2 |
   +------------+--------------+-----------+
   ```

# MySql常见问题

## 有符号和无符号

```sql
create table test_unsigned(a int UNSIGNED, b int UNSIGNED);
insert into test_unsigned values(1,2);

select b - a from test_unsigned;
select a - b from test_unsigned;#报错，BIGINT UNSIGNED value is out of range in
```

## 自动增长

```sql
create table test_auto_increment (a int auto_increment);
# 自动增长字段，必须被定义成key，所以我们需要加上primary key
insert into test_auto_increment(a) values (null),(50),(null),(8),(null);
# 第一个null插入1，然后按真实的数字大小排序后插入，后面两个null，是在最大的数字上面加1
```

## 字段长度

```sql
varchar char 后的数字是代表字符长度
create table test_bigint (a bigint(4) ZEROFILL); ZEROFILL表示长度不够填充0
```

## 大小写

```
有些字符集是不区分大小写的，比如utf8_general_ci
```

## 特殊字符

```
时数据库和表的字符编码都是用的utf8，mysql的utf8编码的一个字符最多3个字节，但是一个emoji表情为4个字节，所以utf8不支持存储emoji表情。
该如何解决这个问题呢？
将字符编码改成utf8mb4，utf8mb4最多能有4字节，不过，在mysql5.5.3或更高的版本才支持。
```

# 常见面试题

## 1. 具体情境

> 有一个表如下：
>
> id,name,score1,score2,update_time
>
> 写出某个时间段有分值的所有人员,分页
>
> 深分页怎么优化
>
> 将上一次的查询结果的最后

## 2. mysql死锁

https://mp.weixin.qq.com/s/-gN3QEaAYiyJ3GL5upBApQ

# 安装

```yaml
version: '3'
services:
  mysql:
    image: mysql:8.0
    container_name: mysql
    command:
      --default-authentication-plugin=mysql_native_password
      --character-set-server=utf8mb4
      --collation-server=utf8mb4_general_ci
      --explicit_defaults_for_timestamp=true
      --lower_case_table_names=1
    # data 用来存放了数据库表文件，init存放初始化的脚本
    volumes:
      - /Users/wyj/Documents/mysql/data/:/var/lib/mysql/
      - /Users/wyj/Documents/mysql/conf/my.cnf:/etc/my.cnf
      - /Users/wyj/Documents/mysql/init:/docker-entrypoint-initdb.d/
    restart: always
    ports:
      - "3306:3306"
    environment:
      TZ: Asia/Shanghai
      MYSQL_ROOT_PASSWORD: 123456
      MYSQL_USER: wyj
      MYSQL_PASSWORD: 123456
```

# 常用语句

## 语句

**show variables like 'character%'**;

![image-20201025161517787](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20201025161517787.png)

**show engines**;

![image-20201025162725134](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20201025162725134.png)

**show create table student \G;**查看建表语句

```sql
Create Table: CREATE TABLE `student` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `number` int DEFAULT NULL,
  `name` varchar(20) DEFAULT NULL,
  `insert_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sex` tinyint DEFAULT NULL,
  `is_visible` tinyint DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```

```sql
 CREATE TABLE `class` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `number` int DEFAULT NULL,
  `classname` varchar(20) DEFAULT NULL,
  `insert_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `is_visible` tinyint DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```

**show index in student;**查看索引

![image-20201025191016247](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20201025191016247.png)

**duplicate key**语句一般应用在格式化多条更新语句，使用**insert into student(id,number,name,sex) values(10,1234567,'sss',0) on duplicate key update number=1234567;**一定要有唯一索引才能实现

**replace into**如果表中存在会先删除存在的记录，然后插入新的数据，否咋直接插入新的数据。

改数据类型

```sql
alter table template_business_value modify  `call_value` float(8,2) NOT NULL DEFAULT '0.00' COMMENT '单条价值', modify `business_ration` float(6,4) NOT NULL DEFAULT '0.00' COMMENT '业务完成率';
```

## 知识点

- MyISAM与InnoDB的差别

|        |   MyISAM   |                 InnoDB                 |
| :----: | :--------: | :------------------------------------: |
| 主外键 |   不支持   |                  支持                  |
|  事务  |   不支持   |                  支持                  |
| 行表锁 |    表锁    |                  行锁                  |
|  缓存  | 只缓存索引 | 不仅缓存索引而且缓存数据，对内存要求高 |
| 表空间 |     小     |                   大                   |
| 关注点 |    性能    |                  事务                  |

- 一条SQL语句的执行顺序：

**from->on->where->group by->having->select->order by->limit**

Left join:以左边为准，保留左边的全部

right join:以右边为准，保留右边的全部

inner join:以共有的为准，保留二者的共有部分

outer join:mysql不支持全外连接，左连接是左外连接，右连接是右外连接

- 添加**is_visible**字段，一方面为了数据浏览的完整性，另一方面为了索引
- 频繁删改的数据不适合建立索引

## 索引

- 单值索引，一个索引只包含单个列，一个表可以有多个单列索引，建议一张表索引不要超过5个

- 唯一索引，索引列的值必须唯一，但允许有空值，主键是一种唯一索引，主键自动建立唯一索引

- 复合索引，一个索引包含多个列

  ### 什么情况下建立索引

  1. 主键自动建立唯一索引
  2. 频繁作为查询条件的字段应该创建索引
  3. 查询中与其他表关联的字段
  4. 高并发倾向建立组合索引
  5. 查询中排序、组合、统计

  ### 什么情况下不建立索引

  1. 表记录太少，mysql官方5到8百万，但是不建议这么大
  2. 经常增删改
  3. 数据字段分布平均而且重复，比如性别、国籍，一般建议选择性（不重复值/所有）大的字段

  ### Explain

  ![image-20201025195509483](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20201025195509483.png)

  Explain+sql语句

  - 表的读取顺序
  - 数据读取操作的操作类型
  - 哪些索引可以使用
  - 哪些索引被实际使用
  - 表之间的引用
  - 每张表有多少行被优化器查询

- Id相同的情况下table列的顺序就是加载顺序；id不同时，id越大，优先级越高，越先被执行

![image-20201025195819981](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20201025195819981.png)

![image-20201025200254201](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20201025200254201.png)

- select_type
  - Simple简单查询
  - Primary最外层的查询
  - Subquery子查询
  - Derived衍生表，临时得
  - Union结果组装
  - Union Result两个查询合并

- type
  - All全表扫描，最差
  - index只遍历索引树
  - range只检索给定范围的行，使用一个索引来选择行，between，>，<等
  - ref非唯一索引扫描，根据索引查出来一部分，可能有多行，查找与扫描的混合体，一般优化到此
  - eq_ref唯一性索引扫描，根据索引查出来只有一条记录与之匹配,常见于主键或唯一索引扫描
  - const通过索引一次就找到了
  - system记录只有一行，const的特例，最好
- possible_keys,key
  - possible_keys索引可能被用到，但是不一定被查询实际使用
  - key实际使用

- Key_len
  - 表示索引使用的字节数，最大长度，并非实际使用长度

- ref
- rows
  - 实际扫描了多少行
- filtered
- Extras

## 表设计相关指南

- int(1)和int(11)在计算和存储上有什么区别？

  无区别，这只是展示长度，比如设为int(11)存为12，前边会有9个0，但是平时看不到，其实是对应的设置没开。

- big int与decimal有什么不同？

  Big int定长小数时，空间小，性能好；deciaml不定长的高精度运算

- varchar与char的区别
  varchar可变长度，支持到65535B，用在字符串最大长度比平均长度大很多，易产生碎片，char用于存储定长数据，支持到255B，比如MD5值，身份证号码会好一些，不易产生碎片。

- 分库分表

- 缓存数据异构，做缓存表，汇总表
  比如连锁店查询多门店订单数据，散表后无法进行聚合查询，使用in导致性能下降，order by查询速度慢

## 索引设计相关指南

![image-20201031231247148](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20201031231247148.png)

![image-20210618161706711](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20210618161706711.png)

平衡m树

- 只存关键字，增大业内数据量提升预读有效性，减少磁盘IO，（预读-》局部性原理，加载数据时加载前后。）

- 极大减少树的度，减少磁盘IO，单页16KB，两int的联合索引8B，4层可存80亿数据。

  16KB/8B=2000,2000X2000X2000=80亿

- 叶子节点直接绑定数据，减少磁盘IO

- 有序，叶子节点间双向链表，减少磁盘IO

- 聚簇索引叶子节点保存完整数据，如果定义了主键，主键就是聚簇索引，如果没有第一个费控唯一列作为聚簇索引，否则使用隐藏的

- 辅助索引叶子节点存聚簇索引的值，先通过普通索引查主键，再由主键查数据

  ## 主键设计规范

- 要有主键，且是顺序增长的，强烈建议使用int/bigint自增id作为主键

- 联合索引最左前缀匹配，一直向右匹配遇到范围查询

- 区分度高的尽量前置，范围查询的尽量后置，不要追求全覆盖，定位到千以内就好

- 不要让索引列的默认值为null

- Update/delete操作的where子句必须命中索引，否则相当于锁表

- 索引数量不要超过5个，长度不要超过3个字段

  ![image-20201031234018612](/Users/wyj/Desktop/gitnote/docs/md/note/mysql/images/image-20201031234018612.png)

  ## 
