# 分库分表

## 方法

//todo

## 问题

1. 事务问题

   分库分表以后，比如要完成一次转账，得先把a的钱扣掉，然后把b的钱加上才算一次操作，a,b可能在不同的库表中，怎么处理？

   - 使用分布式事务

     - 比如Mysql使用XA事务

     - 优点：交由数据库管理，简单有效
     - 缺点：性能代价高，特别是shard越来越多时

   - 由应用程序和数据库共同控制

     - 原理：将一个跨多个数据库的分布式事务分拆成多个仅处 于单个数据库上面的小事务，并通过应用程序来总控 各个小事务
     - 优点：性能上有优势
     - 缺点：需要应用程序在事务控制上做灵活设计。如果使用 了Spring的事务管理，改动起来会面临一定的困难

2. 跨节点join以及避免跨节点join

   - 分两次查询

     尽量避免跨节点join

   - 小表不常改动的，每个库放一份

   - 是否可以冗余

3. 跨节点的count,order by,group by以及聚合函数问题

   - 各节点查询返回，可以并行
   - 结果集大的话内存是个问题

4. 迁移、扩容

   - 尽量避免，尽量一次性分到位，可以将多个实例部署到一个服务器，业务增长以后迁移到别的服务器，这样整体迁移库就可以完成，DBA可以直接做。例如：

     - 首先拆32库，32表，但是部署8集群，每集群4库，每库32表

     - 随着业务增长，库成为瓶颈，逐步拆分到32集群，每集群1库，每库32表，此阶段只需要整体迁移库，路由规则不需要做变动，因为原来就是按照32*32设计的

     - 随着业务增长，32集群也没法满足业务，逐步拆分到1024集群，每集群1库1表，此阶段只需要整体迁移表，库与表的路由规则都要变

     - 随着业务增长，表容量达到瓶颈，那么拆表，每个表可以继续拆分，1024集群，每集群1库8192表，库的路由规则不变，表的路由规则要变

       https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html

5. ID问题

   - UUID
     - 优点：简单
     - 缺点：UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题
   - 数据库自增
     - 优点：简单
     - 缺点：单点、瓶颈
   - 推特的Snowflake，美团的leaf
     - 按照一定规则生成64位（Long），基本自增有序，不碰撞效率高，单秒20万量级

6. 排序分页

   - 排序字段就是分片字段时，根据分片规则比较容易定位到分片
   - 非分片时需要根据不同分片结果组装，但是性能很差
     - 如果是在前台应用提供分页，则限定用户只能看前面n页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）
     - 如果是后台批处理任务要求分批获取数据，则可以加大page size，比如每次获取5000条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）
     - 分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台
   
7. 其它问题

   - 事务支持：将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。
   - 复杂查询：
     - 垂直切分后，就跟join说拜拜了
     - 水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等
     - 禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。