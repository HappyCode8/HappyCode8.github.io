# LocalDate
```java
LocalDate date = LocalDate.of(2014, 3, 18); LocalDate.now();
int year = date.getYear();   
Month month = date.getMonth();   
int day = date.getDayOfMonth();   
DayOfWeek dow = date.getDayOfWeek(); //是周几   
int len = date.lengthOfMonth();    
boolean leap = date.isLeapYear();

//昨天的上一周，也就是7天以前
LocalDate yesterdaySevenDaysAgo = yesterday.minusWeeks(1);
//7天以前所在周的周一
LocalDate yesterdaySevenDaysAgoMonday = yesterdaySevenDaysAgo.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
//7天以前所在周的周日
LocalDate yesterdaySevenDaysAgoSunday = yesterdaySevenDaysAgo.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
```

# 下载文件

```java
@GetMapping("/test10")
    public void trendAnalyseReport(@RequestParam("template") String template,
                                       HttpServletResponse response
    ) throws IOException {
        //log.info("input param {}", sortClause);
        final var workbook = overViewBiz.trendAnalyseReport(template);
        var name = template == null ? "" : template +"_"+ LocalDate.now();
        transFile(response, workbook, name+".xlsx");
    }

private void transFile(HttpServletResponse response, Workbook workbook, String filename)  {
        if (workbook != null) {
            response.setHeader("Content-Disposition", "attachment;filename=" + filename);
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8");
            response.setHeader("Pragma", "no-cache");
            response.setHeader("Cache-Control", "no-cache");
            response.setDateHeader("Expires", 0);
            try (final var out = response.getOutputStream()) {
                workbook.write(out);
            } catch (IOException e) {
                throw new BizException(500, "excel导出失败", e);
            }
        } else {
            throw new BizException(500, "excel导出为空");
        }
    }
```

# 统一异常处理

```java
public class BizException extends Exception {
    private static final long serialVersionUID = 8404629559696048207L;

    private final int errCode;

    public BizException(int errCode) {
        super();
        this.errCode = errCode;
    }

    public BizException(int errCode, String message) {
        super(message);
        this.errCode = errCode;
    }

    public BizException(int errCode, String message, Throwable cause) {
        super(message, cause);
        this.errCode = errCode;
    }

    public BizException(int errCode, Throwable cause) {
        super(cause);
        this.errCode = errCode;
    }

    public int getErrCode() {
        return errCode;
    }

    public String getErrMsg() {
        return getLocalizedMessage();
    }
}

@RestControllerAdvice(basePackages = "com.meituan.ai.sco.pallas")
@Slf4j
public class ExceptionHandlers {

    @ExceptionHandler(MeaningfulException.class)
    public Result<?> handleMeaningfulException(MeaningfulException ex) {
        log.error("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getErrMsg());
        log.debug("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getErrMsg(), ex);
        return new Result<>(ex.getErrCode(), ex.getErrMsg());
    }

    @ExceptionHandler(BizException.class)
    public Result<?> handleBizException(BizException ex) {
        log.error("handle biz exception. code:{} msg:{}", ex.getErrCode(), ex.getErrMsg());
        log.debug("handle biz exception. code:{} msg:{}", ex.getErrCode(), ex.getErrMsg(), ex);
        return new Result<>(ex.getErrCode(), ex.getErrMsg());
    }

    @ExceptionHandler(Exception.class)
    public Result<?> common(Exception ex) {
        log.error("handle exception. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle exception. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage());
    }

    @ExceptionHandler(Throwable.class)
    public Result<?> commonThrowable(Throwable ex) {
        log.error("handle throwable. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle throwable. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage());
    }
}

```

# 枚举

枚举的本质是一个类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。

```java
public final class Size extends Enum<Size> {//这个类不能被继承
    public static final Size SMALL = new Size("SMALL",0);
    public static final Size MEDIUM = new Size("MEDIUM",1);
    public static final Size LARGE = new Size("LARGE",2);
    
    private static Size[] VALUES = new Size[]{SMALL,MEDIUM,LARGE};
    
    private Size(String name, int ordinal){//构造方法只能私有
        super(name, ordinal);
    }
    
    public static Size[] values(){//编译器添加的
        Size[] values = new Size[VALUES.length];
        System.arraycopy(VALUES, 0, values, 0, VALUES.length);
        return values;
    }
    
    public static Size valueOf(String name){//调用父类方法
        return Enum.valueOf(Size.class, name);
    }
}
```

通过name来获取枚举，希望不存在时返回null，有这么几种写法https://dzone.com/articles/java-enum-lookup-by-name-or-field-without-throwing

```java
		/**
     * 拙劣的实现，异常不应该用于流程控制
     * */
    public static Color trycatchValueOf(String name) {
        try {
            return Color.valueOf(name);
        } catch (Exception ex) {
            return null;
        }
    }

    /**
     * 拙劣的实现，没用异常但是线性查找，这有性能问题吗？可能有，但是微乎其微，不过思想上来说不好
     * */
    public static Color iterationFindByName(String name) {
        for (Color color : Color.values()) {
            if (name.equals(color.name())) {
                return color;
            }
        }
        return null;
    }

	  /**
     * 较优的实现，建立一个map，这里甚至可以不只是索引name，而是可以索引其他的的字段比如color
     * */
    private static final Map<String, Color> nameIndex = 	  Maps.newHashMapWithExpectedSize(Color.values().length);
    static {
        for (Color color : Color.values()) {
            nameIndex.put(color.name(), color);
        }
    }
    public static Color lookupByName(String name) {
        return nameIndex.get(name);
    }

		/**
     * 较优的实现，利用google的库，底层代码来看这里甚至使用了WeakReferences和WeakHashMaps
     * */
    public static Color getIfPresent(String name) {
        return Enums.getIfPresent(Color.class, name).orNull();
    }

		/**
     * 提取模板代码到公共的工具类里边
     * */
    private static final Function<String, Color> func =
            EnumUtil.lookupMap(Color.class, e -> e.name());
    public static Color lookupByDisplayNameUtil(String name) {
        return func.apply(name);
    }

public class EnumUtil {
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(Class<E> clazz, Function<E, T> mapper) {
        @SuppressWarnings("unchecked")
        E[] emptyArray = (E[]) Array.newInstance(clazz, 0);
        //EnumSet.allOf(clazz).toArray 将所有枚举类转为数组
        return lookupMap(EnumSet.allOf(clazz).toArray(emptyArray), mapper);
    }
    //入参是一个枚举数组、一个函数式接口（获得枚举的某个属性），出参仍然是一个函数式接口（获取map的）
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(E[] values, Function<E, T> mapper) {
        Map<T, E> index = Maps.newHashMapWithExpectedSize(values.length);
        for (E value : values) {
            //执行传入的函数式接口，此处就是e -> e.name()
            index.put(mapper.apply(value), value);
        }
        //返回的也是一个函数式接口，根据键值获取值(T key) -> index.get(key);
        return index::get;
    }
}
```

# 流式处理

```java
过滤：filter
去重：distinct
限制：limit
跳过：skip
映射：map
扁平化：flatmap
全查找：allMatch
任意满足：anyMatch
不存在：noneMathch
满足条件的第一个元素：findFirst
任意满足：findAny  
求和：sum
规约：reduce// 采用无初始值的重载版本，需要注意返回Optional
> reduce(0, Integer::sum);
> Optional<Integer> total=reduce(Integer::sum) 
求总数：Collectors.counting()   count()
求最大最小：
// 求最大年龄
Optional<Student> olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -> s1.getAge() - s2.getAge()));

// 进一步简化
Optional<Student> olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));

// 求最小年龄
Optional<Student> olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)));

求总和：Collectors.summingInt(Student::getAge)
求平均：Collectors.averagingInt(Student::getAge)
一次性求个数、总和、均值、最大值、最小值：Collectors.summarizingInt(Student::getAge)
  
字符串拼接：Collectors.joining(", ")
分组：Collectors.groupingBy(Student::getSchool)

多级分组：
Map<String, Map<String, List<Student>>> groups2 = students.stream().collect(
                Collectors.groupingBy(Student::getSchool,  // 一级分组，按学校
                Collectors.groupingBy(Student::getMajor)));// 二级分组，按专业

Map<String, Long> groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting()));//二级分组计数


分区：在分区中 key 只有两种情况：true 或 false
Map<Boolean, List<Student>> partition = students.stream().collect(Collectors.partitioningBy(student -> "武汉大学".equals(student.getSchool())));

排序：list.stream().sorted((a, b) -> a.compareTo(b))
```

# web开发

## 1. 异常处理

- 参数校验

  ```java
  @Data
  public class Account {
      @NotEmpty(message = "用户不允许为空")
      private String username;
  
      @NotEmpty(message = "用户姓名不允许为空")
      private String name;
  
      private String avatar;
  
      @Pattern(regexp = "1\\d{10}", message = "手机号格式不正确")
      private String telephone;
  
      @Email(message = "邮箱格式不正确")
      private String email;
  }
  
  @RestController
  @RequestMapping("/api/account")
  @Slf4j
  public class AccountController {
  
      @PostMapping("login")
      public Result<Account> test(@Valid @RequestBody Account account) {
          return Result.ok(account);
      }
  
  }
  ```

- 自定义校验

  ```java
  @Documented
  @Retention(RUNTIME)
  @Target({FIELD, METHOD, PARAMETER, TYPE})
  @Constraint(validatedBy = NotConflictAccount.NotConflictAccountValidator.class)
  public @interface NotConflictAccount {
      String message() default "用户名称不是123";
  
      Class<?>[] groups() default {};//校验分组
  
      Class<? extends Payload>[] payload() default {};
  
      class NotConflictAccountValidator implements ConstraintValidator<NotConflictAccount, Account> {
  
          @Override
          public boolean isValid(Account account, ConstraintValidatorContext constraintValidatorContext) {
              if (!account.getName().equals("123")) {
                  return false;
              }
              return true;
          }
      }
  }
  ```

- 业务代码校验

  ```java
  @RestController
  @RequestMapping("/api/exception")
  @Slf4j
  public class ExceptionController {
      @GetMapping("/meaningException")
      public void meaningfulException(){
          /**
           * 实际上会被WebExceptionHandler捕获处理
           * */
          throw new MeaningfulException(5001,"接收话术录音文件不合法");
      }
  
      @GetMapping("/Exception")
      public void exception() throws Exception {
          throw new Exception("dadsda");
      }
  }
  
  ```

- 建议：如果是简单参数校验直接使用参数校验，复杂且常用的使用自定义校验，更复杂的使用在业务代码中校验抛出异常然后全局统一捕获异常

## 2. 传参

- 前端传数字，后端直接转为枚举值，数据库入库时进行转换，取出时也进行转换，总结就是代码中用枚举，其余存储于给前端时都给数

  ```java
  public enum LanguageEnums{
      CHINESE(1,"中文"),
      ENGLISH(2, "英文");
  
      private Integer code;
      private String desc;
  
      LanguageEnums(Integer code, String desc) {
          this.code=code;
          this.desc=desc;
      }
  
      /**
       * 前端给的时候反序列化成枚举,注意的一点是如果不自己实现，spring也会默认转枚举，但是它是按照下标顺序取的
       * */
      @JsonCreator
      public static LanguageEnums getByCode(Integer code) {
          for (LanguageEnums value : LanguageEnums.values()) {
              if (code.equals(value.getCode())) {
                  return value;
              }
          }
          return null;
      }
  
      /**
      * 给前端时序列化成数字
      * */
      @JsonValue
      public Integer getCode() {
          return code;
      }
  
  }
  ```

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
      <typeHandlers>
          <typeHandler handler="com.wyj.handler.GenderEnumHandler" javaType="com.wyj.anno.GenderEnum" />
      </typeHandlers>
  </configuration>
  ```

  ```java
  public class GenderEnumHandler extends BaseTypeHandler<GenderEnum> {
  
      @Override
      public void setNonNullParameter(PreparedStatement preparedStatement, int i, GenderEnum genderEnum, JdbcType jdbcType) throws SQLException {
          preparedStatement.setInt(i, genderEnum.getCode());
      }
  
      @Override
      public GenderEnum getNullableResult(ResultSet resultSet, String s) throws SQLException {
          return GenderEnum.getGenderEnumByCode(resultSet.getInt(s));
      }
  
      @Override
      public GenderEnum getNullableResult(ResultSet resultSet, int i) throws SQLException {
          return GenderEnum.getGenderEnumByCode(resultSet.getInt(i));
      }
  
      @Override
      public GenderEnum getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
          return GenderEnum.getGenderEnumByCode(callableStatement.getInt(i));
      }
  }
  ```

  









