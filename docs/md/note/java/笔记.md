# LocalDate
```java
LocalDate date = LocalDate.of(2014, 3, 18); LocalDate.now();
int year = date.getYear();   
Month month = date.getMonth();   
int day = date.getDayOfMonth();   
DayOfWeek dow = date.getDayOfWeek(); //是周几   
int len = date.lengthOfMonth();    
boolean leap = date.isLeapYear();

//昨天的上一周，也就是7天以前
LocalDate yesterdaySevenDaysAgo = yesterday.minusWeeks(1);
//7天以前所在周的周一
LocalDate yesterdaySevenDaysAgoMonday = yesterdaySevenDaysAgo.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
//7天以前所在周的周日
LocalDate yesterdaySevenDaysAgoSunday = yesterdaySevenDaysAgo.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
```

# 下载文件

```java
@GetMapping("/test10")
    public void trendAnalyseReport(@RequestParam("template") String template,
                                       HttpServletResponse response
    ) throws IOException {
        //log.info("input param {}", sortClause);
        final var workbook = overViewBiz.trendAnalyseReport(template);
        var name = template == null ? "" : template +"_"+ LocalDate.now();
        transFile(response, workbook, name+".xlsx");
    }

private void transFile(HttpServletResponse response, Workbook workbook, String filename)  {
        if (workbook != null) {
            response.setHeader("Content-Disposition", "attachment;filename=" + filename);
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8");
            response.setHeader("Pragma", "no-cache");
            response.setHeader("Cache-Control", "no-cache");
            response.setDateHeader("Expires", 0);
            try (final var out = response.getOutputStream()) {
                workbook.write(out);
            } catch (IOException e) {
                throw new BizException(500, "excel导出失败", e);
            }
        } else {
            throw new BizException(500, "excel导出为空");
        }
    }
```

# 统一异常处理

```java
public class BizException extends Exception {
    private static final long serialVersionUID = 8404629559696048207L;

    private final int errCode;

    public BizException(int errCode) {
        super();
        this.errCode = errCode;
    }

    public BizException(int errCode, String message) {
        super(message);
        this.errCode = errCode;
    }

    public BizException(int errCode, String message, Throwable cause) {
        super(message, cause);
        this.errCode = errCode;
    }

    public BizException(int errCode, Throwable cause) {
        super(cause);
        this.errCode = errCode;
    }

    public int getErrCode() {
        return errCode;
    }

    public String getErrMsg() {
        return getLocalizedMessage();
    }
}

@RestControllerAdvice(basePackages = "com.meituan.ai.sco.pallas")
@Slf4j
public class ExceptionHandlers {

    @ExceptionHandler(MeaningfulException.class)
    public Result<?> handleMeaningfulException(MeaningfulException ex) {
        log.error("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getErrMsg());
        log.debug("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getErrMsg(), ex);
        return new Result<>(ex.getErrCode(), ex.getErrMsg());
    }

    @ExceptionHandler(BizException.class)
    public Result<?> handleBizException(BizException ex) {
        log.error("handle biz exception. code:{} msg:{}", ex.getErrCode(), ex.getErrMsg());
        log.debug("handle biz exception. code:{} msg:{}", ex.getErrCode(), ex.getErrMsg(), ex);
        return new Result<>(ex.getErrCode(), ex.getErrMsg());
    }

    @ExceptionHandler(Exception.class)
    public Result<?> common(Exception ex) {
        log.error("handle exception. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle exception. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage());
    }

    @ExceptionHandler(Throwable.class)
    public Result<?> commonThrowable(Throwable ex) {
        log.error("handle throwable. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle throwable. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage());
    }
}

```

# 枚举

枚举的本质是一个类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。

```java
public final class Size extends Enum<Size> {//这个类不能被继承
    public static final Size SMALL = new Size("SMALL",0);
    public static final Size MEDIUM = new Size("MEDIUM",1);
    public static final Size LARGE = new Size("LARGE",2);
    
    private static Size[] VALUES = new Size[]{SMALL,MEDIUM,LARGE};
    
    private Size(String name, int ordinal){//构造方法只能私有
        super(name, ordinal);
    }
    
    public static Size[] values(){//编译器添加的
        Size[] values = new Size[VALUES.length];
        System.arraycopy(VALUES, 0, values, 0, VALUES.length);
        return values;
    }
    
    public static Size valueOf(String name){//调用父类方法
        return Enum.valueOf(Size.class, name);
    }
}
```

通过name来获取枚举，希望不存在时返回null，有这么几种写法https://dzone.com/articles/java-enum-lookup-by-name-or-field-without-throwing

```java
		/**
     * 拙劣的实现，异常不应该用于流程控制
     * */
    public static Color trycatchValueOf(String name) {
        try {
            return Color.valueOf(name);
        } catch (Exception ex) {
            return null;
        }
    }

    /**
     * 拙劣的实现，没用异常但是线性查找，这有性能问题吗？可能有，但是微乎其微，不过思想上来说不好
     * */
    public static Color iterationFindByName(String name) {
        for (Color color : Color.values()) {
            if (name.equals(color.name())) {
                return color;
            }
        }
        return null;
    }

	  /**
     * 较优的实现，建立一个map，这里甚至可以不只是索引name，而是可以索引其他的的字段比如color
     * */
    private static final Map<String, Color> nameIndex = 	  Maps.newHashMapWithExpectedSize(Color.values().length);
    static {
        for (Color color : Color.values()) {
            nameIndex.put(color.name(), color);
        }
    }
    public static Color lookupByName(String name) {
        return nameIndex.get(name);
    }

		/**
     * 较优的实现，利用google的库，底层代码来看这里甚至使用了WeakReferences和WeakHashMaps
     * */
    public static Color getIfPresent(String name) {
        return Enums.getIfPresent(Color.class, name).orNull();
    }

		/**
     * 提取模板代码到公共的工具类里边
     * */
    private static final Function<String, Color> func =
            EnumUtil.lookupMap(Color.class, e -> e.name());
    public static Color lookupByDisplayNameUtil(String name) {
        return func.apply(name);
    }

public class EnumUtil {
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(Class<E> clazz, Function<E, T> mapper) {
        @SuppressWarnings("unchecked")
        E[] emptyArray = (E[]) Array.newInstance(clazz, 0);
        //EnumSet.allOf(clazz).toArray 将所有枚举类转为数组
        return lookupMap(EnumSet.allOf(clazz).toArray(emptyArray), mapper);
    }
    //入参是一个枚举数组、一个函数式接口（获得枚举的某个属性），出参仍然是一个函数式接口（获取map的）
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(E[] values, Function<E, T> mapper) {
        Map<T, E> index = Maps.newHashMapWithExpectedSize(values.length);
        for (E value : values) {
            //执行传入的函数式接口，此处就是e -> e.name()
            index.put(mapper.apply(value), value);
        }
        //返回的也是一个函数式接口，根据键值获取值(T key) -> index.get(key);
        return index::get;
    }
}
```

# 流式处理

```java
过滤：filter
去重：distinct
限制：limit
跳过：skip
映射：map
扁平化：flatmap
全查找：allMatch
任意满足：anyMatch
不存在：noneMathch
满足条件的第一个元素：findFirst
任意满足：findAny  
求和：sum
规约：reduce// 采用无初始值的重载版本，需要注意返回Optional
> reduce(0, Integer::sum);
> Optional<Integer> total=reduce(Integer::sum) 
求总数：Collectors.counting()   count()
求最大最小：
// 求最大年龄
Optional<Student> olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -> s1.getAge() - s2.getAge()));

// 进一步简化
Optional<Student> olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));

// 求最小年龄
Optional<Student> olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)));

求总和：Collectors.summingInt(Student::getAge)
求平均：Collectors.averagingInt(Student::getAge)
一次性求个数、总和、均值、最大值、最小值：Collectors.summarizingInt(Student::getAge)
  
字符串拼接：Collectors.joining(", ")
分组：Collectors.groupingBy(Student::getSchool)

多级分组：
Map<String, Map<String, List<Student>>> groups2 = students.stream().collect(
                Collectors.groupingBy(Student::getSchool,  // 一级分组，按学校
                Collectors.groupingBy(Student::getMajor)));// 二级分组，按专业

Map<String, Long> groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting()));//二级分组计数

分区：在分区中 key 只有两种情况：true 或 false
Map<Boolean, List<Student>> partition = students.stream().collect(Collectors.partitioningBy(student -> "武汉大学".equals(student.getSchool())));
```









