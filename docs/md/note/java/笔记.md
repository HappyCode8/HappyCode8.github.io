# LocalDate
```java
LocalDate date = LocalDate.of(2014, 3, 18); LocalDate.now();
int year = date.getYear();   
Month month = date.getMonth();   
int day = date.getDayOfMonth();   
DayOfWeek dow = date.getDayOfWeek(); //是周几   
int len = date.lengthOfMonth();    
boolean leap = date.isLeapYear();

//昨天的上一周，也就是7天以前
LocalDate yesterdaySevenDaysAgo = yesterday.minusWeeks(1);
//7天以前所在周的周一
LocalDate yesterdaySevenDaysAgoMonday = yesterdaySevenDaysAgo.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
//7天以前所在周的周日
LocalDate yesterdaySevenDaysAgoSunday = yesterdaySevenDaysAgo.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
```

# 枚举

枚举的本质是一个类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。

```java
public final class Size extends Enum<Size> {//这个类不能被继承
    public static final Size SMALL = new Size("SMALL",0);
    public static final Size MEDIUM = new Size("MEDIUM",1);
    public static final Size LARGE = new Size("LARGE",2);
    
    private static Size[] VALUES = new Size[]{SMALL,MEDIUM,LARGE};
    
    private Size(String name, int ordinal){//构造方法只能私有
        super(name, ordinal);
    }
    
    public static Size[] values(){//编译器添加的
        Size[] values = new Size[VALUES.length];
        System.arraycopy(VALUES, 0, values, 0, VALUES.length);
        return values;
    }
    
    public static Size valueOf(String name){//调用父类方法
        return Enum.valueOf(Size.class, name);
    }
}
```

通过name来获取枚举，希望不存在时返回null，有这么几种写法https://dzone.com/articles/java-enum-lookup-by-name-or-field-without-throwing

```java
		/**
     * 拙劣的实现，异常不应该用于流程控制
     * */
    public static Color trycatchValueOf(String name) {
        try {
            return Color.valueOf(name);
        } catch (Exception ex) {
            return null;
        }
    }

    /**
     * 拙劣的实现，没用异常但是线性查找，这有性能问题吗？可能有，但是微乎其微，不过思想上来说不好
     * */
    public static Color iterationFindByName(String name) {
        for (Color color : Color.values()) {
            if (name.equals(color.name())) {
                return color;
            }
        }
        return null;
    }

	  /**
     * 较优的实现，建立一个map，这里甚至可以不只是索引name，而是可以索引其他的的字段比如color
     * */
    private static final Map<String, Color> nameIndex = 	  Maps.newHashMapWithExpectedSize(Color.values().length);
    static {
        for (Color color : Color.values()) {
            nameIndex.put(color.name(), color);
        }
    }
    public static Color lookupByName(String name) {
        return nameIndex.get(name);
    }

		/**
     * 较优的实现，利用google的库，底层代码来看这里甚至使用了WeakReferences和WeakHashMaps
     * */
    public static Color getIfPresent(String name) {
        return Enums.getIfPresent(Color.class, name).orNull();
    }

		/**
     * 提取模板代码到公共的工具类里边
     * */
    private static final Function<String, Color> func =
            EnumUtil.lookupMap(Color.class, e -> e.name());
    public static Color lookupByDisplayNameUtil(String name) {
        return func.apply(name);
    }

public class EnumUtil {
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(Class<E> clazz, Function<E, T> mapper) {
        @SuppressWarnings("unchecked")
        E[] emptyArray = (E[]) Array.newInstance(clazz, 0);
        //EnumSet.allOf(clazz).toArray 将所有枚举类转为数组
        return lookupMap(EnumSet.allOf(clazz).toArray(emptyArray), mapper);
    }
    //入参是一个枚举数组、一个函数式接口（获得枚举的某个属性），出参仍然是一个函数式接口（获取map的）
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(E[] values, Function<E, T> mapper) {
        Map<T, E> index = Maps.newHashMapWithExpectedSize(values.length);
        for (E value : values) {
            //执行传入的函数式接口，此处就是e -> e.name()
            index.put(mapper.apply(value), value);
        }
        //返回的也是一个函数式接口，根据键值获取值(T key) -> index.get(key);
        return index::get;
    }
}
```

# 流式处理

```java
过滤：filter
去重：distinct
限制：limit
跳过：skip
映射：map
扁平化：flatmap
全查找：allMatch
任意满足：anyMatch
不存在：noneMathch
满足条件的第一个元素：findFirst
任意满足：findAny  
求和：sum
规约：reduce// 采用无初始值的重载版本，需要注意返回Optional
> reduce(0, Integer::sum);
> Optional<Integer> total=reduce(Integer::sum) 
求总数：Collectors.counting()   count()
求最大最小：
// 求最大年龄
Optional<Student> olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -> s1.getAge() - s2.getAge()));

// 进一步简化
Optional<Student> olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));

// 求最小年龄
Optional<Student> olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)));

求总和：Collectors.summingInt(Student::getAge)
求平均：Collectors.averagingInt(Student::getAge)
一次性求个数、总和、均值、最大值、最小值：Collectors.summarizingInt(Student::getAge)
  
字符串拼接：Collectors.joining(", ")
分组：Collectors.groupingBy(Student::getSchool)

多级分组：
Map<String, Map<String, List<Student>>> groups2 = students.stream().collect(
                Collectors.groupingBy(Student::getSchool,  // 一级分组，按学校
                Collectors.groupingBy(Student::getMajor)));// 二级分组，按专业

Map<String, Long> groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting()));//二级分组计数


分区：在分区中 key 只有两种情况：true 或 false
Map<Boolean, List<Student>> partition = students.stream().collect(Collectors.partitioningBy(student -> "武汉大学".equals(student.getSchool())));

排序：list.stream().sorted((a, b) -> a.compareTo(b))
```

# web开发

## 1. 参数校验

```java
//JSR校验
@Data
public class StudentDTO {
    @NotEmpty(message = "用户姓名不允许为空")
    private String name;

    @Pattern(regexp = "1\\d{10}", message = "手机号格式不正确")
    private String telephone;

    @Email(message = "邮箱格式不正确")
    private String email;
}

//自定义注解校验
@Documented
@Retention(RUNTIME)
@Target({FIELD, METHOD, PARAMETER, TYPE})
@Constraint(validatedBy = NotConflictAccount.NotConflictAccountValidator.class)
public @interface NotConflictAccount {
    String message() default "用户名称不是123";

    Class<?>[] groups() default {};//校验分组

    Class<? extends Payload>[] payload() default {};

    class NotConflictAccountValidator implements ConstraintValidator<NotConflictAccount, StudentDTO> {

        @Override
        public boolean isValid(StudentDTO student, ConstraintValidatorContext constraintValidatorContext) {
            if (!student.getName().equals("123")) {
                return false;
            }
            return true;
        }
    }
}

//需要校验的步骤
@RestController
@RequestMapping("api/validate")
@Slf4j
@Validated
public class ValidationController {
    @PostMapping
    public Result test(@Valid @RequestBody @NotConflictAccount StudentDTO studentDTO){
        return Result.ok(studentDTO);
    }
}
```

- 建议：如果是简单参数校验直接使用参数校验，复杂且常用的使用自定义校验，更复杂的使用在业务代码中校验抛出异常然后全局统一捕获异常

## 2. 统一返回

```java
@Data
@AllArgsConstructor
@RequiredArgsConstructor
public class Result<T> implements Serializable {
    private static final long serialVersionUID = 1L;

    private Integer status;
    private String msg;
    private T data;

    public static <T> Result<T> ok(T data) {
        return new Result<>(HttpStatus.OK.value(), HttpStatus.OK.getReasonPhrase(), data);
    }
}

@GetMapping("/getAllStudent")
    @ResponseBody
    @Tag(name="getAllStudent")
    public Result<PageInfo<StudentVO>> studentList(@RequestParam(defaultValue = "1") Integer currentPage,
                                                   @RequestParam(defaultValue = "10") Integer pageSize) {
        return Result.ok(studentBiz.pageQuery(currentPage, pageSize));
    }
```

## 3. 统一异常处理

```java
//统一的异常类
@Data
public class MeaningfulException extends RuntimeException {
    private static final long serialVersionUID = 3773770775333164849L;

    private final int errCode;

    public MeaningfulException(int errCode, String message) {
        super(message);
        this.errCode = errCode;
    }
}

//统一的异常处理中心
@RestControllerAdvice
@Slf4j
public class WebExceptionHandler {
    @ExceptionHandler(MeaningfulException.class)
    public Result<?> handleMeaningfulException(MeaningfulException ex) {
        log.error("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getLocalizedMessage());
        log.debug("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getLocalizedMessage(), ex);
        return new Result<>(ex.getErrCode(), ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(Exception.class)
    public Result<?> common(Exception ex) {
        log.error("handle exception. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle exception. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(Throwable.class)
    public Result<?> commonThrowable(Throwable ex) {
        log.error("handle throwable. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle throwable. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<?> handleValidException(MethodArgumentNotValidException ex) {
        log.error("valid exception{}",ex.getMessage());
        var stringBuilder = new StringBuilder();
        ex.getBindingResult().getAllErrors().stream().forEach(it->stringBuilder.append(it.getDefaultMessage()).append(","));
        return new Result<>(500,  stringBuilder.toString(),"");
    }
}

@RestController
@RequestMapping("api/exception")
@Slf4j
public class ExceptionController {
    @GetMapping("/meaningException")
    public void meaningfulException(){
        /**
         * 实际上会被WebExceptionHandler捕获处理
         * */
        throw new MeaningfulException(500,"接收话术录音文件不合法");
    }

    @GetMapping("/Exception")
    public void exception() throws Exception {
        throw new Exception("dadsda");
    }
}
```

## 4. 参数校验、统一异常处理与统一返回的关系

>- 参数校验有问题时会抛出异常，这个异常统一处理
>- 异常处理时将返回结果统一到统一返回的格式

## 5. 枚举传参

- 前后端传参，前端传数字，后端转为枚举值，传给前端时再转为数字

  ```java
  //前后端互转
  public enum GenderEnum {
      /*
      对应性别的枚举男性
      */
      MAN(1, "男"),
      /*
      对于性别的枚举女性
      */
      WOMAN(2, "女");
  
      private int code;
      private String value;
  
      GenderEnum(int code, String value) {
          this.code = code;
          this.value = value;
      }
  
      /**
       * 前端给的时候反序列化成枚举,注意的一点是如果不自己实现，spring也会默认转枚举，但是它是按照下标顺序取的
       * */
      @JsonCreator
      public static GenderEnum getGenderEnumByCode(Integer code) {
          switch (code) {
              case 1:
                  return WOMAN;
              default:
                  return MAN;
          }
      }
  
      /**
       * 给前端时序列化成数字
       * */
      @JsonValue
      public int getCode() {
          return code;
      }
  }
  ```

  - 后端与数据库传参，数据库存数字

  ```java
  //基于mybatis互转
  public class GenderEnumHandler extends BaseTypeHandler<GenderEnum> {
  
      /**
       * 写库时写枚举码
       * */
      @Override
      public void setNonNullParameter(PreparedStatement preparedStatement, int i, GenderEnum genderEnum, JdbcType jdbcType) throws SQLException {
          preparedStatement.setInt(i, genderEnum.getCode());
      }
  
      /**
       * 使用列名，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(ResultSet resultSet, String s) throws SQLException {
          return GenderEnum.getGenderEnumByCode(resultSet.getInt(s));
      }
  
      /**
       * 使用下标，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(ResultSet resultSet, int i) throws SQLException {
          return GenderEnum.getGenderEnumByCode(resultSet.getInt(i));
      }
  
      /**
       * 存储过程专用，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
          return GenderEnum.getGenderEnumByCode(callableStatement.getInt(i));
      }
  }
  
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
      <typeHandlers>
          <typeHandler handler="com.wyj.handler.GenderEnumHandler" javaType="com.wyj.enums.GenderEnum" />
      </typeHandlers>
  </configuration>
  ```

  - 当用枚举传参时的一些转化

  >- 涉及到前端、后端、数据库传参时传什么、存什么
  >- 前端给后端传：传枚举码转化为枚举类在代码中使用，涉及到枚举值转枚举类
  >- 后端给前端：传枚举码给前端，涉及到枚举类转枚举值
  >- 后端给数据库：存枚举码，涉及到枚举类转枚举值
  >- 数据库给后端：将查出来的枚举码转为枚举类使用
  >
  >综上来看，只有代码中使用枚举类，传给前端以及存到数据库的都应该是枚举值，每次涉及到正反两方面的转化。
  >
  >- 与数据库互转时，一般使用ORM框架插件处理
  >- 与前端互转时，使用一些序列化注解辅助

## 6. 数据拷贝

```java
//基于mapstruct的数据转换
@Mapper
public interface StudentConverter {
    StudentConverter MAPPER=Mappers.getMapper(StudentConverter.class);
    StudentVO toVo(Student student);
    List<StudentVO> entity2VO(List<Student> student);
}
```

> 但是同时使用lombok与mapstruct有时会有问题，主要原因是这两个都是在编译阶段起作用，因此需要引入插件处理，有时还要保证顺序

```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <annotationProcessorPaths>
      <!--保证顺序-->
      <path>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.20</version>
      </path>
      <path>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct-processor</artifactId>
        <version>${org.mapstruct.version}</version>
      </path>
    </annotationProcessorPaths>
  </configuration>
</plugin>
```

## 7. 切面与注解

基于注解做切面，可以用来打日志、限流等操作

```java
//定义一个注解
@Order(Ordered.HIGHEST_PRECEDENCE)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface Tag {
    // 资源名称，用于描述接口功能
    String name() default "";
}

//对打了注解的做处理
@Aspect
@Component
@Slf4j
public class TagAspect {

    /**
     打了com.annotation.ApiLimit的作为一个切面
     * */
    @Pointcut("@annotation(com.wyj.annotation.Tag)")
    public void pointcut() {
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        /**
         * 得到请求
         * */
        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();
        /**
         * 得到方法签名
         * */
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        /**
         * 得到方法
         * */
        Method signatureMethod = signature.getMethod();
        Tag tag = signatureMethod.getAnnotation(Tag.class);
        String name = tag.name();
        log.info("http method {}", name);
        return joinPoint.proceed();
    }
}
```

## 8. 分片处理

```java
final var partion = Lists.partition(dataList, split);
partion.forEach(it -> {
  处理 it
});
```

## 9. 分页处理Mybatis、PageHelper

```java
PageHelper.startPage(currentPage, pageSize);
        final List<AggregateCityResult> res = 查询;
        PageInfo pageAggregateCityResults = new PageInfo(res);
        final List<CityVO> cityVOS = new ArrayList<>();
        res.forEach(data->{
            //这里做转换
            final var cityVO = new CityVO();
            ...
            cityVOS.add(cityVO);
        });
        //这里重写分页后的list
        pageAggregateCityResults.setList(cityVOS);
        return pageAggregateCityResults;
```

## 10.下载文件

```java
@GetMapping("/test10")
    public void trendAnalyseReport(@RequestParam("template") String template,
                                       HttpServletResponse response
    ) throws IOException {
        //log.info("input param {}", sortClause);
        final var workbook = overViewBiz.trendAnalyseReport(template);
        var name = template == null ? "" : template +"_"+ LocalDate.now();
        transFile(response, workbook, name+".xlsx");
    }

private void transFile(HttpServletResponse response, Workbook workbook, String filename)  {
        if (workbook != null) {
            response.setHeader("Content-Disposition", "attachment;filename=" + filename);
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8");
            response.setHeader("Pragma", "no-cache");
            response.setHeader("Cache-Control", "no-cache");
            response.setDateHeader("Expires", 0);
            try (final var out = response.getOutputStream()) {
                workbook.write(out);
            } catch (IOException e) {
                throw new BizException(500, "excel导出失败", e);
            }
        } else {
            throw new BizException(500, "excel导出为空");
        }
    }
```









