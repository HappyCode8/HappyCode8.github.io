# LocalDate

```java
LocalDate date = LocalDate.of(2014, 3, 18);   LocalDate.now();
int year = date.getYear();   
Month month = date.getMonth();   
int day = date.getDayOfMonth();   
DayOfWeek dow = date.getDayOfWeek(); //是周几   
int len = date.lengthOfMonth();    
boolean leap = date.isLeapYear();

//昨天的上一周，也就是7天以前
LocalDate yesterdaySevenDaysAgo = yesterday.minusWeeks(1);
//7天以前所在周的周一
LocalDate yesterdaySevenDaysAgoMonday = yesterdaySevenDaysAgo.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
//7天以前所在周的周日
LocalDate yesterdaySevenDaysAgoSunday = yesterdaySevenDaysAgo.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
// 判断localDate1是否在localDate2之前，返回布尔值
boolean before = localDate1.isBefore(localDate2);
```

# 枚举

枚举的本质是一个类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。

```java
public final class Size extends Enum<Size> {//这个类不能被继承
    public static final Size SMALL = new Size("SMALL",0);
    public static final Size MEDIUM = new Size("MEDIUM",1);
    public static final Size LARGE = new Size("LARGE",2);

    private static Size[] VALUES = new Size[]{SMALL,MEDIUM,LARGE};

    private Size(String name, int ordinal){//构造方法只能私有
        super(name, ordinal);
    }

    public static Size[] values(){//编译器添加的
        Size[] values = new Size[VALUES.length];
        System.arraycopy(VALUES, 0, values, 0, VALUES.length);
        return values;
    }

    public static Size valueOf(String name){//调用父类方法
        return Enum.valueOf(Size.class, name);
    }
}
```

通过name来获取枚举，希望不存在时返回null，有这么几种写法https://dzone.com/articles/java-enum-lookup-by-name-or-field-without-throwing

```java
        /**
     * 拙劣的实现，异常不应该用于流程控制
     * */
    public static Color trycatchValueOf(String name) {
        try {
            return Color.valueOf(name);
        } catch (Exception ex) {
            return null;
        }
    }

    /**
     * 拙劣的实现，没用异常但是线性查找，这有性能问题吗？可能有，但是微乎其微，不过思想上来说不好
     * */
    public static Color iterationFindByName(String name) {
        for (Color color : Color.values()) {
            if (name.equals(color.name())) {
                return color;
            }
        }
        return null;
    }

      /**
     * 较优的实现，建立一个map，这里甚至可以不只是索引name，而是可以索引其他的的字段比如color
     * */
    private static final Map<String, Color> nameIndex =       Maps.newHashMapWithExpectedSize(Color.values().length);
    static {
        for (Color color : Color.values()) {
            nameIndex.put(color.name(), color);
        }
    }
    public static Color lookupByName(String name) {
        return nameIndex.get(name);
    }

        /**
     * 较优的实现，利用google的库，底层代码来看这里甚至使用了WeakReferences和WeakHashMaps
     * */
    public static Color getIfPresent(String name) {
        return Enums.getIfPresent(Color.class, name).orNull();
    }

        /**
     * 提取模板代码到公共的工具类里边
     * */
    private static final Function<String, Color> func =
            EnumUtil.lookupMap(Color.class, e -> e.name());
    public static Color lookupByDisplayNameUtil(String name) {
        return func.apply(name);
    }

public class EnumUtil {
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(Class<E> clazz, Function<E, T> mapper) {
        @SuppressWarnings("unchecked")
        E[] emptyArray = (E[]) Array.newInstance(clazz, 0);
        //EnumSet.allOf(clazz).toArray 将所有枚举类转为数组
        return lookupMap(EnumSet.allOf(clazz).toArray(emptyArray), mapper);
    }
    //入参是一个枚举数组、一个函数式接口（获得枚举的某个属性），出参仍然是一个函数式接口（获取map的）
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(E[] values, Function<E, T> mapper) {
        Map<T, E> index = Maps.newHashMapWithExpectedSize(values.length);
        for (E value : values) {
            //执行传入的函数式接口，此处就是e -> e.name()
            index.put(mapper.apply(value), value);
        }
        //返回的也是一个函数式接口，根据键值获取值(T key) -> index.get(key);
        return index::get;
    }
}
```

# 流式处理

```java
过滤：filter
去重：distinct
限制：limit
跳过：skip
映射：map
扁平化：flatmap
全查找：allMatch
任意满足：anyMatch
不存在：noneMathch
满足条件的第一个元素：findFirst
任意满足：findAny  
求和：sum
规约：reduce// 采用无初始值的重载版本，需要注意返回Optional
> reduce(0, Integer::sum);
> Optional<Integer> total=reduce(Integer::sum) 
求总数：Collectors.counting()   count()
求最大最小：
// 求最大年龄
Optional<Student> olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -> s1.getAge() - s2.getAge()));

// 进一步简化
Optional<Student> olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));

// 求最小年龄
Optional<Student> olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)));

求总和：Collectors.summingInt(Student::getAge)
求平均：Collectors.averagingInt(Student::getAge)
一次性求个数、总和、均值、最大值、最小值：Collectors.summarizingInt(Student::getAge)

字符串拼接：Collectors.joining(", ")
分组：Collectors.groupingBy(Student::getSchool)

多级分组：
Map<String, Map<String, List<Student>>> groups2 = students.stream().collect(
                Collectors.groupingBy(Student::getSchool,  // 一级分组，按学校
                Collectors.groupingBy(Student::getMajor)));// 二级分组，按专业

Map<String, Long> groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting()));//二级分组计数


分区：在分区中 key 只有两种情况：true 或 false
Map<Boolean, List<Student>> partition = students.stream().collect(Collectors.partitioningBy(student -> "武汉大学".equals(student.getSchool())));

排序：list.stream().sorted((a, b) -> a.compareTo(b))
       list.stream().sorted(Comparator.comparing(o -> o.action_time))//action_time是字符串

转Map：
Collectors.toMap(BotGroup::getBotId, Function.identity(), (u, v) -> v) //取字段做key，本身做value，key重复时取第二个
```

# Optional

- 消除连续判空频繁的if...if...

```java
//java8以前的判空
public static Date getGraduationTime(UserInfo userInfo){
     if (null != userInfo){
         if (null != userInfo.getEducation()){
             return userInfo.getEducation().getGraduationTime();
         }
     }
     return null;
 }

//使用java8的optional以后
public static Date getGraduationTime(UserInfo userInfo){
  return Optional.ofNullable(userInfo)
    .map(UserInfo::getEducation)
    .map(Education::getGraduationTime)
    .orElse(null);
}
```

- 接口

> - empty()
> 
> - of(T value)
>   
>   参数传入一个对象，返回一个Option对象，value不能为空，如果为null，将抛出空指针异常
> 
> - ofNullable(T value)
>   
>   参数传入一个对象，可以为空，如果为空，将返回一个空的Optional对象，就等于Optional.empty()，输出的值为`Optional.empty`,如果不为空，返回一个不为空的Optional对象
> 
> - get()
>   
>   获取Optional中的值，这个值也就是我们的值，Optional相当于就是一个外壳
> 
> - isPresent()
>   
>   判断Optional对象中是否有值，如果有值，返回true，没值返回false
> 
> - ifPresent(Consumer<? super T> consumer)
>   
>   ifPresent参数是一个函数式接口，无返回值，会将Optional中的值作为参数传递到
>   
>   ifPresent()中
> 
> - map(Function<? super T, ? extends U> mapper)
>   
>   参数是一个Function函数式接口，会将Optional中的值作为参数传递到map中，如果传入的值为空，则返回一空的Optional对象，相当于Optional.empty(), 如果不为空，我们可以返回一个可以描述描述结果的返回值(Optional中的值，这个值可以重新赋值)，如下面的返回一个tempUser
> 
> - flatMap(Function<? super T, Optional> mapper)
>   
>   如果Optional中值存在，那么返回一个基于Optional的值(如Optional)，如果Optional中的值不存在，则返回一空的Optional对象，相当于Optional.empty()，与map不同， map返回的是一个值，而flatMap返回一个基于Optional的值
>   
>   与map的区别在于flatmap会抹除Optional的嵌套
>   
>   ```java
>   Optional<String> optional = Optional.ofNullable(user).flatMap(OptionalTest::getFlatMap);
>          
>   Optional<Optional<String>> optional = Optional.ofNullable(user).map(OptionalTest::getFlatMap);
>   public static Optional<String> getFlatMap(User user){
>     return Optional.ofNullable(user).map(User::getUsername);
>   }
>   ```
> 
> - orElse(T other)
>   
>   如果Optional中的值不为空，则返回Optional中的值，如果为空，则返回other值
> 
> - orElseGet(Supplier<? extends T> other)
>   
>   如果Optional中存在值，则返回值，否则返回other调用的结果
> 
> - orElseThrow(Supplier<? extends X> exceptionSupplier)
>   
>   如果Optional中的值存在，则返回值，值不存在，则抛出异常函数Supplier中的异常

- Optional推荐作为方法结果输出，而不建议作为参数输入，意思就是用来预防返回的数据为空，而不是调用时候在参数里带上optional

# Jackson

忽略不要的字段

```java
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
```

# Maven

```shell
#查看某个包是怎么引入的
dependency:tree -Dverbose -Dincludes=org.mybatis:mybatis
```

- **dependenciesManagement**写在父pom里，只会标记版本号，子pom不会继承，子pom引入的时候不需要version，会循着父pom逐级往上找寻找到version。

- Maven的snapshot版本，主要是为了两方同时开发，不同于常规的版本，Maven 每次构建都会在远程仓库中检查新的快照。 版本如果下载到了本地，如果不更新版本号，是不会去远程仓库寻找新的jar包的，只会在本地找。

要想发布，需要在代码中加上：

```xml
<distributionManagement>
        <repository>
            <id>meituan-nexus-releases</id>
            <name>Meituan Nexus Releases Repository</name>
            <url>http://XXX/content/repositories/releases/</url>
        </repository>

        <snapshotRepository>
            <id>meituan-nexus-snapshots</id>
            <name>Meituan Nexus Snapshots Repository</name>
            <url>http://XXX/nexus/content/repositories/snapshots/</url>
        </snapshotRepository>
</distributionManagement>
```

- 版本仲裁
  
  > - 最短路径优先原则
  > - 相同路径优先声明原则
  > - 显示指定优先原则

- Scope
  
  > | 周期           | 阶段       | 是否打包    | 举例          |
  > | ------------ | -------- | ------- | ----------- |
  > | **compile**  | 编译、测试、运行 | 不参与打包   | 常见          |
  > | **test**     | 测试       | 不参与项目打包 | JUnit       |
  > | **provided** | 编译、测试    | 不参与项目打包 | servlet-api |
  > | **runtime**  | 测试、运行    | 参与打包    | JDBC驱动      |

# Lombok

[官网](https://projectlombok.org/features/)

- 常用注解
  
  > **@Data**：添加get、set，重写equal、hashcode、canequal、tostring
  > 
  > **@ToString**：注意这个注解可以用(exclude="column")排除不依赖某一列，(of="column")只依赖某一列
  > 
  > **@EqualsAndHashCode**: 可以在不生成的列上打上@EqualsAndHashCode.Exclude注解，如果父类的属性也要注解的话可以设置callSuper = true
  > 
  > **@NoArgsConstructor**
  > 
  > **@AllArgsConstructor**
  > 
  > **@Getter**
  > 
  > **@Setter**
  > 
  > **@Slf4j**:提供对应的 Logger 对象，变量名为 log
  > 
  > **@Builder，@Accessors**：提供链式创建
  > 
  > **@Synchronized**：同步方法
  > 
  > **@SneakyThrows**：自动抛受检异常，而无需显式在方法上使用throws语句
  > 
  > **@Getter(lazy=true)**”：双重校验、懒加载

# 日志

- 日志框架
  
  > 通常情况下，日志是由一个抽象层 + 实现层的组合来搭建的。
  > 
  > - 抽象门面框架，如：Commons Logging、SLF4J
  > - 实现的框架，如：Log4j，Log4j2，Logback，Jul
  > 
  > 在开发的时候不应该直接使用日志实现类，应该使用日志的抽象层。

- 统一日志框架
  
  > 一般情况下，在项目中存在着各种不同的第三方 jar ，且它们的日志选择也可能不尽相同，显然这样是不利于我们使用的，那么如果我们想为项目设置统一的日志框架该怎么办呢？
  > 
  > 1. 排除系统中的其他日志框架。
  > 
  > 2. 使用中间包替换要替换的日志框架。
  > 
  > 3. 导入我们选择的 SLF4J 实现。
  > 
  > 有些依赖方不使用slf4j门面,直接使用具体的日志实现怎么办？
  > 
  > - 需要增加具体实现日志包到slf4j桥接
  > - 什么是桥接？假如你正在开发应用程序所调用的组件当中已经使用了common-logging，这时你需要 jcl-over-slf4j.jar把日志信息输出重定向到 slf4j-api，slf4j-api再去调用slf4j实际依赖的日志组件。这个过程称为桥接。
  
  # web开发

## 包结构

> 一个代码库里边同时包含几个联系不大的业务时，每个业务又有一定的规模时，可以每个业务拆分一个模块出来；如果几个业务有联系时可以在基本的service、model下边拆一些业务的包出来。

> ```
> demo
> ├── starter-demo-app // 发布模块目录
> │   ├── pom.xml // 发布模块pom文件
> │   └── src
> │       ├── main
> │       │   ├── java
> │       │   │   └── pack
> |                |        |                └── annotation
> |       |   |       └── aop
> |       |   |       └── config
> |       |   |       └── constant
> |       |   |       └── controller
> |       |   |       └── crane
> |       |   |       └── exception
> |       |   |       └── service
> |       |   |       └── util
> |       |   |       └── model
> |       |   |               └── VO
> |       |   |               └── BO
> |       |   |               └── DTO
> |       |   |       └── dal
> |       |   |               └── entity
> |       |   |               └── example
> |       |   |               └── mapper
> |       |   |       └── mq
> |       |   |               └── consumer
> |       |   |               └── producer
> │       │   │       └── Application.java // Main Class 文件
> │       │   ├── profiles 
> │       │   │   ├── prod 
> │       │   │   │   ├── application.properties 
> │       │   │   │   └── log4j2.xml 
> │       │   │   └── test
> │       │   │       ├── application.properties 
> │       │   │       └── log4j2.xml 
> │       │   └── resources
> │       │       └── META-INF
> │       │           └── app.properties
> │       └── test
> │           ├── BaseTest.java
> │           └── ContextLoadsTest.java
> ├── service-1 module
> │   ├── pom.xml
> │   └── src
> |           └── main
> |                └── test
> ├── service-2 module
> ├── service-3 module
> ├── common module //定义公共服务模块
> └── pom.xml//总pom文件
> ```

## 1. 参数校验

这里比较全面 https://mp.weixin.qq.com/s/tEdUUfdndwktTMB8oDYU5g

```java
//JSR校验
@Data
public class StudentDTO {
    @NotEmpty(message = "用户姓名不允许为空")
    private String name;

    @Pattern(regexp = "1\\d{10}", message = "手机号格式不正确")
    private String telephone;

    @Email(message = "邮箱格式不正确")
    private String email;
}

//自定义注解校验
@Documented
@Retention(RUNTIME)
@Target({FIELD, METHOD, PARAMETER, TYPE})
@Constraint(validatedBy = NotConflictAccount.NotConflictAccountValidator.class)
public @interface NotConflictAccount {
    String message() default "用户名称不是123";

    Class<?>[] groups() default {};//校验分组

    Class<? extends Payload>[] payload() default {};

    class NotConflictAccountValidator implements ConstraintValidator<NotConflictAccount, StudentDTO> {

        @Override
        public boolean isValid(StudentDTO student, ConstraintValidatorContext constraintValidatorContext) {
            if (!student.getName().equals("123")) {
                return false;
            }
            return true;
        }
    }
}

//需要校验的步骤
@RestController
@RequestMapping("api/validate")
@Slf4j
@Validated
public class ValidationController {
    @PostMapping
    public Result test(@Valid @RequestBody @NotConflictAccount StudentDTO studentDTO){
        return Result.ok(studentDTO);
    }
}
```

- 建议：如果是简单参数校验直接使用参数校验，复杂且常用的使用自定义校验，更复杂的使用在业务代码中校验抛出异常然后全局统一捕获异常

## 2. 统一返回

```java
@Data
@AllArgsConstructor
@RequiredArgsConstructor
public class Result<T> implements Serializable {
    private static final long serialVersionUID = 1L;

    private Integer status;
    private String msg;
    private T data;

    public static <T> Result<T> ok(T data) {
        return new Result<>(HttpStatus.OK.value(), HttpStatus.OK.getReasonPhrase(), data);
    }
}

@GetMapping("/getAllStudent")
    @ResponseBody
    @Tag(name="getAllStudent")
    public Result<PageInfo<StudentVO>> studentList(@RequestParam(defaultValue = "1") Integer currentPage,
                                                   @RequestParam(defaultValue = "10") Integer pageSize) {
        return Result.ok(studentBiz.pageQuery(currentPage, pageSize));
    }
```

- 统一返回的另外一种写法，不需要再在controller里写result了而是借助ResponseBodyAdvice<Object>拦截通过beforeBodyWrite方法进行包装，对于不需要包装的可以打一个注解在support方法里进行排除

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.wyj.annotation.NotControllerResponseAdvice;
import com.wyj.response.Result;
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

@RestControllerAdvice(basePackages = {"com.wyj.controller.interceptController"})
public class ControllerResponseAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter methodParameter, Class<? extends HttpMessageConverter<?>> aClass) {
        // response是Result类型，或者注释了NotControllerResponseAdvice都不进行包装
        return !(methodParameter.getParameterType().isAssignableFrom(Result.class)||methodParameter.hasMethodAnnotation(NotControllerResponseAdvice.class));
    }

    @Override
    public Object beforeBodyWrite(Object data, MethodParameter returnType, MediaType mediaType, Class<? extends HttpMessageConverter<?>> aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {
        if (returnType.getGenericParameterType().equals(String.class)) {
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                // 将数据包装在ResultVo里后转换为json串进行返回
                return objectMapper.writeValueAsString(Result.ok(data));
            } catch (JsonProcessingException e) {
                throw new MeaningfulException(500, e.getMessage());
            }
        }
        // 否则直接包装成ResultVo返回
        return Result.ok(data);
    }
}

//需要排除的打下面的注解进行排除
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface NotControllerResponseAdvice {
}
```

## 3. 统一异常处理

```java
//统一的异常类
@Data
public class MeaningfulException extends RuntimeException {
    private static final long serialVersionUID = 3773770775333164849L;

    private final int errCode;

    public MeaningfulException(int errCode, String message) {
        super(message);
        this.errCode = errCode;
    }
}

//统一的异常处理中心
@RestControllerAdvice
@Slf4j
public class WebExceptionHandler {
    @ExceptionHandler(MeaningfulException.class)
    public Result<?> handleMeaningfulException(MeaningfulException ex) {
        log.error("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getLocalizedMessage());
        log.debug("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getLocalizedMessage(), ex);
        return new Result<>(ex.getErrCode(), ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(Exception.class)
    public Result<?> common(Exception ex) {
        log.error("handle exception. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle exception. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(Throwable.class)
    public Result<?> commonThrowable(Throwable ex) {
        log.error("handle throwable. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle throwable. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<?> handleValidException(MethodArgumentNotValidException ex) {
        log.error("valid exception{}",ex.getMessage());
        var stringBuilder = new StringBuilder();
        ex.getBindingResult().getAllErrors().stream().forEach(it->stringBuilder.append(it.getDefaultMessage()).append(","));
        return new Result<>(500,  stringBuilder.toString(),"");
    }
}

@RestController
@RequestMapping("api/exception")
@Slf4j
public class ExceptionController {
    @GetMapping("/meaningException")
    public void meaningfulException(){
        /**
         * 实际上会被WebExceptionHandler捕获处理
         * */
        throw new MeaningfulException(500,"接收话术录音文件不合法");
    }

    @GetMapping("/Exception")
    public void exception() throws Exception {
        throw new Exception("dadsda");
    }
}
```

## 4. 参数校验、统一异常处理与统一返回的关系

> - 参数校验有问题时会抛出异常，这个异常统一处理
> - 异常处理时将返回结果统一到统一返回的格式

## 5. 枚举传参

- 前后端传参，前端传数字，后端转为枚举值，传给前端时再转为数字
  
  ```java
  //前后端互转
  public enum GenderEnum {
      /*
      对应性别的枚举男性
      */
      MAN(1, "男"),
      /*
      对于性别的枚举女性
      */
      WOMAN(2, "女");
  
      private int code;
      private String value;
  
      GenderEnum(int code, String value) {
          this.code = code;
          this.value = value;
      }
  
      /**
       * 前端给的时候反序列化成枚举,注意的一点是如果不自己实现，spring也会默认转枚举，但是它是按照下标顺序取的
       * */
      @JsonCreator
      public static GenderEnum getGenderEnumByCode(Integer code) {
          switch (code) {
              case 1:
                  return WOMAN;
              default:
                  return MAN;
          }
      }
  
      /**
       * 给前端时序列化成数字
       * */
      @JsonValue
      public int getCode() {
          return code;
      }
  }
  ```
  
  - 后端与数据库传参，数据库存数字
  
  ```java
  //基于mybatis互转
  public class GenderEnumHandler extends BaseTypeHandler<GenderEnum> {
  
      /**
       * 写库时写枚举码
       * */
      @Override
      public void setNonNullParameter(PreparedStatement preparedStatement, int i, GenderEnum genderEnum, JdbcType jdbcType) throws SQLException {
          preparedStatement.setInt(i, genderEnum.getCode());
      }
  
      /**
       * 使用列名，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(ResultSet resultSet, String s) throws SQLException {
          return GenderEnum.getGenderEnumByCode(resultSet.getInt(s));
      }
  
      /**
       * 使用下标，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(ResultSet resultSet, int i) throws SQLException {
          return GenderEnum.getGenderEnumByCode(resultSet.getInt(i));
      }
  
      /**
       * 存储过程专用，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
          return GenderEnum.getGenderEnumByCode(callableStatement.getInt(i));
      }
  }
  
  //插入这个转换器
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
      <typeHandlers>
          <typeHandler handler="com.wyj.handler.GenderEnumHandler" javaType="com.wyj.enums.GenderEnum" />
      </typeHandlers>
  </configuration>
  
   <resultMap id="BaseResultMap" type="com.web.entity.Student">
    //用于查询时转换
      <result column="sex" jdbcType="INTEGER" property="sex" typeHandler="com.web.handler.GenderEnumHandler" /> 
    </resultMap>
  
    <insert id="insert" parameterType="com.web.entity.Student">
      insert into student (sex)
      //用于插入时转换
      values (#{sex,jdbcType=INTEGER,typeHandler=com.web.handler.GenderEnumHandler})
    </insert>
  ```
  
  - 当用枚举传参时的一些转化
  
  > - 涉及到前端、后端、数据库传参时传什么、存什么
  > - 前端给后端传：传枚举码转化为枚举类在代码中使用，涉及到枚举值转枚举类
  > - 后端给前端：传枚举码给前端，涉及到枚举类转枚举值
  > - 后端给数据库：存枚举码，涉及到枚举类转枚举值
  > - 数据库给后端：将查出来的枚举码转为枚举类使用
  > 
  > 综上来看，只有代码中使用枚举类，传给前端以及存到数据库的都应该是枚举值，每次涉及到正反两方面的转化。
  > 
  > - 与数据库互转时，一般使用ORM框架插件处理
  > - 与前端互转时，使用一些序列化注解辅助

## 6. 数据拷贝

```java
//基于mapstruct的数据转换
@Mapper
public interface StudentConverter {
    StudentConverter MAPPER=Mappers.getMapper(StudentConverter.class);
    StudentVO toVo(Student student);
    List<StudentVO> entity2VO(List<Student> student);
}
```

> 但是同时使用lombok与mapstruct有时会有问题，主要原因是这两个都是在编译阶段起作用，因此需要引入插件处理，有时还要保证顺序

```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <annotationProcessorPaths>
      <!--保证顺序-->
      <path>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.20</version>
      </path>
      <path>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct-processor</artifactId>
        <version>${org.mapstruct.version}</version>
      </path>
    </annotationProcessorPaths>
  </configuration>
</plugin>
```

## 7. 切面与注解

基于注解做切面，可以用来打日志、限流等操作

```java
//定义一个注解
@Order(Ordered.HIGHEST_PRECEDENCE)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface Tag {
    // 资源名称，用于描述接口功能
    String name() default "";
}

//对打了注解的做处理
@Aspect
@Component
@Slf4j
public class TagAspect {

    /**
     打了com.annotation.ApiLimit的作为一个切面
     * */
    @Pointcut("@annotation(com.wyj.annotation.Tag)")
    public void pointcut() {
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        /**
         * 得到请求
         * */
        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();
        /**
         * 得到方法签名
         * */
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        /**
         * 得到方法
         * */
        Method signatureMethod = signature.getMethod();
        Tag tag = signatureMethod.getAnnotation(Tag.class);
        String name = tag.name();
        log.info("http method {}", name);
        return joinPoint.proceed();
    }
}
```

## 8. 分片处理

```java
final var partion = Lists.partition(dataList, split);
partion.forEach(it -> {
  处理 it
});
```

## 9. 分页处理Mybatis、PageHelper

```java
PageHelper.startPage(currentPage, pageSize);
        final List<AggregateCityResult> res = 查询;
        PageInfo pageAggregateCityResults = new PageInfo(res);
        final List<CityVO> cityVOS = new ArrayList<>();
        res.forEach(data->{
            //这里做转换
            final var cityVO = new CityVO();
            ...
            cityVOS.add(cityVO);
        });
        //这里重写分页后的list
        pageAggregateCityResults.setList(cityVOS);
        return pageAggregateCityResults;
```

## 10.下载文件

```java
@GetMapping("/test10")
    public void trendAnalyseReport(@RequestParam("template") String template,
                                       HttpServletResponse response
    ) throws IOException {
        //log.info("input param {}", sortClause);
        final var workbook = overViewBiz.trendAnalyseReport(template);
        var name = template == null ? "" : template +"_"+ LocalDate.now();
        transFile(response, workbook, name+".xlsx");
    }

private void transFile(HttpServletResponse response, Workbook workbook, String filename)  {
        if (workbook != null) {
            response.setHeader("Content-Disposition", "attachment;filename=" + filename);
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8");
            response.setHeader("Pragma", "no-cache");
            response.setHeader("Cache-Control", "no-cache");
            response.setDateHeader("Expires", 0);
            try (final var out = response.getOutputStream()) {
                workbook.write(out);
            } catch (IOException e) {
                throw new BizException(500, "excel导出失败", e);
            }
        } else {
            throw new BizException(500, "excel导出为空");
        }
    }
```

## 11. 重试

```java
@Service
@Slf4j
public class RetryService {

  //异常时重试，最大重试2次，第一次重试时每次暂停2秒，以后延迟1.5倍（每次隔2,3,4.5秒后重试）
    @Retryable(value = Exception.class, maxAttempts = 2, backoff = @Backoff(delay = 2000, multiplier = 1.5))
    public void test() throws Exception {
        int i = new Random().nextInt(2);
        log.info("random num:{}", i);
        if (i==1){
            throw new Exception("异常了");
        }
        log.info("正常执行");
    }

    //重试最大次数以后默认会执行这个方法,参数要与上述异常一致，需要写在同一个类里面
    @Recover
    public void recover(Exception e) {
        log.info("回调方法执行！");
    }
}
```

## 12. 异步

```java
@Service
public class AsyncService {
    @Async("myExcutor")//使用自己定义的线程池
    public void sleep() throws InterruptedException {
        Thread.sleep(5000);
    }
}

@Configuration
public class ExecutorConfig {
    @Bean
    public Executor myExcutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(1);
        executor.setMaxPoolSize(3);
        executor.setQueueCapacity(5);
        executor.setKeepAliveSeconds(10);
        executor.setThreadNamePrefix("mafka-producer");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

//在启动类上加上@EnableAsync
```

## 13. 测试

可能用到的一些依赖

```xml
<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-test</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-test</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-test-autoconfigure</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-core</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>com.jayway.jsonpath</groupId>
  <artifactId>json-path</artifactId>
</dependency>
```

service层mock dao层数据

```java
package com.wyj.controller;

import com.wyj.dao.PassiveCallInfoDao;
import com.wyj.entity.PassiveCallInfo;
import com.wyj.service.PassiveCallInfoService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit4.SpringRunner;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.mockito.Mockito.when;
import static org.hamcrest.core.IsEqual.equalTo;

/**
 * @author wyj
 */

@RunWith(SpringRunner.class)
@SpringBootTest
public class ServiceMock {
    @Autowired
    private PassiveCallInfoService passiveCallInfoService;
    @MockBean
    private PassiveCallInfoDao passiveCallInfoDao;

    @Test
    public void test1(){//搭配mock使用
        final var passiveCallInfo=new PassiveCallInfo();
        passiveCallInfo.setComplainTag("true");
        when(passiveCallInfoDao.selectByPrimaryKey(32L)).thenReturn(passiveCallInfo);
        assertThat(passiveCallInfoService.selectByPrimaryKey(32L).getComplainTag(),equalTo("true"));
    }

}
```

service层直接测试

```java
package com.wyj.controller;

import com.wyj.service.PassiveCallInfoService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.IsEqual.equalTo;

@RunWith(SpringRunner.class)
@SpringBootTest
public class ServiceFact {
    @Autowired
    private PassiveCallInfoService passiveCallInfoService;

    @Test
    public void test2(){
        assertThat(passiveCallInfoService.selectByPrimaryKey(32L).getComplainTag(),equalTo("32"));
    }
}
```

controller层mock service层数据

```java
package com.wyj.controller;

import com.wyj.dao.PassiveCallInfoDao;
import com.wyj.entity.PassiveCallInfo;
import com.wyj.service.PassiveCallInfoService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit4.SpringRunner;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.mockito.Mockito.when;
import static org.hamcrest.core.IsEqual.equalTo;

/**
 * @author wyj
 */

@RunWith(SpringRunner.class)
@SpringBootTest
public class ServiceMock {
    @Autowired
    private PassiveCallInfoService passiveCallInfoService;
    @MockBean
    private PassiveCallInfoDao passiveCallInfoDao;

    @Test
    public void test1(){//搭配mock使用
        final var passiveCallInfo=new PassiveCallInfo();
        passiveCallInfo.setComplainTag("true");
        when(passiveCallInfoDao.selectByPrimaryKey(32L)).thenReturn(passiveCallInfo);
        assertThat(passiveCallInfoService.selectByPrimaryKey(32L).getComplainTag(),equalTo("true"));
    }

}
```

controller层直接测试

```java
package com.wyj.controller;

import com.wyj.service.PassiveCallInfoService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mock.web.MockHttpSession;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringRunner.class)
@SpringBootTest
/**
 * 1 这个注解用于集成测试，也就是默认会加载完整的Spring应用程序并注入所有所需的bean。一般会通过带有@SpringBootApplication的配置类来实现。
 * 2 由于会加载整个应用到Spring容器中，整个启动过程是非常缓慢的（10+秒起步），一般会用于集成测试，可以使用TestRestTemplete或者MockMvc来发起请求并验证响应结果。
 * 3 SpringBootTest中的也可以使用Mockito等Mock工具来对某些bean进行mock，但是一般不会只对单个层进行测试，推荐用于单个应用的端到到集成测试。
 * 4 如果涉及到第三方依赖，如数据库、服务间调用、Redis等，可以考虑服务虚拟化方案。
 */
public class ControllerFact {

    private MockMvc mockMvc;

    @Autowired
    private WebApplicationContext wac;

    @Before
    public void setupMockMvc(){
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象
    }

    @Test
    public void test4() throws Exception {
        final var authResult=mockMvc.perform(MockMvcRequestBuilders.get("/hello2").param("id", String.valueOf(32L)))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.complainTag").value("32"))
                .andReturn().getResponse().getContentAsString();
        System.out.println("返回结果"+authResult);
    }
}
```

使用http测试

```java
package com.wyj.controller;

import com.wyj.entity.PassiveCallInfo;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.web.client.RestTemplate;

import java.util.HashMap;
import java.util.Map;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.IsEqual.equalTo;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
public class HttpRequestTest {
    @LocalServerPort//随机端口有助于在测试环境中避免冲突
    private int port;

    @Autowired
    RestTemplateBuilder builder;

    private RestTemplate restTemplate;

    @Before
    public void restTemplate() {
        restTemplate=builder.build();
    }

    @Test
    public void test1(){
        String x=restTemplate.getForObject("http://localhost:"+port+"/hello",String.class);
        assertThat(x, equalTo("hello"));
    }

    @Test
    public void test2(){
        Map<String, String> params = new HashMap<>();
        params.put("id", "32");
        PassiveCallInfo x=restTemplate.getForObject("http://localhost:"+port+"/hello2"+"?id={id}", PassiveCallInfo.class,params);
        assertThat(x.getTargetNumToken(), equalTo("321"));
    }
}
```

## 14. 接口版本

```java
//接口版本值的存储位置
//通过URL Path实现版本控制，直观也最不容易出错
@GetMapping("/v1/api/user")
public int right1(){
}
//通过QueryString中的version参数实现版本控制，不易携带，不太推荐作为公开API的版本策略
@GetMapping(value = "/api/user", params = "version=2")
public int right2(@RequestParam("version") int version) {
}
//通过请求头中的X-API-VERSION参数实现版本控制，比较没有侵入性，如果仅仅是部分接口需要进行版本控制，可以考虑这种方式。
@GetMapping(value = "/api/user", headers = "X-API-VERSION=3")
public int right3(@RequestHeader("X-API-VERSION") int version) {
}
```

处理接口的版本号

```java
//首先，创建一个注解来定义接口的版本。@APIVersion自定义注解可以应用于方法或Controller上：
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface APIVersion {
    String[] value();
}

//然后，定义一个APIVersionHandlerMapping类继承RequestMappingHandlerMapping。
//RequestMappingHandlerMapping的作用，是根据类或方法上的@RequestMapping来生成RequestMappingInfo的实例。我们覆盖registerHandlerMethod方法的实现，从@APIVersion自定义注解中读取版本信息，拼接上原有的、不带版本号的URL Pattern，构成新的RequestMappingInfo，来通过注解的方式为接口增加基于URL的版本号：
public class APIVersionHandlerMapping extends RequestMappingHandlerMapping {
    @Override
    protected boolean isHandler(Class beanType) {
        return AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);
    }


    @Override
    protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {
        Class controllerClass = method.getDeclaringClass();
        //类上的APIVersion注解
        APIVersion apiVersion = AnnotationUtils.findAnnotation(controllerClass, APIVersion.class);
        //方法上的APIVersion注解
        APIVersion methodAnnotation = AnnotationUtils.findAnnotation(method, APIVersion.class);
        //以方法上的注解优先
        if (methodAnnotation != null) {
            apiVersion = methodAnnotation;
        }

        String[] urlPatterns = apiVersion == null ? new String[0] : apiVersion.value();

        PatternsRequestCondition apiPattern = new PatternsRequestCondition(urlPatterns);
        PatternsRequestCondition oldPattern = mapping.getPatternsCondition();
        PatternsRequestCondition updatedFinalPattern = apiPattern.combine(oldPattern);
        //重新构建RequestMappingInfo
        mapping = new RequestMappingInfo(mapping.getName(), updatedFinalPattern, mapping.getMethodsCondition(),
                mapping.getParamsCondition(), mapping.getHeadersCondition(), mapping.getConsumesCondition(),
                mapping.getProducesCondition(), mapping.getCustomCondition());
        super.registerHandlerMethod(handler, method, mapping);
    }
}

//最后，通过实现WebMvcRegistrations接口，来生效自定义的APIVersionHandlerMapping
//  /v4/api/user
@SpringBootApplication
public class CommonMistakesApplication implements WebMvcRegistrations {
...
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new APIVersionHandlerMapping();
    }
}

//调用
@GetMapping(value = "/api/user")
@APIVersion("v4")
public int right4() {
    return 4;
}

 //使用框架来明确API版本的指定策略，不仅实现了标准化，更实现了强制的API版本控制。
```

也可以使用请求头控制

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface APIVersion {
    String value();

    String headerKey() default "X-API-VERSION";
}

public class APIVersionCondition implements RequestCondition<APIVersionCondition> {

    @Getter
    private String apiVersion;
    @Getter
    private String headerKey;

    public APIVersionCondition(String apiVersion, String headerKey) {
        this.apiVersion = apiVersion;
        this.headerKey = headerKey;
    }

    @Override
    public APIVersionCondition combine(APIVersionCondition other) {
        return new APIVersionCondition(other.getApiVersion(), other.getHeaderKey());
    }

    @Override
    public APIVersionCondition getMatchingCondition(HttpServletRequest request) {
        String version = request.getHeader(headerKey);
        return apiVersion.equals(version) ? this : null;
    }

    @Override
    public int compareTo(APIVersionCondition other, HttpServletRequest request) {
        return 0;
    }
}

public class APIVersionHandlerMapping extends RequestMappingHandlerMapping {
    @Override
    protected boolean isHandler(Class<?> beanType) {
        return AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);
    }

    @Override
    protected RequestCondition<APIVersionCondition> getCustomTypeCondition(Class<?> handlerType) {
        APIVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, APIVersion.class);
        return createCondition(apiVersion);
    }

    @Override
    protected RequestCondition<APIVersionCondition> getCustomMethodCondition(Method method) {
        APIVersion apiVersion = AnnotationUtils.findAnnotation(method, APIVersion.class);
        return createCondition(apiVersion);
    }

    private RequestCondition<APIVersionCondition> createCondition(APIVersion apiVersion) {
        return apiVersion == null ? null : new APIVersionCondition(apiVersion.value(), apiVersion.headerKey());
    }
}

@SpringBootApplication
public class CommonMistakesApplication implements WebMvcRegistrations {

    public static void main(String[] args) {
        SpringApplication.run(CommonMistakesApplication.class, args);
    }

    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new APIVersionHandlerMapping();
    }
}
```

## 其它技巧

springboot启动时不报错，直接退出，使用trycatch包住启动代码，查看异常

```java
try {
  SpringApplication.run(Pallas.class, args);
}catch(Throwable e) {
  e.printStackTrace();
}
```

```java
//springboot读取resource下的文件
public void testReadFile() throws IOException {
//        ClassPathResource classPathResource = new ClassPathResource("resource.properties");
        Resource resource = new ClassPathResource("resource.properties");
        InputStream is = resource.getInputStream();
        InputStreamReader isr = new InputStreamReader(is);
        BufferedReader br = new BufferedReader(isr);
        String data = null;
        while((data = br.readLine()) != null) {
            System.out.println(data);
        }

        br.close();
        isr.close();
        is.close();
    }
```

# 常用的轮子

常用库

1. 使用Objects.equals(strA, strB)比较两个对象是否相等，避免对左边对象判空
2. 使用commons-lang3操作字符串，包装临时对象Pair与Trible
3. 使用commons-collections集合工具类操作集合
4. 使用common-beanutils 操作对象，进行对象和map互转
5. 使用commons-io 文件流处理，读文件、写文件以及复制文件等
6. 使用Guava操作集合，新建、切分集合，使用Multimap可以一个key映射多个value的HashMap，使用BiMap一种连value也不能重复的HashMap，实质是双向的映射，kv可以实现互转，Table可以有两个key的Hashmap，Multiset一种用来计数的Set

## Collections

> java.util.Collections
> 
> 用于求最大、最小、排序、翻转、转换线程安全、返回空集合、做二分查找、转换为不可修改集合

## CollectioinUtils

> 一个是spring自带的：org.springframework.util.CollectionUtils
> 
> 一个是apache下的：org.apache.commons.collections.CollectionUtils，这个提供的更多、更全面
> 
> 提供了集合判空、交并补等等

## Lists

> com.google.common.collect`包下的集合工具：`Lists
> 
> 创建空集合、快速初始化集合、笛卡尔积、分页、流处理、翻转

## Objects

> java自带的工具类java.util.Objects
> 
> 对象判空、判空抛异常、判断对象是否相等、获取hash码

## BooleanUtils

> commons-lang3：BooleanUtils
> 
> 判断true、false、非true、false、转换数字、包装类转换、

## StringUtils

> org.apache.commons.lang3包下的`StringUtils
> 
> 判空、分割、判断是否纯数字、集合拼接、

## Assert

> Spring提供
> 
> 断言参数是否为空、断言集合是否为空

## IOUtils

> org.apache.commons.io包下的`IOUtils
> 
> 读文件为字符串、字节数组、迭代器、写文件、拷贝文件

## MDC

> org.slf4j
> 
> 用来传递线程安全的诊断日志的容器

## ClassUtils

> Spring提供的
> 
> 获取对象所有接口、某个类的包名、某个类是否是内部类、是否是代理对象

## BeanUtils

> Spring提供的
> 
> 拷贝对象、实例化·、获取指定类的指定方法、指定方法的参数

## ReflectionUtils

> Spring提供的
> 
> 获取方法、字段、执行方法、字段是否常量、是否是Equals方法

## Base64Utils

> Spring提供的
> 
> decode、ecode

## StandardCharsets

> java.nio.charset
> 
> 转换字符编码

## DigestUtils

> `org.apache.commons.codec.digest`包下的`DigestUtils`类。
> 
> 各种加密

## SerializationUtils

> org.springframework.util包下的`SerializationUtils
> 
> 序列化、反序列化

## HttpStatus

> `org.springframework.http`包下的HttpStatus枚举
> 
> 提供常见的状态码

# 各种O

## 概念

- VO（`View Object`）：**视图对象**，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。
- DTO（`Data Transfer Object`）：**数据传输对象**，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，更符合泛指用于展示层与服务层之间的数据传输对象。
- BO（`Business Object`）：**业务对象**，把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。
- PO（`Persistent Object`）：**持久化对象**，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。
- DO（`Domain Object`）：**领域对象**，就是从现实世界中抽象出来的有形或无形的业务实体。

## VO与DTO

某公司有一个后台服务，服务层有一个getUser的方法返回一个系统用户，包含sex(性别)、年龄。对于服务层来说，DTO只从语义上定义，可能是这样的：

```json
{
 "gender":"男",
 "age":35
}
```

但这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，比如管理端要求显示准确的年龄，而应用端为了保护客户隐私，只需要显示一个年龄段即可。

管理端VO：

```json
{
 "gender":"男",
 "age":35
}
```

应用端VO：

```json
{
 "gender":"男",
 "age":30~40
}
```

DTO很有存在的必要，根据职责单一原则，服务层只负责业务，与具体的表现形式无关，DTO不应该出现与表现形式的耦合，DTO定义的是原始数据，VO再对DTO数据进行解释。这下VO和DTO用法就清晰很多了。

## BO和PO

PO-1是交易记录对象，PO-2是登录记录对象，PO-3是商品浏览记录对象，PO-4是添加购物车记录对象，PO-5是搜索记录对象，BO是个人网站行为对象，BO对象：{PO-1;PO-2;PO-3;PO-4;PO-5}。这样做的优点不言而喻，维护代码的时候查看BO，就能知道这块逻辑涉及多少表（PO）。

## BO和DTO

BO是业务对象，DTO是数据传输对象，虽然BO也可以排列组合数据，但它的功能是对内的，比如上个例子中的BO对象包括{PO-1;PO-2;PO-3;PO-4;PO-5}还有其他字段属性，但在提供对外接口时，BO对象中的某些属性对象可能用不到或者不方便对外暴露，那么此时DTO只需要在BO的基础上，抽取自己需要的数据，然后对外提供。

在这个关系上，通常不会有数据内容的变化，内容变化要么在BO内部业务计算的时候完成，要么在解释VO的时候完成。

<img src="https://s2.loli.net/2022/03/26/Q4F1KhOVewN9YUP.png" alt="各种O的关系" style="zoom: 33%;" />

另附这些概念命名规范：

- 数据对象：xxxPO，xxx即为数据表名。(也可DO)
- 数据传输对象：xxxDTO，xxx为业务领域相关的名称。
- 展示对象：xxxVO，xxx一般为网页名称。
- 业务对象：xxxBO，xxx是业务名称。

## 怎么优雅的转化O？

> 尽量使用一些工具，org.springframework.beans.BeanUtils#copyProperties，mapstruct等，org.springframework.beans.BeanUtils#copyProperties是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。
> 
> 转化的语义：
> 
> ```java
> @PostMapping
> public User addUser(UserInputDTO userInputDTO){
> User user = new User();
> //虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好
> BeanUtils.copyProperties(userInputDTO,user);
> return userService.addUser(user);
> }
> 
> //这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中
> @PostMapping
> public User addUser(UserInputDTO userInputDTO){
>    User user = convertFor(userInputDTO);
>    return userService.addUser(user);
> }
> 
> private User convertFor(UserInputDTO userInputDTO){
>    User user = new User();
>    BeanUtils.copyProperties(userInputDTO,user);
>    return user;
> }
> 
> //实际开发中我们发现有很多这样的操作以后，那么应该定义好一个接口，让所有这样的操作都有规则的进行。果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。
> public interface DTOConvert<S,T> {
> T convert(S s);
> }
> public class UserInputDTOConvert implements DTOConvert {
> @Override
> public User convert(UserInputDTO userInputDTO) {
> User user = new User();
> BeanUtils.copyProperties(userInputDTO,user);
> return user;
> }
> }
> @RequestMapping("/v1/api/user")
> @RestController
> public class UserApi {
> @Autowired
> private UserService userService;
> 
> @PostMapping
> public User addUser(UserInputDTO userInputDTO){
>   User user = new UserInputDTOConvert().convert(userInputDTO);
>   return userService.addUser(user);
> }
> }
> 
> //我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的。所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：
> @PostMapping
> public UserOutputDTO addUser(UserInputDTO userInputDTO){
>   User user = new UserInputDTOConvert().convert(userInputDTO);
>   User saveUserResult = userService.addUser(user);
>   UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult);
>   return result;
> }
> //这样你的 API 才更健全。
> 
> User user = new UserInputDTOConvert().convert(userInputDTO);
> 
> //你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢？
> public class UserInputDTO {
> private String username;
> private int age;
> 
> public String getUsername() {
>   return username;
> }
> 
> public void setUsername(String username) {
>   this.username = username;
> }
> 
> public int getAge() {
>   return age;
> }
> 
> public void setAge(int age) {
>   this.age = age;
> }
> 
> 
> public User convertToUser(){
>   UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert();
>   User convert = userInputDTOConvert.convert(this);
>   return convert;
> }
> 
> private static class UserInputDTOConvert implements DTOConvert<UserInputDTO,User> {
>   @Override
>   public User convert(UserInputDTO userInputDTO) {
>       User user = new User();
>       BeanUtils.copyProperties(userInputDTO,user);
>       return user;
>   }
> }
> 
> }
> 
> //这样原来的实现由
> User user = new UserInputDTOConvert().convert(userInputDTO);
> User saveUserResult = userService.addUser(user);
> //转化为
> User user = userInputDTO.convertToUser();
> User saveUserResult = userService.addUser(user);
> //我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。
> 
> //Guava com.google.common.base.Convert有一段这样的定义
> public abstract class Converter<A, B> implements Function<A, B> {
> protected abstract B doForward(A a);
> protected abstract A doBackward(B b);
> //其他略
> }
> //可以把原来代码中的部分改为下列实现
> private static class UserInputDTOConvert extends Converter<UserInputDTO, User> {
>    @Override
>    protected User doForward(UserInputDTO userInputDTO) {
>            User user = new User();
>            BeanUtils.copyProperties(userInputDTO,user);
>            return user;
>    }
> 
>    @Override
>    protected UserInputDTO doBackward(User user) {
>            UserInputDTO userInputDTO = new UserInputDTO();
>            BeanUtils.copyProperties(user,userInputDTO);
>            return userInputDTO;
>    }
> }
> 
> //再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：
> public class UserDTO {
> @NotNull
> private String username;
> @NotNull
> private int age;
>   //其他代码略
> }
> @PostMapping
> public UserDTO addUser(@Valid UserDTO userDTO){
>       User user =  userDTO.convertToUser();
>       User saveResultUser = userService.addUser(user);
>       UserDTO result = userDTO.convertFor(saveResultUser);
>       return result;
> }
> 
> //我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常（带有错误码的异常）。
> @PostMapping
> public UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult){
> checkDTOParams(bindingResult);
> 
> User user =  userDTO.convertToUser();
> User saveResultUser = userService.addUser(user);
> UserDTO result = userDTO.convertFor(saveResultUser);
> return result;
> }
> private void checkDTOParams(BindingResult bindingResult){
> if(bindingResult.hasErrors()){
>        //throw new 带验证码的验证错误异常
> }
> }
> 
> //使用链式调用 lombok的@Accessors(chain = true)
> tudent student = new Student()
>   .setAge(24)
>   .setName("zs");
> 
> //接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）：
> @Accessors(chain = true)
> @Setter
> @Getter
> @RequiredArgsConstructor(staticName = "ofName")
> public class Student {
> @NonNull private String name;
> private int age;
> }
> 
> 测试代码：
> Student student = Student.ofName("zs");
> 
> //当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：
> @RequiredArgsConstructor(staticName = "of")
> public class Student {
>   @NonNull private String name;
> }
> 
> 测试代码：
> Student student = Student.of("zs");
> 
> 当然他仍然是支持链式调用的：
> Student student = Student.of("zs").setAge(24);
> 
> //使用lombok的@Builder
> ```

## domain还是entity

> domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的。
> 
> 所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为：com.xxx.entity。

## 贫血模型 or 领域模型

> 领域模型是对领域内的概念类或现实世界中对象的可视化表示。
> 
> 贫血模型是指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层。贫血模型的缺点是不够面向对象，领域对象只是作为保存状态或者传递状态使用，它是没有生命的，只有数据没有行为的对象不是真正的对象。
> 
> web开发中，贫血模型一般这样使用：
> 
> （1）铺设扁平的原子业务逻辑层，即简单的CRUD操作（含批量数据操作）
> 
> （2）特定业务清晰的逻辑通过Facade层来组装原子操作实现。
> 
> （3）给业务逻辑层实施模块划分，保持模块之间的松耦合的关系。
> 
> **举例说明**
> 
> **原子业务逻辑层（Service）提供了用户模型的条件查询方法：**
> 
> List<User> queryUser(Condition con)
> 
> **Facade层则提供了一种特定的业务场景的分子接口，满足18岁的中国公民，内部实现调用的正是上述的原子接口：**
> 
> List<User> queryAdultChinese()
> 
> Facade、Service层纵向划分为几个大的领域包：用户、内容和产品。

## 业务驱动技术 or 技术驱动业务

> 业务驱动技术 or 技术驱动业务 ？其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置。
> 
> **业务驱动技术：**如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。
> 
> **技术驱动业务：**如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益。
> 
> 比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。
> 
> 我相信大部分人还都处于业务驱动技术的方向吧。所以你既然不能驱动业务，那就请拥抱业务变化吧。

# 消除if...else

## 使用策略模式

```java
public interface IPay {  
    void pay();  
}  

@Service  
public class AliaPay implements IPay {  
     @Override  
     public void pay() {  
        System.out.println("===发起支付宝支付===");  
     }  
}  

@Service  
public class WeixinPay implements IPay {  
     @Override  
     public void pay() {  
         System.out.println("===发起微信支付===");  
     }  
}  

@Service  
public class JingDongPay implements IPay {  
     @Override  
     public void pay() {  
        System.out.println("===发起京东支付===");  
     }  
}  

@Service  
public class PayService {  
     @Autowired  
     private AliaPay aliaPay;  
     @Autowired  
     private WeixinPay weixinPay;  
     @Autowired  
     private JingDongPay jingDongPay;  

     //问题在于如果支付方式越来越多，比如：又加了百度支付、美团支付、银联支付等等，就需要改toPay方法的代码，增加新的else...if判断，判断多了就会导致逻辑越来越多？这里违法了设计模式六大原则的：开闭原则 和 单一职责原则
     public void toPay(String code) {  
         if ("alia".equals(code)) {  
             aliaPay.pay();  
         } else if ("weixin".equals(code)) {  
              weixinPay.pay();  
         } else if ("jingdong".equals(code)) {  
              jingDongPay.pay();  
         } else {  
              System.out.println("找不到支付方式");  
         }  
     }  
}
```

## 使用注解

```java
@Retention(RetentionPolicy.RUNTIME)  
@Target(ElementType.TYPE)  
public @interface PayCode {  

     String value();    
     String name();  
}

@PayCode(value = "alia", name = "支付宝支付")  
@Service  
public class AliaPay implements IPay {  

     @Override  
     public void pay() {  
         System.out.println("===发起支付宝支付===");  
     }  
}  


@PayCode(value = "weixin", name = "微信支付")  
@Service  
public class WeixinPay implements IPay {  

     @Override  
     public void pay() {  
         System.out.println("===发起微信支付===");  
     }  
} 


@PayCode(value = "jingdong", name = "京东支付")  
@Service  
public class JingDongPay implements IPay {  

     @Override  
     public void pay() {  
        System.out.println("===发起京东支付===");  
     }  
}

//
@Service  
public class PayService2 implements ApplicationListener<ContextRefreshedEvent> {  

     private static Map<String, IPay> payMap = null;  

     @Override  
     public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {  
         ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();  
         Map<String, Object> beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode.class);  

         if (beansWithAnnotation != null) {  
             payMap = new HashMap<>();  
             beansWithAnnotation.forEach((key, value) ->{  
                 String bizType = value.getClass().getAnnotation(PayCode.class).value();  
                 payMap.put(bizType, (IPay) value);  
             });  
         }  
     }  

     public void pay(String code) {  
        payMap.get(code).pay();  
     }  
}
```

## 动态拼接名称

```java
@Service  
public class PayService3 implements ApplicationContextAware {   
     private ApplicationContext applicationContext;  
     private static final String SUFFIX = "Pay";  

     @Override  
     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
        this.applicationContext = applicationContext;  
     }  

     public void toPay(String payCode) {  
         ((IPay) applicationContext.getBean(getBeanName(payCode))).pay();  
     }  

     public String getBeanName(String payCode) {  
         return payCode + SUFFIX;  
     }  
}
```

## 模板方法判断

```java
@Service  
public class PayService3 implements ApplicationContextAware {   
     private ApplicationContext applicationContext;  
     private static final String SUFFIX = "Pay";  

     @Override  
     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
        this.applicationContext = applicationContext;  
     }  

     public void toPay(String payCode) {  
         ((IPay) applicationContext.getBean(getBeanName(payCode))).pay();  
     }  

     public String getBeanName(String payCode) {  
         return payCode + SUFFIX;  
     }  
}

@Service  
public class PayService4 implements ApplicationContextAware, InitializingBean {  

     private ApplicationContext applicationContext;  
     private List<IPay> payList = null;  

     @Override  
     public void afterPropertiesSet() throws Exception {  
         if (payList == null) {  
             payList = new ArrayList<>();  
             Map<String, IPay> beansOfType = applicationContext.getBeansOfType(IPay.class);  

             beansOfType.forEach((key, value) -> payList.add(value));  
         }  
     }  

     @Override  
     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
        this.applicationContext = applicationContext;  
     }  

     public void toPay(String code) {  
         for (IPay iPay : payList) {  
             if (iPay.support(code)) {  
                iPay.pay();  
             }  
         }  
     }  
}
```

## 策略+工厂模式

```java
public interface IPay {
    void pay();
}

@Service
public class AliaPay implements IPay {

    @PostConstruct
    public void init() {
        PayStrategyFactory.register("aliaPay", this);
    }


    @Override
    public void pay() {
        System.out.println("===发起支付宝支付===");
    }

}

@Service
public class WeixinPay implements IPay {

    @PostConstruct
    public void init() {
        PayStrategyFactory.register("weixinPay", this);
    }

    @Override
    public void pay() {
        System.out.println("===发起微信支付===");
    }
}

@Service
public class JingDongPay implements IPay {

    @PostConstruct
    public void init() {
        PayStrategyFactory.register("jingDongPay", this);
    }

    @Override
    public void pay() {
        System.out.println("===发起京东支付===");
    }
}

public class PayStrategyFactory {

    private static Map<String, IPay> PAY_REGISTERS = new HashMap<>();


    public static void register(String code, IPay iPay) {
        if (null != code && !"".equals(code)) {
            PAY_REGISTERS.put(code, iPay);
        }
    }


    public static IPay get(String code) {
        return PAY_REGISTERS.get(code);
    }
}

@Service
public class PayService3 {

    public void toPay(String code) {
        PayStrategyFactory.get(code).pay();
    }
}
```

## 责任链模式

```java
public abstract class PayHandler {

    @Getter
    @Setter
    protected PayHandler next;

    public abstract void pay(String pay);

}

@Service
public class AliaPayHandler extends PayHandler {


    @Override
    public void pay(String code) {
        if ("alia".equals(code)) {
            System.out.println("===发起支付宝支付===");
        } else {
            getNext().pay(code);
        }
    }

}

@Service
public class WeixinPayHandler extends PayHandler {

    @Override
    public void pay(String code) {
        if ("weixin".equals(code)) {
            System.out.println("===发起微信支付===");
        } else {
            getNext().pay(code);
        }
    }
}

@Service
public class JingDongPayHandler extends PayHandler {


    @Override
    public void pay(String code) {
        if ("jingdong".equals(code)) {
            System.out.println("===发起京东支付===");
        } else {
            getNext().pay(code);
        }
    }
}

@Service
public class PayHandlerChain implements ApplicationContextAware, InitializingBean {

    private ApplicationContext applicationContext;
    private PayHandler header;


    public void handlePay(String code) {
        header.pay(code);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        Map<String, PayHandler> beansOfTypeMap = applicationContext.getBeansOfType(PayHandler.class);
        if (beansOfTypeMap == null || beansOfTypeMap.size() == 0) {
            return;
        }
        List<PayHandler> handlers = beansOfTypeMap.values().stream().collect(Collectors.toList());
        for (int i = 0; i < handlers.size(); i++) {
            PayHandler payHandler = handlers.get(i);
            if (i != handlers.size() - 1) {
                payHandler.setNext(handlers.get(i + 1));
            }
        }
        header = handlers.get(0);
    }
}
```

## 其它方式

- 使用枚举代替
  
  ```java
  public String getMessage(int code) {  
       if (code == 1) {  
          return "成功";  
       } else if (code == -1) {  
          return "失败";  
       } else if (code == -2) {  
          return "网络超时";  
       } else if (code == -3) {  
          return "参数错误";  
       }  
       throw new RuntimeException("code错误");  
  }
  //使用枚举以后
  public enum MessageEnum {  
       SUCCESS(1, "成功"),  
       FAIL(-1, "失败"),  
       TIME_OUT(-2, "网络超时"),  
       PARAM_ERROR(-3, "参数错误");  
  
       private int code;  
       private String message;  
  
       MessageEnum(int code, String message) {  
           this.code = code;  
           this.message = message;  
       }  
  
       public int getCode() {  
          return this.code;  
       }  
  
       public String getMessage() {  
          return this.message;  
       }  
  
       public static MessageEnum getMessageEnum(int code) {  
          return Arrays.stream(MessageEnum.values()).filter(x -> x.code == code).findFirst().orElse(null);  
       }  
  }
  //调用方法改造
  public String getMessage(int code) {  
       MessageEnum messageEnum = MessageEnum.getMessageEnum(code);  
       return messageEnum.getMessage();  
  }
  ```

- 使用三目运算符(只能消除两个)
  
  ```java
  public String getMessage2(int code) {  
      return code == 1 ? "成功" : "失败";  
  }
  ```

- 使用断言代替参数检测
  
  ```java
  public void save(Integer code，String name) {  
       if(code == null) {
         throw Exception("code不能为空");     
       } else {
           if(name == null) {
               throw Exception("name不能为空");     
           } else {
               System.out.println("doSave");
           }
       }
   }
  
  public String save2(Integer code，String name) {      
       Assert.notNull(code,"code不能为空"); 
       Assert.notNull(name,"name不能为空"); 
       System.out.println("doSave");
   }
  ```
