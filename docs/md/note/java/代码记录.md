# LocalDate
```java
LocalDate date = LocalDate.of(2014, 3, 18); LocalDate.now();
int year = date.getYear();   
Month month = date.getMonth();   
int day = date.getDayOfMonth();   
DayOfWeek dow = date.getDayOfWeek(); //是周几   
int len = date.lengthOfMonth();    
boolean leap = date.isLeapYear();

//昨天的上一周，也就是7天以前
LocalDate yesterdaySevenDaysAgo = yesterday.minusWeeks(1);
//7天以前所在周的周一
LocalDate yesterdaySevenDaysAgoMonday = yesterdaySevenDaysAgo.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
//7天以前所在周的周日
LocalDate yesterdaySevenDaysAgoSunday = yesterdaySevenDaysAgo.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
```

# 枚举

枚举的本质是一个类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。

```java
public final class Size extends Enum<Size> {//这个类不能被继承
    public static final Size SMALL = new Size("SMALL",0);
    public static final Size MEDIUM = new Size("MEDIUM",1);
    public static final Size LARGE = new Size("LARGE",2);
    
    private static Size[] VALUES = new Size[]{SMALL,MEDIUM,LARGE};
    
    private Size(String name, int ordinal){//构造方法只能私有
        super(name, ordinal);
    }
    
    public static Size[] values(){//编译器添加的
        Size[] values = new Size[VALUES.length];
        System.arraycopy(VALUES, 0, values, 0, VALUES.length);
        return values;
    }
    
    public static Size valueOf(String name){//调用父类方法
        return Enum.valueOf(Size.class, name);
    }
}
```

通过name来获取枚举，希望不存在时返回null，有这么几种写法https://dzone.com/articles/java-enum-lookup-by-name-or-field-without-throwing

```java
		/**
     * 拙劣的实现，异常不应该用于流程控制
     * */
    public static Color trycatchValueOf(String name) {
        try {
            return Color.valueOf(name);
        } catch (Exception ex) {
            return null;
        }
    }

    /**
     * 拙劣的实现，没用异常但是线性查找，这有性能问题吗？可能有，但是微乎其微，不过思想上来说不好
     * */
    public static Color iterationFindByName(String name) {
        for (Color color : Color.values()) {
            if (name.equals(color.name())) {
                return color;
            }
        }
        return null;
    }

	  /**
     * 较优的实现，建立一个map，这里甚至可以不只是索引name，而是可以索引其他的的字段比如color
     * */
    private static final Map<String, Color> nameIndex = 	  Maps.newHashMapWithExpectedSize(Color.values().length);
    static {
        for (Color color : Color.values()) {
            nameIndex.put(color.name(), color);
        }
    }
    public static Color lookupByName(String name) {
        return nameIndex.get(name);
    }

		/**
     * 较优的实现，利用google的库，底层代码来看这里甚至使用了WeakReferences和WeakHashMaps
     * */
    public static Color getIfPresent(String name) {
        return Enums.getIfPresent(Color.class, name).orNull();
    }

		/**
     * 提取模板代码到公共的工具类里边
     * */
    private static final Function<String, Color> func =
            EnumUtil.lookupMap(Color.class, e -> e.name());
    public static Color lookupByDisplayNameUtil(String name) {
        return func.apply(name);
    }

public class EnumUtil {
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(Class<E> clazz, Function<E, T> mapper) {
        @SuppressWarnings("unchecked")
        E[] emptyArray = (E[]) Array.newInstance(clazz, 0);
        //EnumSet.allOf(clazz).toArray 将所有枚举类转为数组
        return lookupMap(EnumSet.allOf(clazz).toArray(emptyArray), mapper);
    }
    //入参是一个枚举数组、一个函数式接口（获得枚举的某个属性），出参仍然是一个函数式接口（获取map的）
    public static <T, E extends Enum<E>> Function<T, E> lookupMap(E[] values, Function<E, T> mapper) {
        Map<T, E> index = Maps.newHashMapWithExpectedSize(values.length);
        for (E value : values) {
            //执行传入的函数式接口，此处就是e -> e.name()
            index.put(mapper.apply(value), value);
        }
        //返回的也是一个函数式接口，根据键值获取值(T key) -> index.get(key);
        return index::get;
    }
}
```

# 流式处理

```java
过滤：filter
去重：distinct
限制：limit
跳过：skip
映射：map
扁平化：flatmap
全查找：allMatch
任意满足：anyMatch
不存在：noneMathch
满足条件的第一个元素：findFirst
任意满足：findAny  
求和：sum
规约：reduce// 采用无初始值的重载版本，需要注意返回Optional
> reduce(0, Integer::sum);
> Optional<Integer> total=reduce(Integer::sum) 
求总数：Collectors.counting()   count()
求最大最小：
// 求最大年龄
Optional<Student> olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -> s1.getAge() - s2.getAge()));

// 进一步简化
Optional<Student> olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));

// 求最小年龄
Optional<Student> olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)));

求总和：Collectors.summingInt(Student::getAge)
求平均：Collectors.averagingInt(Student::getAge)
一次性求个数、总和、均值、最大值、最小值：Collectors.summarizingInt(Student::getAge)
  
字符串拼接：Collectors.joining(", ")
分组：Collectors.groupingBy(Student::getSchool)

多级分组：
Map<String, Map<String, List<Student>>> groups2 = students.stream().collect(
                Collectors.groupingBy(Student::getSchool,  // 一级分组，按学校
                Collectors.groupingBy(Student::getMajor)));// 二级分组，按专业

Map<String, Long> groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting()));//二级分组计数


分区：在分区中 key 只有两种情况：true 或 false
Map<Boolean, List<Student>> partition = students.stream().collect(Collectors.partitioningBy(student -> "武汉大学".equals(student.getSchool())));

排序：list.stream().sorted((a, b) -> a.compareTo(b))
  	 list.stream().sorted(Comparator.comparing(o -> o.action_time))//action_time是字符串
```

# Optional

- 消除连续判空频繁的if...if...

```java
//java8以前的判空
public static Date getGraduationTime(UserInfo userInfo){
     if (null != userInfo){
         if (null != userInfo.getEducation()){
             return userInfo.getEducation().getGraduationTime();
         }
     }
     return null;
 }

//使用java8的optional以后
public static Date getGraduationTime(UserInfo userInfo){
  return Optional.ofNullable(userInfo)
    .map(UserInfo::getEducation)
    .map(Education::getGraduationTime)
    .orElse(null);
}
```

- 接口

>- empty()
>
>- of(T value)
>
>  参数传入一个对象，返回一个Option对象，value不能为空，如果为null，将抛出空指针异常
>
>- ofNullable(T value)
>
>  参数传入一个对象，可以为空，如果为空，将返回一个空的Optional对象，就等于Optional.empty()，输出的值为`Optional.empty`,如果不为空，返回一个不为空的Optional对象
>
>- get()
>
>  获取Optional中的值，这个值也就是我们的值，Optional相当于就是一个外壳
>
>- isPresent()
>
>  判断Optional对象中是否有值，如果有值，返回true，没值返回false
>
>- ifPresent(Consumer<? super T> consumer)
>
>  ifPresent参数是一个函数式接口，无返回值，会将Optional中的值作为参数传递到
>
>  ifPresent()中
>
>- map(Function<? super T, ? extends U> mapper)
>
>  参数是一个Function函数式接口，会将Optional中的值作为参数传递到map中，如果传入的值为空，则返回一空的Optional对象，相当于Optional.empty(), 如果不为空，我们可以返回一个可以描述描述结果的返回值(Optional中的值，这个值可以重新赋值)，如下面的返回一个tempUser
>
>- flatMap(Function<? super T, Optional> mapper)
>
>  如果Optional中值存在，那么返回一个基于Optional的值(如Optional)，如果Optional中的值不存在，则返回一空的Optional对象，相当于Optional.empty()，与map不同， map返回的是一个值，而flatMap返回一个基于Optional的值
>
>  与map的区别在于flatmap会抹除Optional的嵌套
>
>  ```java
>  Optional<String> optional = Optional.ofNullable(user).flatMap(OptionalTest::getFlatMap);
>         
>  Optional<Optional<String>> optional = Optional.ofNullable(user).map(OptionalTest::getFlatMap);
>  public static Optional<String> getFlatMap(User user){
>     return Optional.ofNullable(user).map(User::getUsername);
>  }
>  ```
>
>- orElse(T other)
>
>  如果Optional中的值不为空，则返回Optional中的值，如果为空，则返回other值
>
>- orElseGet(Supplier<? extends T> other)
>
>  如果Optional中存在值，则返回值，否则返回other调用的结果
>
>- orElseThrow(Supplier<? extends X> exceptionSupplier)
>
>  如果Optional中的值存在，则返回值，值不存在，则抛出异常函数Supplier中的异常

- Optional推荐作为方法结果输出，而不建议作为参数输入，意思就是用来预防返回的数据为空，而不是调用时候在参数里带上optional

# Jackson

忽略不要的字段

```java
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
```

# Maven

```shell
#查看某个包是怎么引入的
dependency:tree -Dverbose -Dincludes=org.mybatis:mybatis
```

**dependenciesManagement**写在父pom里，只会标记版本号，子pom不会继承，子pom引入的时候不需要version，会循着父pom逐级往上找寻找到version。

- Maven的snapshot版本，主要是为了两方同时开发，不同于常规的版本，Maven 每次构建都会在远程仓库中检查新的快照。 版本如果下载到了本地，如果不更新版本号，是不会去远程仓库寻找新的jar包的，只会在本地找。

要想发布，需要在代码中加上：

```xml
<distributionManagement>
        <repository>
            <id>meituan-nexus-releases</id>
            <name>Meituan Nexus Releases Repository</name>
            <url>http://XXX/content/repositories/releases/</url>
        </repository>

        <snapshotRepository>
            <id>meituan-nexus-snapshots</id>
            <name>Meituan Nexus Snapshots Repository</name>
            <url>http://XXX/nexus/content/repositories/snapshots/</url>
        </snapshotRepository>
</distributionManagement>
```

 # web开发

## 1. 参数校验

这里比较全面https://mp.weixin.qq.com/s/tEdUUfdndwktTMB8oDYU5g

```java
//JSR校验
@Data
public class StudentDTO {
    @NotEmpty(message = "用户姓名不允许为空")
    private String name;

    @Pattern(regexp = "1\\d{10}", message = "手机号格式不正确")
    private String telephone;

    @Email(message = "邮箱格式不正确")
    private String email;
}

//自定义注解校验
@Documented
@Retention(RUNTIME)
@Target({FIELD, METHOD, PARAMETER, TYPE})
@Constraint(validatedBy = NotConflictAccount.NotConflictAccountValidator.class)
public @interface NotConflictAccount {
    String message() default "用户名称不是123";

    Class<?>[] groups() default {};//校验分组

    Class<? extends Payload>[] payload() default {};

    class NotConflictAccountValidator implements ConstraintValidator<NotConflictAccount, StudentDTO> {

        @Override
        public boolean isValid(StudentDTO student, ConstraintValidatorContext constraintValidatorContext) {
            if (!student.getName().equals("123")) {
                return false;
            }
            return true;
        }
    }
}

//需要校验的步骤
@RestController
@RequestMapping("api/validate")
@Slf4j
@Validated
public class ValidationController {
    @PostMapping
    public Result test(@Valid @RequestBody @NotConflictAccount StudentDTO studentDTO){
        return Result.ok(studentDTO);
    }
}
```

- 建议：如果是简单参数校验直接使用参数校验，复杂且常用的使用自定义校验，更复杂的使用在业务代码中校验抛出异常然后全局统一捕获异常

## 2. 统一返回

```java
@Data
@AllArgsConstructor
@RequiredArgsConstructor
public class Result<T> implements Serializable {
    private static final long serialVersionUID = 1L;

    private Integer status;
    private String msg;
    private T data;

    public static <T> Result<T> ok(T data) {
        return new Result<>(HttpStatus.OK.value(), HttpStatus.OK.getReasonPhrase(), data);
    }
}

@GetMapping("/getAllStudent")
    @ResponseBody
    @Tag(name="getAllStudent")
    public Result<PageInfo<StudentVO>> studentList(@RequestParam(defaultValue = "1") Integer currentPage,
                                                   @RequestParam(defaultValue = "10") Integer pageSize) {
        return Result.ok(studentBiz.pageQuery(currentPage, pageSize));
    }
```

- 统一返回的另外一种写法，不需要再在controller里写result了而是借助ResponseBodyAdvice<Object>拦截通过beforeBodyWrite方法进行包装，对于不需要包装的可以打一个注解在support方法里进行排除

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.wyj.annotation.NotControllerResponseAdvice;
import com.wyj.response.Result;
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

@RestControllerAdvice(basePackages = {"com.wyj.controller.interceptController"})
public class ControllerResponseAdvice implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter methodParameter, Class<? extends HttpMessageConverter<?>> aClass) {
        // response是Result类型，或者注释了NotControllerResponseAdvice都不进行包装
        return !(methodParameter.getParameterType().isAssignableFrom(Result.class)||methodParameter.hasMethodAnnotation(NotControllerResponseAdvice.class));
    }

    @Override
    public Object beforeBodyWrite(Object data, MethodParameter returnType, MediaType mediaType, Class<? extends HttpMessageConverter<?>> aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {
        if (returnType.getGenericParameterType().equals(String.class)) {
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                // 将数据包装在ResultVo里后转换为json串进行返回
                return objectMapper.writeValueAsString(Result.ok(data));
            } catch (JsonProcessingException e) {
                throw new MeaningfulException(500, e.getMessage());
            }
        }
        // 否则直接包装成ResultVo返回
        return Result.ok(data);
    }
}

//需要排除的打下面的注解进行排除
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface NotControllerResponseAdvice {
}
```



## 3. 统一异常处理

```java
//统一的异常类
@Data
public class MeaningfulException extends RuntimeException {
    private static final long serialVersionUID = 3773770775333164849L;

    private final int errCode;

    public MeaningfulException(int errCode, String message) {
        super(message);
        this.errCode = errCode;
    }
}

//统一的异常处理中心
@RestControllerAdvice
@Slf4j
public class WebExceptionHandler {
    @ExceptionHandler(MeaningfulException.class)
    public Result<?> handleMeaningfulException(MeaningfulException ex) {
        log.error("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getLocalizedMessage());
        log.debug("handle meaningful exception. code:{} msg:{}", ex.getErrCode(), ex.getLocalizedMessage(), ex);
        return new Result<>(ex.getErrCode(), ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(Exception.class)
    public Result<?> common(Exception ex) {
        log.error("handle exception. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle exception. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(Throwable.class)
    public Result<?> commonThrowable(Throwable ex) {
        log.error("handle throwable. ex:{} msg:{}", ex.getClass().getName(), ex.getLocalizedMessage());
        log.debug("handle throwable. msg:{}", ex.getLocalizedMessage(), ex);
        return new Result<>(500, ex.getLocalizedMessage(),"");
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<?> handleValidException(MethodArgumentNotValidException ex) {
        log.error("valid exception{}",ex.getMessage());
        var stringBuilder = new StringBuilder();
        ex.getBindingResult().getAllErrors().stream().forEach(it->stringBuilder.append(it.getDefaultMessage()).append(","));
        return new Result<>(500,  stringBuilder.toString(),"");
    }
}

@RestController
@RequestMapping("api/exception")
@Slf4j
public class ExceptionController {
    @GetMapping("/meaningException")
    public void meaningfulException(){
        /**
         * 实际上会被WebExceptionHandler捕获处理
         * */
        throw new MeaningfulException(500,"接收话术录音文件不合法");
    }

    @GetMapping("/Exception")
    public void exception() throws Exception {
        throw new Exception("dadsda");
    }
}
```

## 4. 参数校验、统一异常处理与统一返回的关系

>- 参数校验有问题时会抛出异常，这个异常统一处理
>- 异常处理时将返回结果统一到统一返回的格式

## 5. 枚举传参

- 前后端传参，前端传数字，后端转为枚举值，传给前端时再转为数字

  ```java
  //前后端互转
  public enum GenderEnum {
      /*
      对应性别的枚举男性
      */
      MAN(1, "男"),
      /*
      对于性别的枚举女性
      */
      WOMAN(2, "女");
  
      private int code;
      private String value;
  
      GenderEnum(int code, String value) {
          this.code = code;
          this.value = value;
      }
  
      /**
       * 前端给的时候反序列化成枚举,注意的一点是如果不自己实现，spring也会默认转枚举，但是它是按照下标顺序取的
       * */
      @JsonCreator
      public static GenderEnum getGenderEnumByCode(Integer code) {
          switch (code) {
              case 1:
                  return WOMAN;
              default:
                  return MAN;
          }
      }
  
      /**
       * 给前端时序列化成数字
       * */
      @JsonValue
      public int getCode() {
          return code;
      }
  }
  ```

  - 后端与数据库传参，数据库存数字

  ```java
  //基于mybatis互转
  public class GenderEnumHandler extends BaseTypeHandler<GenderEnum> {
  
      /**
       * 写库时写枚举码
       * */
      @Override
      public void setNonNullParameter(PreparedStatement preparedStatement, int i, GenderEnum genderEnum, JdbcType jdbcType) throws SQLException {
          preparedStatement.setInt(i, genderEnum.getCode());
      }
  
      /**
       * 使用列名，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(ResultSet resultSet, String s) throws SQLException {
          return GenderEnum.getGenderEnumByCode(resultSet.getInt(s));
      }
  
      /**
       * 使用下标，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(ResultSet resultSet, int i) throws SQLException {
          return GenderEnum.getGenderEnumByCode(resultSet.getInt(i));
      }
  
      /**
       * 存储过程专用，查库时转为枚举值
       * */
      @Override
      public GenderEnum getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
          return GenderEnum.getGenderEnumByCode(callableStatement.getInt(i));
      }
  }
  
  //插入这个转换器
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
      <typeHandlers>
          <typeHandler handler="com.wyj.handler.GenderEnumHandler" javaType="com.wyj.enums.GenderEnum" />
      </typeHandlers>
  </configuration>
    
   <resultMap id="BaseResultMap" type="com.web.entity.Student">
    //用于查询时转换
      <result column="sex" jdbcType="INTEGER" property="sex" typeHandler="com.web.handler.GenderEnumHandler" /> 
    </resultMap>
    
    <insert id="insert" parameterType="com.web.entity.Student">
      insert into student (sex)
      //用于插入时转换
      values (#{sex,jdbcType=INTEGER,typeHandler=com.web.handler.GenderEnumHandler})
    </insert>
  ```
  
  - 当用枚举传参时的一些转化
  
  >- 涉及到前端、后端、数据库传参时传什么、存什么
  >- 前端给后端传：传枚举码转化为枚举类在代码中使用，涉及到枚举值转枚举类
  >- 后端给前端：传枚举码给前端，涉及到枚举类转枚举值
  >- 后端给数据库：存枚举码，涉及到枚举类转枚举值
  >- 数据库给后端：将查出来的枚举码转为枚举类使用
  >
  >综上来看，只有代码中使用枚举类，传给前端以及存到数据库的都应该是枚举值，每次涉及到正反两方面的转化。
  >
  >- 与数据库互转时，一般使用ORM框架插件处理
  >- 与前端互转时，使用一些序列化注解辅助

## 6. 数据拷贝

```java
//基于mapstruct的数据转换
@Mapper
public interface StudentConverter {
    StudentConverter MAPPER=Mappers.getMapper(StudentConverter.class);
    StudentVO toVo(Student student);
    List<StudentVO> entity2VO(List<Student> student);
}
```

> 但是同时使用lombok与mapstruct有时会有问题，主要原因是这两个都是在编译阶段起作用，因此需要引入插件处理，有时还要保证顺序

```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <annotationProcessorPaths>
      <!--保证顺序-->
      <path>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.20</version>
      </path>
      <path>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct-processor</artifactId>
        <version>${org.mapstruct.version}</version>
      </path>
    </annotationProcessorPaths>
  </configuration>
</plugin>
```

## 7. 切面与注解

基于注解做切面，可以用来打日志、限流等操作

```java
//定义一个注解
@Order(Ordered.HIGHEST_PRECEDENCE)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface Tag {
    // 资源名称，用于描述接口功能
    String name() default "";
}

//对打了注解的做处理
@Aspect
@Component
@Slf4j
public class TagAspect {

    /**
     打了com.annotation.ApiLimit的作为一个切面
     * */
    @Pointcut("@annotation(com.wyj.annotation.Tag)")
    public void pointcut() {
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        /**
         * 得到请求
         * */
        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();
        /**
         * 得到方法签名
         * */
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        /**
         * 得到方法
         * */
        Method signatureMethod = signature.getMethod();
        Tag tag = signatureMethod.getAnnotation(Tag.class);
        String name = tag.name();
        log.info("http method {}", name);
        return joinPoint.proceed();
    }
}
```

## 8. 分片处理

```java
final var partion = Lists.partition(dataList, split);
partion.forEach(it -> {
  处理 it
});
```

## 9. 分页处理Mybatis、PageHelper

```java
PageHelper.startPage(currentPage, pageSize);
        final List<AggregateCityResult> res = 查询;
        PageInfo pageAggregateCityResults = new PageInfo(res);
        final List<CityVO> cityVOS = new ArrayList<>();
        res.forEach(data->{
            //这里做转换
            final var cityVO = new CityVO();
            ...
            cityVOS.add(cityVO);
        });
        //这里重写分页后的list
        pageAggregateCityResults.setList(cityVOS);
        return pageAggregateCityResults;
```

## 10.下载文件

```java
@GetMapping("/test10")
    public void trendAnalyseReport(@RequestParam("template") String template,
                                       HttpServletResponse response
    ) throws IOException {
        //log.info("input param {}", sortClause);
        final var workbook = overViewBiz.trendAnalyseReport(template);
        var name = template == null ? "" : template +"_"+ LocalDate.now();
        transFile(response, workbook, name+".xlsx");
    }

private void transFile(HttpServletResponse response, Workbook workbook, String filename)  {
        if (workbook != null) {
            response.setHeader("Content-Disposition", "attachment;filename=" + filename);
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8");
            response.setHeader("Pragma", "no-cache");
            response.setHeader("Cache-Control", "no-cache");
            response.setDateHeader("Expires", 0);
            try (final var out = response.getOutputStream()) {
                workbook.write(out);
            } catch (IOException e) {
                throw new BizException(500, "excel导出失败", e);
            }
        } else {
            throw new BizException(500, "excel导出为空");
        }
    }
```

## 11. 重试

```java
@Service
@Slf4j
public class RetryService {

  //异常时重试，最大重试2次，第一次重试时每次暂停2秒，以后延迟1.5倍（每次隔2,3,4.5秒后重试）
    @Retryable(value = Exception.class, maxAttempts = 2, backoff = @Backoff(delay = 2000, multiplier = 1.5))
    public void test() throws Exception {
        int i = new Random().nextInt(2);
        log.info("random num:{}", i);
        if (i==1){
            throw new Exception("异常了");
        }
        log.info("正常执行");
    }

    //重试最大次数以后默认会执行这个方法,参数要与上述异常一致，需要写在同一个类里面
    @Recover
    public void recover(Exception e) {
        log.info("回调方法执行！");
    }
}
```



## 12. 异步

```java
@Service
public class AsyncService {
    @Async("myExcutor")//使用自己定义的线程池
    public void sleep() throws InterruptedException {
        Thread.sleep(5000);
    }
}

@Configuration
public class ExecutorConfig {
    @Bean
    public Executor myExcutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(1);
        executor.setMaxPoolSize(3);
        executor.setQueueCapacity(5);
        executor.setKeepAliveSeconds(10);
        executor.setThreadNamePrefix("mafka-producer");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

//在启动类上加上@EnableAsync
```

## 13. 测试

可能用到的一些依赖

``` xml
<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-test</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-test</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-test-autoconfigure</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-core</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>com.jayway.jsonpath</groupId>
  <artifactId>json-path</artifactId>
</dependency>
```

service层mock dao层数据

```java
package com.wyj.controller;

import com.wyj.dao.PassiveCallInfoDao;
import com.wyj.entity.PassiveCallInfo;
import com.wyj.service.PassiveCallInfoService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit4.SpringRunner;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.mockito.Mockito.when;
import static org.hamcrest.core.IsEqual.equalTo;

/**
 * @author wyj
 */

@RunWith(SpringRunner.class)
@SpringBootTest
public class ServiceMock {
    @Autowired
    private PassiveCallInfoService passiveCallInfoService;
    @MockBean
    private PassiveCallInfoDao passiveCallInfoDao;

    @Test
    public void test1(){//搭配mock使用
        final var passiveCallInfo=new PassiveCallInfo();
        passiveCallInfo.setComplainTag("true");
        when(passiveCallInfoDao.selectByPrimaryKey(32L)).thenReturn(passiveCallInfo);
        assertThat(passiveCallInfoService.selectByPrimaryKey(32L).getComplainTag(),equalTo("true"));
    }

}
```

service层直接测试

```java
package com.wyj.controller;

import com.wyj.service.PassiveCallInfoService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.IsEqual.equalTo;

@RunWith(SpringRunner.class)
@SpringBootTest
public class ServiceFact {
    @Autowired
    private PassiveCallInfoService passiveCallInfoService;

    @Test
    public void test2(){
        assertThat(passiveCallInfoService.selectByPrimaryKey(32L).getComplainTag(),equalTo("32"));
    }
}
```

controller层mock service层数据

```java
package com.wyj.controller;

import com.wyj.dao.PassiveCallInfoDao;
import com.wyj.entity.PassiveCallInfo;
import com.wyj.service.PassiveCallInfoService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit4.SpringRunner;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.mockito.Mockito.when;
import static org.hamcrest.core.IsEqual.equalTo;

/**
 * @author wyj
 */

@RunWith(SpringRunner.class)
@SpringBootTest
public class ServiceMock {
    @Autowired
    private PassiveCallInfoService passiveCallInfoService;
    @MockBean
    private PassiveCallInfoDao passiveCallInfoDao;

    @Test
    public void test1(){//搭配mock使用
        final var passiveCallInfo=new PassiveCallInfo();
        passiveCallInfo.setComplainTag("true");
        when(passiveCallInfoDao.selectByPrimaryKey(32L)).thenReturn(passiveCallInfo);
        assertThat(passiveCallInfoService.selectByPrimaryKey(32L).getComplainTag(),equalTo("true"));
    }

}
```

controller层直接测试

```java
package com.wyj.controller;

import com.wyj.service.PassiveCallInfoService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mock.web.MockHttpSession;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringRunner.class)
@SpringBootTest
/**
 * 1 这个注解用于集成测试，也就是默认会加载完整的Spring应用程序并注入所有所需的bean。一般会通过带有@SpringBootApplication的配置类来实现。
 * 2 由于会加载整个应用到Spring容器中，整个启动过程是非常缓慢的（10+秒起步），一般会用于集成测试，可以使用TestRestTemplete或者MockMvc来发起请求并验证响应结果。
 * 3 SpringBootTest中的也可以使用Mockito等Mock工具来对某些bean进行mock，但是一般不会只对单个层进行测试，推荐用于单个应用的端到到集成测试。
 * 4 如果涉及到第三方依赖，如数据库、服务间调用、Redis等，可以考虑服务虚拟化方案。
 */
public class ControllerFact {

    private MockMvc mockMvc;

    @Autowired
    private WebApplicationContext wac;

    @Before
    public void setupMockMvc(){
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象
    }

    @Test
    public void test4() throws Exception {
        final var authResult=mockMvc.perform(MockMvcRequestBuilders.get("/hello2").param("id", String.valueOf(32L)))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.complainTag").value("32"))
                .andReturn().getResponse().getContentAsString();
        System.out.println("返回结果"+authResult);
    }
}
```

使用http测试

``` java
package com.wyj.controller;

import com.wyj.entity.PassiveCallInfo;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.web.client.RestTemplate;

import java.util.HashMap;
import java.util.Map;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.IsEqual.equalTo;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
public class HttpRequestTest {
    @LocalServerPort//随机端口有助于在测试环境中避免冲突
    private int port;

    @Autowired
    RestTemplateBuilder builder;

    private RestTemplate restTemplate;

    @Before
    public void restTemplate() {
        restTemplate=builder.build();
    }

    @Test
    public void test1(){
        String x=restTemplate.getForObject("http://localhost:"+port+"/hello",String.class);
        assertThat(x, equalTo("hello"));
    }

    @Test
    public void test2(){
        Map<String, String> params = new HashMap<>();
        params.put("id", "32");
        PassiveCallInfo x=restTemplate.getForObject("http://localhost:"+port+"/hello2"+"?id={id}", PassiveCallInfo.class,params);
        assertThat(x.getTargetNumToken(), equalTo("321"));
    }
}
```

14. 其它技巧

springboot启动时不报错，直接退出，使用trycatch包住启动代码，查看异常

```java
try {
  SpringApplication.run(Pallas.class, args);
}catch(Throwable e) {
  e.printStackTrace();
}
```

```java
//springboot读取resource下的文件
public void testReadFile() throws IOException {
//        ClassPathResource classPathResource = new ClassPathResource("resource.properties");
        Resource resource = new ClassPathResource("resource.properties");
        InputStream is = resource.getInputStream();
        InputStreamReader isr = new InputStreamReader(is);
        BufferedReader br = new BufferedReader(isr);
        String data = null;
        while((data = br.readLine()) != null) {
            System.out.println(data);
        }
        
        br.close();
        isr.close();
        is.close();
    }
```

# 常用的轮子

常用库

1. 使用Objects.equals(strA, strB)比较两个对象是否相等，避免对左边对象判空
2. 使用commons-lang3操作字符串，包装临时对象Pair与Trible
3. 使用commons-collections集合工具类操作集合
4. 使用common-beanutils 操作对象，进行对象和map互转
5. 使用commons-io 文件流处理，读文件、写文件以及复制文件等
6. 使用Guava操作集合，新建、切分集合，使用Multimap可以一个key映射多个value的HashMap，使用BiMap一种连value也不能重复的HashMap，实质是双向的映射，kv可以实现互转，Table可以有两个key的Hashmap，Multiset一种用来计数的Set

## Collections

>java.util.Collections
>
>用于求最大、最小、排序、翻转、转换线程安全、返回空集合、做二分查找、转换为不可修改集合

## CollectioinUtils

>一个是spring自带的：org.springframework.util.CollectionUtils
>
>一个是apache下的：org.apache.commons.collections.CollectionUtils，这个提供的更多、更全面
>
>提供了集合判空、交并补等等

## Lists

>com.google.common.collect`包下的集合工具：`Lists
>
>创建空集合、快速初始化集合、笛卡尔积、分页、流处理、翻转

## Objects

>java自带的工具类java.util.Objects
>
>对象判空、判空抛异常、判断对象是否相等、获取hash码

## BooleanUtils

>commons-lang3：BooleanUtils
>
>判断true、false、非true、false、转换数字、包装类转换、

## StringUtils

>org.apache.commons.lang3包下的`StringUtils
>
>判空、分割、判断是否纯数字、集合拼接、

## Assert

>Spring提供
>
>断言参数是否为空、断言集合是否为空

## IOUtils

>org.apache.commons.io包下的`IOUtils
>
>读文件为字符串、字节数组、迭代器、写文件、拷贝文件

## MDC

>org.slf4j
>
>用来传递线程安全的诊断日志的容器

## ClassUtils

>Spring提供的
>
>获取对象所有接口、某个类的包名、某个类是否是内部类、是否是代理对象

## BeanUtils

>Spring提供的
>
>拷贝对象、实例化·、获取指定类的指定方法、指定方法的参数

## ReflectionUtils

>Spring提供的
>
>获取方法、字段、执行方法、字段是否常量、是否是Equals方法

## Base64Utils

>Spring提供的
>
>decode、ecode

## StandardCharsets

>java.nio.charset
>
>转换字符编码

## DigestUtils

>`org.apache.commons.codec.digest`包下的`DigestUtils`类。
>
>各种加密

## SerializationUtils

>org.springframework.util包下的`SerializationUtils
>
>序列化、反序列化

## HttpStatus

>`org.springframework.http`包下的HttpStatus枚举
>
>提供常见的状态码
