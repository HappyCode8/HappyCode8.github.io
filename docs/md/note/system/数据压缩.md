# 数据压缩

HashMap<Integer, V>   ->  IntObjectHashMap<V>

Set<Integer> -> intSet

IntObjectHashMap，这个类出自 Netty，根据https://www.bilibili.com/video/BV1eX4y1F7zJ?p=2的测算，存入10000个数据，开销降低40%-60%

IntSet节省80%，不生成Integer对象，GC性能更好

- IntObjectHashMap对key冲突时使用的是开放寻址策略中的线性探测
- 它的key限制了就是int类型的值，所以初始化时不能指定key的类型
- 它内部有key[],value[]两个数组

HashMap的结构是 Node[] table; Node 下面有Hash，Key，Value，Next四个属性。
而IntObjectHashMap的结构是int[] keys 和 Object[] values.
在插入时，同样把int先取模落桶，如果遇到冲突，则不采样HashMap的链地址法，而是用开放地址法（线性探测法）index＋1找下一个空桶，最后在keys[index]，values[index]中分别记录。在查找时也是先落桶，然后在key[index++]中逐个比较key。
所以，对比整个数据结构，省的不止是int vs Integer，还有每个Node的内容。
而性能嘛，IntObjectHashMap还是稳赢一点的，随便测了几种场景，耗时至少都有24ms vs 28ms的样子，好的时候甚至快1/3。

# CQRS

Command Query Responsibility Segregation（命令查询职责隔离）

例如电商系统，包含订单、用户、商品等等数据，数据的变更操作、查询操作，都是基于这一套数据模型的。但是，实际场景下的查询需求是多种多样。例如这3类人群：

- 商家
- 买家用户
- 电商运营人员

他们的数据视角是不同的，各自的关注角度不同，需要查询的数据就完全不同，但数据模型是一套啊，怎么办？是不是就需要做数据关联、构建临时数据集合等等复杂的操作啊，基于一种数据模型，来实现 N 种视角的查询，既别扭又麻烦。

- CQRS 把数据的变更和查询拆开了，有各自的数据模型。

- 命令模型负责数据的变更，并把最新数据同步给查询模型。

- 查询模型根据自己的想法来安排数据，想怎么用就怎么用。

- 好处是可以让查询更加自由，更快的满足多变的业务需求。

- 坏处是增加了架构的复杂度，还有数据同步带来的问题。

